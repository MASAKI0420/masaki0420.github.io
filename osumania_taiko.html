<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- ↓ PWAに必要な設定を追加 -->
    <meta name="theme-color" content="#1f2940"/>
    <link rel="manifest" href="manifest.json">
    <!-- ↑ PWAに必要な設定を追加 -->
    <title>Rhythm Game Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* --- Global and Game Selector Styles --- */
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: #0d0d1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            color: white;
        }

        .game-wrapper {
            width: 100%;
            height: 100%;
            display: none; /* Initially hidden */
        }
        
        #mania-wrapper #game-container.playing,
        #taiko-wrapper #taiko-game-container.playing {
            cursor: none;
        }

        #game-selector {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 30px;
            text-align: center;
        }

        #game-selector h1 {
            font-size: 3em;
            font-weight: 600;
            color: #e0e5f0;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }

        .game-select-button {
            padding: 20px 40px;
            font-size: 1.5em;
            font-weight: 500;
            color: white;
            border: 2px solid #4a5578;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: #1f2940;
            min-width: 300px;
        }

        #select-mania:hover {
            background-color: #3d7eff;
            border-color: #3d7eff;
            box-shadow: 0 0 20px #3d7eff;
        }

        #select-taiko:hover {
            background-color: #d9534f;
            border-color: #d9534f;
            box-shadow: 0 0 20px #d9534f;
        }

        /* --- osu!mania Styles (Scoped) --- */
        #mania-wrapper {
            --num-lanes: 4;
            --note-height: 22px;
            --receptor-size: 70px;
            --judgment-line-pos: 15vh;
            --judgment-text-top: 65vh;
            --panel-bg: #1f2940;
            --panel-text: #e0e5f0;
            --panel-border: #4a5578;
            --accent-color: #3d7eff;
            --disabled-color: #555c6f;
            --background-brightness: 0.5;
            --combo-size-scale: 1.0;
            --combo-position-y: 45%;
            --lane-opacity: 0.5;
            --playfield-bg-opacity: 0.5;
        }
        #mania-wrapper #video-background {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            
            /* ★★★【Maniaの動画サイズ調整はここ】★★★ */
            width: 110%;
            height: auto;
        }

        /* ▼ Taikoの動画専用スタイル (セレクタを修正しました) */
        #taiko-wrapper #taiko-background-video {
            position: fixed;
            top: -7%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            
            /* ★★★【Taikoの動画サイズ調整はここ】★★★ */
            width: 212%;
            height: auto;
        }

        /* ▼ 画像専用スタイル (Mania/Taiko共通, 全体表示で固定) */
        #mania-wrapper #image-background, #taiko-wrapper #taiko-background-image {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            object-fit: contain; /* 画像全体を表示 */
        }

        /* ▼ Mania専用の追加スタイル (表示切替と明るさ) */
        #mania-wrapper #video-background, #mania-wrapper #image-background {
            display: none;
            filter: brightness(var(--background-brightness));
        }
        #mania-wrapper #app-container { z-index: 2; position: relative; display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; }
        #mania-wrapper #controls-panel {
            width: 95%;
            max-width: 900px;
            background-color: var(--panel-bg);
            border: 1px solid var(--panel-border);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            color: var(--panel-text);
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr auto auto auto;
            gap: 20px 25px;
            align-items: flex-start;
            transform: scale(0.75); /* ▼▼▼ 変更点 ▼▼▼ */
        }
        #mania-wrapper .panel-column { display: flex; flex-direction: column; gap: 20px; min-height: 350px; }
        #mania-wrapper #beatmap-library-selector { width: 100%; background-color: #2a344d; color: var(--panel-text); border: 1px solid var(--panel-border); border-radius: 6px; padding: 8px; height: 190px; }
        #mania-wrapper #beatmap-library-selector option { padding: 5px; }
        #mania-wrapper .library-buttons, #mania-wrapper .settings-buttons { display: flex; gap: 10px; }
        #mania-wrapper .library-buttons .control-button { flex-grow: 1; }
        #mania-wrapper #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; overflow: hidden; display: none; z-index: 10; }
        #mania-wrapper #playfield { position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 100%; max-width: 500px; height: 100%; z-index: 10; }
        #mania-wrapper #playfield-background { position: absolute; width: 100%; height: 100%; background-color: #000; z-index: -1; display: none; opacity: var(--playfield-bg-opacity); }
        #mania-wrapper .grid-item-full { grid-column: 1 / -1; }
        #mania-wrapper #controls-panel h2 { grid-column: 1 / -1; text-align: center; margin: 0 0 10px 0; font-size: 1.8em; font-weight: 600; }
        #mania-wrapper #controls-panel label { font-size: 0.9em; font-weight: 500; color: #a0a8c0; margin-bottom: 8px; display: block; }
        #mania-wrapper #controls-panel p { grid-column: 1 / -1; font-size: 0.8em; color: #828aa1; text-align: center; margin: 0; }
        #mania-wrapper input[type="file"] { width: 0.1px; height: 0.1px; opacity: 0; overflow: hidden; position: absolute; z-index: -1; }
        #mania-wrapper .control-button, #mania-wrapper .styled-select { width: 100%; padding: 12px; font-size: 1em; font-weight: 500; color: var(--panel-text); background-color: #394362; border: 1px solid var(--panel-border); border-radius: 8px; cursor: pointer; transition: background-color 0.2s; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23e0e5f0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 1em top 50%; background-size: .65em auto; padding-right: 2.5em; }
        #mania-wrapper .control-button:hover, #mania-wrapper .styled-select:hover { background-color: #4a5578; }
        #mania-wrapper .control-button:disabled, #mania-wrapper .styled-select:disabled { background-color: var(--disabled-color); cursor: not-allowed; color: #8c92a3; }
        #mania-wrapper input[type="range"] { -webkit-appearance: none; width: 100%; height: 6px; background: #2a344d; border-radius: 3px; outline: none; cursor: pointer; }
        #mania-wrapper input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--accent-color); border-radius: 50%; cursor: pointer; }
        #mania-wrapper input[type="number"] { width: 100%; background-color: #2a344d; color: var(--panel-text); border: 1px solid var(--panel-border); border-radius: 6px; padding: 8px; text-align: center; font-size: 1em; box-sizing: border-box; }
        #mania-wrapper #key-config-inputs { display: flex; justify-content: space-between; gap: 5px; width: 100%; }
        #mania-wrapper .key-config-input { flex-grow: 1; height: 45px; background-color: #2a344d; border: 1px solid var(--panel-border); border-radius: 6px; color: var(--panel-text); font-size: 1.3em; font-weight: bold; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; user-select: none; }
        #mania-wrapper .key-config-input:hover { background-color: #394362; }
        #mania-wrapper .key-config-input:focus, #mania-wrapper .key-config-input.is-waiting { background-color: var(--accent-color); border-color: var(--accent-color); outline: none; color: white; }
        #mania-wrapper .checkbox-wrapper { display: flex; align-items: center; cursor: pointer; }
        #mania-wrapper input[type="checkbox"] { display: none; }
        #mania-wrapper .custom-checkbox { width: 20px; height: 20px; background-color: #2a344d; border: 1px solid var(--panel-border); border-radius: 4px; display: inline-block; position: relative; margin-right: 10px; transition: background-color 0.2s; }
        #mania-wrapper input[type="checkbox"]:checked + .custom-checkbox { background-color: var(--accent-color); }
        #mania-wrapper .custom-checkbox::after { content: ''; position: absolute; left: 6px; top: 2px; width: 5px; height: 10px; border: solid white; border-width: 0 3px 3px 0; transform: rotate(45deg); display: none; }
        #mania-wrapper input[type="checkbox"]:checked + .custom-checkbox::after { display: block; }
        #mania-wrapper #start-button { grid-column: 1 / -1; padding: 15px; font-size: 1.2em; font-weight: 600; color: white; background-color: var(--accent-color); border: none; }
        #mania-wrapper #start-button:disabled { background-color: var(--disabled-color); }
        #mania-wrapper #song-info { grid-column: 1 / -1; min-height: 20px; text-align: center; }
        #mania-wrapper .offset-controls-container { display: flex; gap: 10px; }
        #mania-wrapper .offset-control { flex: 1; }
        #mania-wrapper #lanes-container { display: flex; height: 100%; }
        #mania-wrapper .lane { width: calc(100% / var(--num-lanes)); height: 100%; border-left: 1px solid rgba(255, 255, 255, 0.2); background-color: rgba(0,0,0, var(--lane-opacity)); position: relative; box-sizing: border-box; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
        #mania-wrapper .lane:last-child { border-right: 1px solid rgba(255, 255, 255, 0.2); }
        #mania-wrapper #judgment-line { position: absolute; bottom: var(--judgment-line-pos); left: 0; width: 100%; height: 2px; background-color: rgba(255,255,255,0.8); box-shadow: 0 0 10px white; z-index: 15; }
        #mania-wrapper .note-wrapper { position: absolute; left: 0; width: 100%; top: 0; will-change: transform; pointer-events: none; display: flex; justify-content: center; }
        #mania-wrapper .note-wrapper.hidden { display: none; }
        #mania-wrapper .note-wrapper:has(.long-note-body) .note { position: relative; z-index: 2; }
        #mania-wrapper .long-note-body { width: 90%; background: #a13d53; border-radius: 4px 4px 0 0; position: absolute; z-index: 1; transform: translateY(calc(var(--note-height) / 2)); padding-bottom: calc(var(--note-height) / 2); box-sizing: content-box; }
        #mania-wrapper #playfield.note-style-circle .note-wrapper:has(.long-note-body) .note { width: var(--receptor-size); height: var(--receptor-size); border-radius: 50%; background: #a0d8ef; border: 2px solid rgba(255,255,255,0.7); box-sizing: border-box; box-shadow: none; aspect-ratio: 1/1; }
        #mania-wrapper #playfield.note-style-circle .long-note-body { width: var(--receptor-size); background: #5c8a9f; border-radius: calc(var(--receptor-size) / 2) calc(var(--receptor-size) / 2) 0 0; transform: none; padding-bottom: 0; box-sizing: border-box; }
        #mania-wrapper .note { width: 90%; margin: auto; height: var(--note-height); background: linear-gradient(90deg, #FF4D6D, #FF8FA3); border-radius: 4px; position: absolute; top: 0; box-shadow: 0 0 12px #FF4D6D; }
        #mania-wrapper #playfield.note-style-circle .note { width: var(--receptor-size); height: var(--receptor-size); border-radius: 50%; background: #a0d8ef; border: 2px solid white; box-sizing: border-box; box-shadow: none; aspect-ratio: 1/1; }
        #mania-wrapper #playfield.note-style-circle #playfield-background { display: block; }
        #mania-wrapper #playfield.note-style-circle .lane { background-color: transparent; border-left: none; border-right: 1px solid rgba(255, 255, 255, 0.25); }
        #mania-wrapper #playfield.note-style-circle .lane:first-child { border-left: 1px solid rgba(255, 255, 255, 0.25); }
        #mania-wrapper #playfield.note-style-circle #judgment-line { display: none; }
        #mania-wrapper #playfield.note-style-circle #key-indicators { bottom: var(--judgment-line-pos); transform: translateY(50%); height: auto; z-index: 12; pointer-events: none; }
        #mania-wrapper #playfield.note-style-circle .key { width: 100%; background-color: transparent; border: none; margin: 0; height: var(--receptor-size); display: flex; align-items: center; justify-content: center; font-size: 0; }
        #mania-wrapper #playfield.note-style-circle .key::before { content: ''; display: block; height: var(--receptor-size); width: var(--receptor-size); border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%; background-color: rgba(0, 0, 0, 0.3); transition: background-color 0.05s, box-shadow 0.05s; box-sizing: border-box; }
        #mania-wrapper #playfield.note-style-circle .key.active::before { background-color: rgba(255, 255, 255, 5.0); box-shadow: 0 0 20px inset; }
        #mania-wrapper #key-indicators { position: absolute; bottom: 0; left: 0; width: 100%; height: var(--judgment-line-pos); display: flex; z-index: 12; pointer-events: none; }
        #mania-wrapper .key { width: calc(100% / var(--num-lanes)); text-align: center; font-size: 1.5em; color: rgba(255, 255, 255, 0.5); font-weight: 500; display: flex; align-items: center; justify-content: center; padding-bottom: 2vh; }
        #mania-wrapper #ui-panel { position: absolute; top: 20px; right: 30px; text-align: right; color: white; z-index: 20; }
        #mania-wrapper #score { font-size: 3em; font-weight: 600; }
        #mania-wrapper #accuracy { font-size: 1.5em; font-weight: 400; margin-top: 5px; min-width: 4.5em; text-align: right; }
        #mania-wrapper #accuracy-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
        }
        #mania-wrapper #judgment-timing-text { position: absolute; top: calc(var(--judgment-text-top) - 3.5vh); left: 50%; transform: translateX(-50%); font-size: 1.2em; opacity: 0; z-index: 22; color: #ccc; animation: mania-judgment-anim-new 0.4s ease-out; pointer-events: none; }
        #mania-wrapper #judgment-text { position: absolute; top: var(--judgment-text-top); left: 50%; transform: translateX(-50%); font-size: 2.2em; font-weight: bold; opacity: 0; z-index: 22; padding: 5px 20px; border-radius: 4px; color: white; text-align: center; animation: mania-judgment-anim-new 0.4s ease-out; pointer-events: none; }
        @keyframes mania-judgment-anim-new { 0% { transform: translateX(-50%) scale(0.9); opacity: 1; } 80% { transform: translateX(-50%) scale(1.05); opacity: 1; } 100% { transform: translateX(-50%) scale(1.05); opacity: 0; } }
        #mania-wrapper #combo-container { position: absolute; top: var(--combo-position-y); left: 50%; transform: translate(-50%, -50%); z-index: 13; color: white; text-align: center; opacity: 0; transition: opacity 0.2s; pointer-events: none; }
        #mania-wrapper #combo-container.visible { opacity: 1; }
        #mania-wrapper #combo-count { font-size: calc(7em * var(--combo-size-scale)); font-weight: bold; line-height: 1; text-shadow: 0 0 15px rgba(0,0,0,0.8); }
        #mania-wrapper #combo-label { font-size: calc(1.8em * var(--combo-size-scale)); font-weight: 500; }
        #mania-wrapper .combo-anim { animation: combo-pop 0.1s ease-out; }
        @keyframes combo-pop { 0% { transform: scale(1.3); } 100% { transform: scale(1); } }
        #mania-wrapper #ingame-pause-button { position: absolute; top: 20px; left: 20px; width: 48px; height: 48px; background-color: rgba(255,255,255,0.1); border: 2px solid white; border-radius: 50%; color: white; font-size: 1.8em; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 100; }
        #mania-wrapper .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); color: white; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 200; }
        #mania-wrapper .overlay-menu {
            text-align: center;
            padding: 20px;
            background-color: #16213e;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            transform: scale(0.85); /* ▼▼▼ 変更点 ▼▼▼ */
        }
        #mania-wrapper .overlay-menu h2 { font-size: 2.5em; margin-top: 0; margin-bottom: 30px; }
        #mania-wrapper .overlay-button { display: block; width: 200px; padding: 15px; margin: 10px auto; font-size: 1.2em; color: white; border: 2px solid white; background-color: transparent; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, color 0.2s; }
        #mania-wrapper .overlay-button:hover, #mania-wrapper .overlay-button.selected { background-color: white; color: black; }
        #mania-wrapper #results-menu .results-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 20px; margin-bottom: 20px; font-size: 1.1em; }
        #mania-wrapper .results-grid .results-item span > span { display: inline-block; min-width: 40px; text-align: right; }
        #mania-wrapper .results-grid .results-item small { font-size: 0.8em; color: #a0a8c0; margin-left: 8px;}
        #mania-wrapper #results-accuracy-container { font-size: 1.5em; font-weight: bold; margin-bottom: 30px; }
        #mania-wrapper #countdown-text { font-size: 8em; font-weight: bold; text-shadow: 0 0 20px rgba(0,0,0,0.7); }
        #mania-wrapper .settings-item { margin-bottom: 20px; text-align: left; padding: 0 20px; width: 250px; }
        #mania-wrapper .settings-item label { display: block; margin-bottom: 10px; }
        #mania-wrapper .settings-item input[type="range"] { width: 100%; }
        #mania-wrapper .mod-select-container { display: flex; flex-wrap: wrap; gap: 8px; }
        #mania-wrapper .mod-button { padding: 8px 12px; font-size: 0.9em; font-weight: 500; color: var(--panel-text); background-color: #394362; border: 1px solid var(--panel-border); border-radius: 20px; cursor: pointer; transition: all 0.2s; user-select: none; }
        #mania-wrapper .mod-button.active { background-color: var(--accent-color); color: white; border-color: var(--accent-color); }
        
        /* --- Hit Error Bar Styles START --- */
        #mania-wrapper #error-bar-container {
            position: absolute;
            bottom: 30px; /* Position at the bottom */
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 14px;
            z-index: 21;
            border-radius: 10px;
            background: linear-gradient(to right, 
                #b29d38, 
                #a6c84a, 
                #6ee099 40%, 
                #45eede 50%, 
                #6ee099 60%, 
                #a6c84a, 
                #b29d38
            );
            box-shadow: 0 0 8px 2px rgba(115, 228, 153, 0.5), inset 0 0 3px rgba(0,0,0,0.4);
            overflow: visible;
        }
        #mania-wrapper #error-bar {
            position: relative;
            width: 100%;
            height: 100%;
        }
        #mania-wrapper #error-bar::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 120%;
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 5px #fff, 0 0 10px #00ffff;
            border-radius: 2px;
        }
        #mania-wrapper .error-tick {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 150%;
            background-color: white;
            box-shadow: 0 0 8px white, 0 0 15px #00ffff;
            border-radius: 3px;
            opacity: 0;
            animation: error-tick-anim 1.5s ease-out forwards;
        }
        @keyframes error-tick-anim {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scaleY(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scaleY(0.8);
            }
        }
        /* --- Hit Error Bar Styles END --- */
        
        /* --- Mania Results Rank Style START --- */
        #mania-wrapper .results-rank-container {
            margin-bottom: 20px;
        }
        #mania-wrapper #mania-results-rank-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #FFD700;
        }
         /* --- Mania Results Rank Style END --- */

        /* --- osu!taiko Styles (Scoped) --- */
        #taiko-wrapper {
            --panel-bg: #1f2940;
            --panel-text: #e0e5f0;
            --panel-border: #4a5578;
            --accent-color: #d9534f;
            --disabled-color: #555c6f;
        }
        #taiko-wrapper #app-container { display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; }
        #taiko-wrapper #controls-panel {
            width: 1200px;
            height: 980px;
            font-size: 14px; /* ★追加点: パネル内の基準フォントサイズを小さくする */
            background-color: var(--panel-bg);
            border: 1px solid var(--panel-border);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            color: var(--panel-text);
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr auto auto;
            gap: 10px 20px;
            align-items: start;
            transform: scale(0.85);
            box-sizing: border-box;
        }
        #taiko-wrapper .panel-column-left, #taiko-wrapper .panel-column-right {
            display: flex;
            flex-direction: column;
            gap: 50px;
	    min-height: 200px; /* ← この行を追加します */
        }
        #taiko-wrapper .panel-column-left { grid-column: 1; grid-row: 2; }
        #taiko-wrapper .panel-column-right { grid-column: 2; grid-row: 2; }

        #taiko-wrapper .control-group { display: flex; flex-direction: column; gap: 8px; }

        #taiko-wrapper #beatmap-actions {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
         #taiko-wrapper #beatmap-actions > * {
            width: 100%;
            padding: 10px 0; /* Adjusted padding for smaller buttons */
            font-size: 0.9em;
        }
        #taiko-wrapper #delete-song-button { background-color: #8c3b38; }
        #taiko-wrapper #delete-song-button:hover { background-color: #a34c49; }

        #taiko-wrapper .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px 15px;
            align-items: start;
        }
        #taiko-wrapper .settings-grid .control-group {
            gap: 8px; /* Reset gap for items within the grid */
        }
        #taiko-wrapper .settings-grid .control-group.span-2 {
            grid-column: 1 / -1;
        }
        #taiko-wrapper .assist-options, #taiko-wrapper .sound-options {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #taiko-wrapper .sound-options {
            flex-direction: row;
            gap: 10px;
        }
        #taiko-wrapper .sound-options .file-input-label {
            flex: 1;
        }


        #taiko-wrapper #taiko-game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; overflow: hidden; display: none; z-index: 10; }
        
        #taiko-wrapper #taiko-playfield { position: absolute; top: 50%; left: 0; right: 0; height: 180px; transform: translateY(calc(-50% - 58px)); background-color: rgba(18, 18, 18, 0.85); z-index: 10; box-shadow: 0 5px 25px rgba(0,0,0,0.3); border-radius: 0; }
        #taiko-wrapper #game-canvas { display: block; width: 100%; height: 100%; }
        #taiko-wrapper .grid-item-full { grid-column: 1 / -1; }
        #taiko-wrapper #controls-panel h2 { grid-column: 1 / -1; text-align: center; margin: 0 0 10px 0; font-size: 1.8em; font-weight: 600; color: var(--accent-color); }
        #taiko-wrapper #controls-panel label { font-size: 0.9em; font-weight: 500; color: #a0a8c0; margin-bottom: 0px; display: block; }
        #taiko-wrapper #controls-panel p { grid-column: 1 / -1; text-align: center; margin: 10px 0 0 0; }
        #taiko-wrapper input[type="file"] { width: 0.1px; height: 0.1px; opacity: 0; overflow: hidden; position: absolute; z-index: -1; }
        #taiko-wrapper .file-input-label { display: inline-block; padding: 8px 15px; font-size: 0.9em; font-weight: 500; color: var(--panel-text); background-color: #394362; border: 1px solid var(--panel-border); border-radius: 6px; cursor: pointer; transition: background-color 0.2s; text-align: center;}
        #taiko-wrapper .file-input-label:hover { background-color: #4a5578; }
        #taiko-wrapper .file-input-label.is-loading { background-color: var(--disabled-color); cursor: not-allowed; }
        #taiko-wrapper input[type="range"] { -webkit-appearance: none; width: 100%; height: 6px; background: #2a344d; border-radius: 3px; outline: none; cursor: pointer; }
        #taiko-wrapper input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--accent-color); border-radius: 50%; cursor: pointer; }
        #taiko-wrapper input[type="number"], #taiko-wrapper #song-search-input, #taiko-wrapper #saved-songs-list { width: 100%; background-color: #2a344d; color: var(--panel-text); border: 1px solid var(--panel-border); border-radius: 6px; padding: 8px; font-size: 1em; box-sizing: border-box; }
        #taiko-wrapper #song-search-input { text-align: left; padding-left: 12px; }
        #taiko-wrapper #saved-songs-list { padding: 8px; text-align: center; text-align-last: center; -webkit-appearance: none; -moz-appearance: none; appearance: none; }
        #taiko-wrapper #taiko-key-config-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; }
        #taiko-wrapper .key-config-item { display: flex; flex-direction: column; }
        #taiko-wrapper .key-config-input { flex-grow: 1; height: 45px; background-color: #2a344d; border: 1px solid var(--panel-border); border-radius: 6px; color: var(--panel-text); font-size: 1.3em; font-weight: bold; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; user-select: none; }
        #taiko-wrapper .key-config-input:hover { background-color: #394362; }
        #taiko-wrapper .key-config-input.is-waiting { background-color: var(--accent-color); border-color: var(--accent-color); outline: none; color: white; }
        #taiko-wrapper .checkbox-wrapper { display: flex; align-items: center; cursor: pointer; margin-bottom: 5px; }
        #taiko-wrapper input[type="checkbox"] { display: none; }
        #taiko-wrapper .custom-checkbox { width: 20px; height: 20px; background-color: #2a344d; border: 1px solid var(--panel-border); border-radius: 4px; display: inline-block; position: relative; margin-right: 10px; transition: background-color 0.2s; flex-shrink: 0; }
        #taiko-wrapper input[type="checkbox"]:checked + .custom-checkbox { background-color: var(--accent-color); }
        #taiko-wrapper .custom-checkbox::after { content: ''; position: absolute; left: 6px; top: 2px; width: 5px; height: 10px; border: solid white; border-width: 0 3px 3px 0; transform: rotate(45deg); display: none; }
        #taiko-wrapper input[type="checkbox"]:checked + .custom-checkbox::after { display: block; }
        #taiko-wrapper .control-button { width: 100%; padding: 12px; font-size: 1em; font-weight: 500; color: var(--panel-text); background-color: #394362; border: 1px solid var(--panel-border); border-radius: 8px; cursor: pointer; transition: background-color 0.2s; -webkit-appearance: none; text-align: center; }
        #taiko-wrapper .control-button:hover { background-color: #4a5578; }
        #taiko-wrapper #buttons-group { 
            grid-column: 1 / -1; 
            grid-row: 3;
            display: grid; 
            grid-template-columns: 2fr 1fr; 
            gap: 15px; 
            margin-top: 10px;
        }
        #taiko-wrapper #taiko-start-button { 
            padding: 15px; 
            font-size: 1.2em; 
            font-weight: 600; 
            color: white; 
            background-color: var(--accent-color); 
            border: none;
            border-radius: 8px;
        }
        #taiko-wrapper #switch-to-mania-button {
            border-radius: 8px;
        }

        #taiko-wrapper #taiko-start-button:disabled, #taiko-wrapper #save-song-to-pc-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; color: #8c92a3; }
        #taiko-wrapper #taiko-song-info { min-height: 80px; text-align: center; background: #2a344d; border-radius: 8px; padding: 10px; display: flex; flex-direction: column; justify-content: center; border: 1px solid var(--panel-border); }
        #taiko-wrapper #taiko-ingame-pause-button { display: none; }
        #taiko-wrapper #taiko-ui-panel { position: absolute; top: 20px; right: 30px; color: white; z-index: 20; text-shadow: 0 0 8px rgba(0,0,0,0.8); text-align: right; font-weight: 600; }
        #taiko-wrapper #taiko-score { font-size: 2.5em; }
        #taiko-wrapper #taiko-accuracy { font-size: 1.5em; color: #FFD700; min-width: 5.5em; text-align: right; }
        #taiko-wrapper #taiko-accuracy-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
        }
        #taiko-wrapper #combo-display { position: absolute; top: 49.3%; left: 180px; width: 120px; height: 120px; z-index: 20; font-weight: bold; color: white; text-shadow: 0 0 8px rgba(0,0,0,0.8); opacity: 0; transform: translate(-50%, calc(-50% - 58px)) scale(0.8); transition: opacity 0.2s, transform 0.2s; display: flex; align-items: center; justify-content: center; pointer-events: none; }
        #taiko-wrapper #combo-display.visible { opacity: 1; transform: translate(-50%, calc(-50% - 58px)) scale(1); }
        #taiko-wrapper #roll-counter-display { position: absolute; top: 50%; left: 390px; transform: translate(-50%, calc(-50% - 58px)); z-index: 21; color: white; font-size: 36px; font-weight: bold; text-shadow: 0 0 5px black, 0 0 5px black; opacity: 0; transition: opacity 0.1s linear; pointer-events: none; }
        #taiko-wrapper #roll-counter-display.visible { opacity: 1; }
        #taiko-wrapper #combo { font-size: 4.5em; line-height: 1; }
        #taiko-wrapper #combo-label { display: none; }
        #taiko-wrapper #taiko-judgment-text { position: absolute; top: calc(50% - 180px); left: 390px; transform: translateX(-50%); font-size: 2.5em; font-weight: bold; opacity: 0; z-index: 22; padding: 5px 20px; border-radius: 4px; color: white; text-align: center; text-shadow: 0 0 8px #000, 0 0 8px #000; animation: taiko-judgment-anim-new 0.4s ease-out; pointer-events: none; }
        @keyframes taiko-judgment-anim-new {
    /* 開始: 少し下から現れる */
    0% {
        transform: translateX(-50%) translateY(5px);
        opacity: 1;
    }
    /* 頂点: 高さを5pxに調整 */
    20% {
        transform: translateX(-50%) translateY(-3px); /* ← この行を変更 */
        opacity: 1;
    }
    /* 着地 & 静止: 本来の位置にピタッと収まり、そのまま表示を維持 */
    35%, 90% {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
    }
    /* 終了: その場で消える */
    100% {
        transform: translateX(-50%) translateY(0);
        opacity: 0;
    }
}
        #taiko-wrapper #progress-container { display: none; } /* Hide original progress bar */
        #taiko-wrapper .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: white; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 200; }
        #taiko-wrapper .overlay-menu {
            text-align: center;
            padding: 30px 40px;
            background-color: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transform: scale(0.85); /* ▼▼▼ 変更点 ▼▼▼ */
        }
        #taiko-wrapper .overlay-menu h2 { font-size: 2.8em; margin-top: 0; margin-bottom: 30px; letter-spacing: 2px;}
        #taiko-wrapper .overlay-button { display: block; width: 220px; padding: 15px; margin: 12px auto; font-size: 1.2em; color: white; border: 2px solid var(--panel-border); background-color: #394362; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, transform 0.1s; }
        #taiko-wrapper .overlay-button:hover, #taiko-wrapper .overlay-button.selected { background-color: #4a5578; }
        #taiko-wrapper .overlay-button:active { transform: scale(0.98); }
        #taiko-wrapper #results-menu #results-song-title { font-size: 1.2em; color: #a0a8c0; margin-top: -20px; margin-bottom: 25px;}
        #taiko-wrapper #results-menu .results-main-stats { display: flex; justify-content: space-around; gap: 30px; margin-bottom: 30px; }
        #taiko-wrapper #results-menu .results-item { text-align: center; }
        #taiko-wrapper #results-menu .results-item.rank-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #taiko-wrapper .results-item span:first-child { display: block; font-size: 1em; color: #a0a8c0; margin-bottom: 5px;}
        #taiko-wrapper .results-item span:last-child { font-size: 2em; font-weight: 600;}
        #taiko-wrapper #results-rank-value { font-size: 2.5em; color: #FFD700; }
        #taiko-wrapper #results-menu .results-judgments { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 30px; text-align: center; }
        #taiko-wrapper .judgment-item span:first-child { font-size: 1.2em; font-weight: bold;}
        #taiko-wrapper #results-ryo { color: gold; }
        #taiko-wrapper #results-ka { color: white; }
        #taiko-wrapper #results-fuka { color: #dda0dd; }
        #taiko-wrapper #drum-display { position: absolute; width: 120px; height: 120px; top: 50%; left: 120px; transform: translateY(calc(-50% - 58px)); z-index: 15; pointer-events: none; }
        #taiko-wrapper .drum-body { width: 100%; height: 100%; background-color: #FFFFFF; border: 12px solid #FFFFFF; border-radius: 50%; box-sizing: border-box; position: absolute;box-shadow: inset 0 0 0 2px rgba(0, 0, 0, 0.3); }
#taiko-wrapper .drum-body::after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 2px; /* 線の太さ */
            height: 100%; /* 線の高さ */
            background-color: rgba(0, 0, 0, 0.3); /* 線の色（少し透明な黒） */
        }
        #taiko-wrapper .drum-hit-area { position: absolute; width: 100%; height: 100%; top: 0; left: 0; border-radius: 50%; box-sizing: border-box; opacity: 0; transition: opacity 0.1s linear; }
        #taiko-wrapper .drum-hit-area.active { opacity: 1; transition: none; }
        #taiko-wrapper #drum-don-left, #taiko-wrapper #drum-don-right { width: calc(100% - 24px); height: calc(100% - 24px); top: 12px; left: 12px; background-color: rgba(255, 77, 109, 0.8); }
        #taiko-wrapper #drum-don-left { clip-path: polygon(0% 0%, 50% 0%, 50% 100%, 0% 100%); }
        #taiko-wrapper #drum-don-right { clip-path: polygon(50% 0%, 100% 0%, 100% 100%, 50% 100%); }
        #taiko-wrapper #drum-katsu-left { border: 12px solid rgba(77, 171, 247, 0.9); clip-path: polygon(0% 0%, 50% 0%, 50% 100%, 0% 100%); }
        #taiko-wrapper #drum-katsu-right { border: 12px solid rgba(77, 171, 247, 0.9); clip-path: polygon(50% 0%, 100% 0%, 100% 100%, 50% 100%); }
    
        /* --- Taiko Hit Error Bar Styles START --- */
         #taiko-wrapper #taiko-error-bar-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 40%;
            height: 14px;
            z-index: 25;
            border-radius: 10px;
            background: linear-gradient(to right, 
                #b29d38, 
                #a6c84a, 
                #6ee099 40%, 
                #45eede 50%, 
                #6ee099 60%, 
                #a6c84a, 
                #b29d38
            );
            box-shadow: 0 0 8px 2px rgba(115, 228, 153, 0.5), inset 0 0 3px rgba(0,0,0,0.4);
            overflow: visible;
        }
        #taiko-wrapper #taiko-error-bar {
            position: relative;
            width: 100%;
            height: 100%;
        }
         #taiko-wrapper #taiko-error-bar::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 120%;
            background-color: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 5px #fff, 0 0 10px #00ffff;
            border-radius: 2px;
        }
        #taiko-wrapper .error-tick {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 150%;
            background-color: white;
            box-shadow: 0 0 8px white, 0 0 15px #00ffff;
            border-radius: 3px;
            opacity: 0;
            animation: taiko-error-tick-anim 1.5s ease-out forwards;
        }
        @keyframes taiko-error-tick-anim {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scaleY(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scaleY(0.8);
            }
        }
        /* --- Taiko Hit Error Bar Styles END --- */

        /* 円の位置を個別に調整するためのCSS */
        #mania-wrapper #mania-gameplay-progress-pie {
            position: relative;
            top: 0px;  /* 上下位置: プラスの値で下に、マイナスの値で上に移動 */
            left: 0px; /* 左右位置: プラスの値で右に、マイナスの値で左に移動 */
        }
        #taiko-wrapper #taiko-gameplay-progress-pie {
            position: relative;
            top: 0px;  /* 上下位置: プラスの値で下に、マイナスの値で上に移動 */
            left: 0px; /* 左右位置: プラスの値で右に、マイナスの値で左に移動 */
        }

        /* ショートカットキー設定UIのスタイル */
        .shortcut-key-control {
            margin-top: 10px;
        }
        .shortcut-key-inputs {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        .shortcut-key-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .shortcut-key-item > span {
            font-size: 0.9em;
            color: #a0a8c0;
        }
        .shortcut-key-item .key-config-input {
            width: 80px;
        }
        #taiko-wrapper .shortcut-key-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
    </style>
</head>
<body>

    <div id="game-selector">
        <h1>Select a Game</h1>
        <div>
            <button id="select-mania" class="game-select-button">Play Mania</button>
            <button id="select-taiko" class="game-select-button">Play Taiko</button>
        </div>
    </div>

    <!-- Container for osu!mania Game -->
    <div id="mania-wrapper" class="game-wrapper">
        <video id="video-background" loop muted playsinline></video>
        <img id="image-background" src="" alt="Background Image">
        <div id="app-container">
            <div id="controls-panel">
                <h2 class="grid-item-full">Mania Player</h2>
                <div class="panel-column">
                    <div>
                        <label for="beatmap-library-selector">1. 譜面ライブラリ (.osz, .mcz, .zip)</label>
                        <select id="beatmap-library-selector" size="8"></select>
                        <input type="file" id="mania-osz-file" accept=".osz,.zip,.mcz" multiple>
                    </div>
                    <div class="library-buttons">
                        <button id="add-beatmaps-button" class="control-button">追加</button>
                        <button id="remove-beatmap-button" class="control-button">削除</button>
                        <button id="save-osz-button" class="control-button">PCへ保存</button>
                    </div>
                    <div id="beatmap-selector-container" style="display: none;">
                        <label for="beatmap-selector">2. 難易度を選択</label>
                        <select id="beatmap-selector" class="styled-select"></select>
                    </div>
                     <div id="background-selector-container" style="display: none;">
                        <label for="background-selector">3. 背景を選択</label>
                        <select id="background-selector" class="styled-select"></select>
                    </div>
                </div>
                <div class="panel-column">
                    <div>
                        <label for="key-count-selector">キー数 (Key Count)</label>
                        <select id="key-count-selector" class="styled-select"></select>
                    </div>
                    <div>
                        <label>MOD</label>
                        <div id="mod-select-container" class="mod-select-container">
                            <div class="mod-button" data-mod="NF">No Fail</div>
                            <div class="mod-button" data-mod="HT">Half Time</div>
                            <div class="mod-button" data-mod="DT">Double Time</div>
                            <div class="mod-button" data-mod="HD">Hidden</div>
                        </div>
                    </div>
                    <div class="speed-control">
                        <label for="speed-slider" id="speed-label">ノーツ速度 (x1.5)</label>
                        <input type="range" id="speed-slider" min="0.5" max="4" value="1.5" step="0.1">
                    </div>
                    <div class="offset-controls-container">
                        <div class="offset-control">
                            <label for="offset-input">共通ノーツオフセット (ms)</label>
                            <input type="number" id="offset-input" value="0" step="5">
                        </div>
                        <div class="offset-control">
                            <label for="audio-offset-input">個別楽曲開始位置 (ms)</label>
                            <input type="number" id="audio-offset-input" value="0" step="5">
                        </div>
                    </div>
                    <div class="key-config-control">
                        <label>キー設定</label>
                        <div id="key-config-inputs"></div>
                    </div>
                     <div id="force-4k-container" style="display: none;">
                        <label for="force-4k-checkbox" class="checkbox-wrapper">
                            <input type="checkbox" id="force-4k-checkbox">
                            <span class="custom-checkbox"></span>
                            <span>中央4レーンのみプレイ</span>
                        </label>
                    </div>
                    <div class="assist-control">
                        <label>プレイアシスト</label>
                        <label for="auto-play-checkbox" class="checkbox-wrapper">
                            <input type="checkbox" id="auto-play-checkbox">
                            <span class="custom-checkbox"></span>
                            <span>オートプレイ</span>
                        </label>
                    </div>
                     <div class="settings-buttons">
                        <button id="open-settings-button" class="control-button">UI設定</button>
                        <button id="switch-to-taiko-button" class="control-button">Taiko Playerへ</button>
                    </div>
                    <div class="shortcut-key-control">
                         <label>ショートカットキー</label>
                         <div class="shortcut-key-inputs">
                             <div class="shortcut-key-item">
                                 <span>リトライ</span>
                                 <div id="mania-shortcut-retry" class="key-config-input" data-shortcut-for="retry" tabindex="0">R</div>
                             </div>
                             <div class="shortcut-key-item">
                                 <span>メニューへ</span>
                                 <div id="mania-shortcut-menu" class="key-config-input" data-shortcut-for="menu" tabindex="0">H</div>
                             </div>
                         </div>
                     </div>
                </div>
                <button id="start-button" class="grid-item-full" disabled>ゲーム開始</button>
                <div id="song-info" class="grid-item-full">
                    <div id="song-title">譜面を選択してください</div>
                    <div id="song-artist" style="font-size: 0.9em; color: #a0a8c0;"></div>
                </div>
                <p class="grid-item-full">※ WキーまたはESCキーでポーズ / ESC長押しでフルスクリーン解除</p>
            </div>
        </div>
        <div id="game-container" class="game-container">
            <div id="countdown-overlay" class="overlay" style="background-color: rgba(0,0,0,0.6);">
                <div id="countdown-text">3</div>
            </div>
            <button id="ingame-pause-button">||</button>
            <div id="ui-panel">
                <div id="score">0</div>
                <div id="accuracy-container">
                    <canvas id="mania-gameplay-progress-pie" width="24" height="24"></canvas>
                    <div id="accuracy">100.00%</div>
                </div>
            </div>
            <div id="judgment-timing-text"></div>
            <div id="judgment-text"></div>
            <div id="playfield">
                <div id="playfield-background"></div>
                <div id="combo-container">
                    <div id="combo-count">0</div>
                    <div id="combo-label">COMBO</div>
                </div>
                <div id="lanes-container"></div>
                <div id="judgment-line"></div>
                <div id="error-bar-container"><div id="error-bar"></div></div>
                <div id="key-indicators"></div>
            </div>
        </div>
        <div id="pause-overlay" class="overlay">
            <div id="pause-menu" class="overlay-menu">
                <h2>PAUSED</h2>
                <button id="resume-button" class="overlay-button">再開 (Resume)</button>
                <button id="retry-button" class="overlay-button">やり直し (Retry)</button>
                <button id="back-to-menu-button" class="overlay-button">メニューに戻る (Menu)</button>
            </div>
        </div>
        <div id="results-overlay" class="overlay">
            <div id="results-menu" class="overlay-menu">
                <h2>RESULTS</h2>
                <div class="results-item" style="font-size: 1.8em; margin-bottom: 20px;"><span>SCORE: </span><span id="results-score-value">0</span></div>
                <div class="results-rank-container">
                    <span id="mania-results-rank-value">S</span>
                </div>
                <div id="results-accuracy-container">ACCURACY: <span id="results-accuracy-value">0.00</span>%</div>
                <div class="results-grid">
                    <div class="results-item" style="grid-column: 1 / -1;"><span>MAX COMBO: </span><span id="results-max-combo-value">0</span></div>
                    <div class="results-item"><span>PERFECT+: </span><span><span id="results-perfect-plus-value">0</span> <small id="results-perfect-plus-percent">(0.00%)</small></span></div>
                    <div class="results-item"><span>PERFECT: </span><span><span id="results-perfect-value">0</span> <small id="results-perfect-percent">(0.00%)</small></span></div>
                    <div class="results-item"><span>GREAT: </span><span><span id="results-great-value">0</span> <small id="results-great-percent">(0.00%)</small></span></div>
                    <div class="results-item"><span>GOOD: </span><span><span id="results-good-value">0</span> <small id="results-good-percent">(0.00%)</small></span></div>
                    <div class="results-item"><span>OK: </span><span><span id="results-ok-value">0</span> <small id="results-ok-percent">(0.00%)</small></span></div>
                    <div class="results-item"><span>MISS: </span><span><span id="results-miss-value">0</span> <small id="results-miss-percent">(0.00%)</small></span></div>
                </div>
                <button id="results-retry-button" class="overlay-button">やり直し (Retry)</button>
                <button id="results-menu-button" class="overlay-button">メニューに戻る (Menu)</button>
            </div>
        </div>
        <div id="settings-overlay" class="overlay">
             <div class="overlay-menu">
                <h2>UI設定</h2>
                <div class="settings-item">
                    <label for="note-style-selector">ノーツのスタイル</label>
                    <select id="note-style-selector" class="styled-select">
                        <option value="bar">バー</option>
                        <option value="circle">サークル</option>
                    </select>
                </div>
                <div class="settings-item">
                    <label for="background-brightness-slider">背景の明るさ: <span id="brightness-value">50</span>%</label>
                    <input type="range" id="background-brightness-slider" min="0" max="100" value="50">
                </div>
                <div class="settings-item">
                    <label for="lane-opacity-slider" id="lane-opacity-label">レーンの不透明度: <span id="lane-opacity-value">50</span>%</label>
                    <input type="range" id="lane-opacity-slider" min="0" max="100" value="50">
                </div>
                <div class="settings-item">
                    <label for="combo-size-slider">コンボの大きさ: <span id="combo-size-value">100</span>%</label>
                    <input type="range" id="combo-size-slider" min="50" max="150" value="100">
                </div>
                <div class="settings-item">
                    <label for="combo-position-slider">コンボのY位置: <span id="combo-position-value">45</span>%</label>
                    <input type="range" id="combo-position-slider" min="20" max="80" value="45">
                </div>
                <div class="settings-item">
                    <label for="judgment-position-slider">判定文字のY位置: <span id="judgment-position-value">65</span>%</label>
                    <input type="range" id="judgment-position-slider" min="20" max="85" value="65">
                </div>
                <button class="overlay-button">閉じる</button>
             </div>
        </div>
    </div>
    
    <!-- Container for osu!taiko Game -->
    <div id="taiko-wrapper" class="game-wrapper">
        <div id="app-container">
            <div id="controls-panel">
                <h2 class="grid-item-full">Taiko Player</h2>

                <!-- Left Column -->
                <div class="panel-column-left">
                    <div class="control-group">
                        <label>譜面管理</label>
                        <input type="text" id="song-search-input" placeholder="曲を検索...">
                        <select id="saved-songs-list" class="control-button">
                             <option value="">-- 保存済み譜面を選択 --</option>
                        </select>
                        <div id="beatmap-actions">
                             <label for="taiko-osz-file" id="osz-file-label" class="file-input-label control-button">追加</label>
                             <button id="delete-song-button" class="control-button">削除</button>
                             <button id="save-song-to-pc-button" class="control-button" disabled>PCへ保存</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>曲情報</label>
                        <div id="taiko-song-info">
                            <div id="taiko-song-title">譜面を選択してください</div>
                            <div id="taiko-song-artist" style="font-size: 0.9em; color: #a0a8c0;"></div>
                        </div>
                        <div id="taiko-beatmap-selector-container" style="display: none;">
                            <select id="taiko-beatmap-selector" class="control-button"></select>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>キー設定</label>
                        <div id="taiko-key-config-inputs">
                             <div class="key-config-item">
                                <label>ドン (左)</label>
                                <div id="key-don-left" class="key-config-input" data-key-id="don_left" tabindex="0">D</div>
                            </div>
                            <div class="key-config-item">
                                <label>ドン (右)</label>
                                <div id="key-don-right" class="key-config-input" data-key-id="don_right" tabindex="0">K</div>
                            </div>
                            <div class="key-config-item">
                                <label>カッ (左)</label>
                                <div id="key-katsu-left" class="key-config-input" data-key-id="katsu_left" tabindex="0">S</div>
                            </div>
                            <div class="key-config-item">
                                <label>カッ (右)</label>
                                <div id="key-katsu-right" class="key-config-input" data-key-id="katsu_right" tabindex="0">L</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Column -->
                <div class="panel-column-right">
                    <div class="settings-grid">
                        <div class="control-group">
                            <label for="taiko-speed-slider" id="taiko-speed-label">スクロール速度 (x1.0)</label>
                            <input type="range" id="taiko-speed-slider" min="-5" max="5" value="0" step="0.1">
                        </div>
                         <div class="control-group">
                            <label for="taiko-offset-input">譜面オフセット (ms)</label>
                            <input type="number" id="taiko-offset-input" value="0" step="0.5">
                        </div>
                         <div class="control-group">
                            <label for="taiko-individual-offset-input">個別譜面オフセット (ms)</label>
                            <input type="number" id="taiko-individual-offset-input" value="0" step="0.5">
                        </div>
                        <div class="control-group">
                            <label for="video-offset-input">動画オフセット (ms)</label>
                            <input type="number" id="video-offset-input" value="0" step="5">
                        </div>
                        <div class="control-group" style="grid-column: 1 / -1;">
                            <label for="se-offset-input">SEオフセット (ms)</label>
                            <input type="number" id="se-offset-input" value="0" step="5" title="音が遅れて聞こえる場合、-50のようにマイナスの値を入力して調整してください。">
                        </div>
                        <div class="control-group">
                            <label for="taiko-lane-opacity-slider" id="taiko-lane-opacity-label">レーン不透明度 (85%)</label>
                            <input type="range" id="taiko-lane-opacity-slider" min="0" max="1" value="0.85" step="0.01">
                        </div>
                        <div class="control-group">
                            <label for="bg-brightness-slider" id="bg-brightness-label">背景の明るさ (100%)</label>
                            <input type="range" id="bg-brightness-slider" min="0.1" max="2.5" value="1" step="0.05">
                        </div>
                         <div class="control-group" style="grid-column: 1 / -1;">
                            <label for="lane-cover-slider" id="lane-cover-label">レーンカバー (0%)</label>
                            <input type="range" id="lane-cover-slider" min="0" max="70" value="0" step="1">
                        </div>
                         <div class="control-group span-2">
                            <label>プレイアシスト</label>
                            <div class="assist-options">
                                <label for="taiko-auto-play-checkbox" class="checkbox-wrapper">
                                    <input type="checkbox" id="taiko-auto-play-checkbox">
                                    <span class="custom-checkbox"></span>
                                    <span>オートプレイ</span>
                                </label>
                                 <label for="single-hand-big-note-checkbox" class="checkbox-wrapper">
                                    <input type="checkbox" id="single-hand-big-note-checkbox" checked>
                                    <span class="custom-checkbox"></span>
                                    <span>大音符を片手で処理</span>
                                </label>
                                <label for="auto-se-checkbox" class="checkbox-wrapper">
                                    <input type="checkbox" id="auto-se-checkbox">
                                    <span class="custom-checkbox"></span>
                                    <span>自動SE</span>
                                </label>
                            </div>
                        </div>
                        <div class="control-group span-2">
                            <label>サウンド設定</label>
                            <div class="sound-options">
                                <label for="don-sound-file" class="file-input-label">ドン(SE)</label>
                                <input type="file" id="don-sound-file" accept="audio/*">
                                <label for="katsu-sound-file" class="file-input-label">カッ(SE)</label>
                                <input type="file" id="katsu-sound-file" accept="audio/*">
                            </div>
                        </div>
                        <div id="background-select-wrapper" class="control-group span-2" style="display: none;">
                            <label for="background-select">背景</label>
                            <select id="background-select" class="control-button"></select>
                        </div>
                        <div class="control-group span-2">
                            <label>ショートカットキー</label>
                            <div class="shortcut-key-inputs">
                                <div class="shortcut-key-item">
                                    <span>リトライ</span>
                                    <div id="taiko-shortcut-retry" class="key-config-input" data-shortcut-for="retry" tabindex="0">R</div>
                                </div>
                                <div class="shortcut-key-item">
                                    <span>メニューへ</span>
                                    <div id="taiko-shortcut-menu" class="key-config-input" data-shortcut-for="menu" tabindex="0">H</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Bottom Buttons -->
                <div id="buttons-group" class="grid-item-full">
                    <button id="taiko-start-button" disabled>ゲーム開始 (Space)</button>
                    <button id="switch-to-mania-button" class="control-button">Mania Playerへ</button>
                </div>
                
                <p class="grid-item-full">※ WキーまたはESCキーでポーズ / ESC長押しでフルスクリーン解除©MASAKI_TAIKO</p>
                
                <!-- Hidden file input -->
                <input type="file" id="taiko-osz-file" accept=".osz" multiple>
            </div>
        </div>
        <div id="taiko-game-container" class="game-container">
            <video id="taiko-background-video" muted loop playsinline></video>
            <img id="taiko-background-image" />
            <button id="taiko-ingame-pause-button">||</button>
            <div id="taiko-ui-panel">
                <div id="taiko-score">0</div>
                <div id="taiko-accuracy-container">
                    <canvas id="taiko-gameplay-progress-pie" width="24" height="24"></canvas>
                    <div id="taiko-accuracy">S 100.00%</div>
                </div>
            </div>
            <div id="combo-display">
                <span id="combo">0</span><span id="combo-label">x</span>
            </div>
            <div id="roll-counter-display"></div>
            <div id="taiko-judgment-text"></div>
            <div id="drum-display">
                <div class="drum-body"></div>
                <div id="drum-don-left" class="drum-hit-area"></div>
                <div id="drum-don-right" class="drum-hit-area"></div>
                <div id="drum-katsu-left" class="drum-hit-area"></div>
                <div id="drum-katsu-right" class="drum-hit-area"></div>
            </div>
             <div id="taiko-error-bar-container"><div id="taiko-error-bar"></div></div>
            <div id="taiko-playfield">
                <canvas id="game-canvas"></canvas>
            </div>
        </div>
        <div id="taiko-pause-overlay" class="overlay">
            <div id="pause-menu" class="overlay-menu">
                <h2>PAUSED</h2>
                <button id="taiko-resume-button" class="overlay-button">再開 (Resume)</button>
                <button id="taiko-retry-button" class="overlay-button">やり直し (Retry)</button>
                <button id="back-to-title-button-pause" class="overlay-button">タイトルへ戻る</button>
            </div>
        </div>
        <div id="taiko-results-overlay" class="overlay">
            <div id="results-menu" class="overlay-menu">
                <h2>RESULTS</h2>
                <div id="results-song-title">Song Title</div>
                 <div class="results-main-stats">
                    <div class="results-item">
                        <span>SCORE</span>
                        <span id="taiko-results-score-value">0</span>
                    </div>
                    <div class="results-item rank-item">
                        <span>RANK</span>
                        <span id="results-rank-value">S</span>
                    </div>
                    <div class="results-item">
                        <span>MAX COMBO</span>
                        <span id="taiko-results-max-combo-value">0</span>
                    </div>
                </div>
                <div class="results-judgments">
                    <div class="judgment-item" id="results-ryo">
                        <span>良 (PERFECT)</span>
                        <span id="results-ryo-value">0</span>
                    </div>
                     <div class="judgment-item" id="results-ka">
                        <span>可 (GREAT)</span>
                        <span id="results-ka-value">0</span>
                    </div>
                     <div class="judgment-item" id="results-fuka">
                        <span>不可 (MISS)</span>
                        <span id="results-fuka-value">0</span>
                    </div>
                </div>
                <button id="taiko-results-retry-button" class="overlay-button">やり直し (Retry)</button>
                <button id="back-to-title-button-results" class="overlay-button">タイトルへ戻る</button>
            </div>
        </div>
        <audio id="audio-player"></audio>
    </div>

    <script>
    // --- Global Controller ---
    let shortcutKeys = {
        retry: 'R',
        menu: 'H'
    };

    function saveGlobalSettings() {
        localStorage.setItem('rhythmGameGlobalSettings', JSON.stringify({ shortcuts: shortcutKeys }));
    }

    function loadGlobalSettings() {
        try {
            const settings = JSON.parse(localStorage.getItem('rhythmGameGlobalSettings'));
            if (settings && settings.shortcuts) {
                shortcutKeys = { ...shortcutKeys, ...settings.shortcuts };
            }
        } catch (e) {
            console.error("Failed to load global settings:", e);
        }
    }

    function initializeShortcutKeySetup(retryElementId, menuElementId) {
        const retryInput = document.getElementById(retryElementId);
        const menuInput = document.getElementById(menuElementId);
        if (!retryInput || !menuInput) return;

        const updateUI = () => {
            document.querySelectorAll('[data-shortcut-for="retry"]').forEach(el => el.textContent = shortcutKeys.retry);
            document.querySelectorAll('[data-shortcut-for="menu"]').forEach(el => el.textContent = shortcutKeys.menu);
        };
        updateUI();

        const setupListener = (element, keyName) => {
            element.addEventListener('click', () => {
                document.querySelectorAll('.key-config-input.is-waiting').forEach(el => el.blur());
                element.textContent = '...';
                element.classList.add('is-waiting');
            });

            element.addEventListener('keydown', (e) => {
                e.preventDefault();
                if (!element.classList.contains('is-waiting')) return;
                if (e.key === 'Escape') {
                    element.blur();
                    return;
                }
                const newKey = e.key.toUpperCase();
                if (newKey.length === 1 || e.code.startsWith('F')) {
                     shortcutKeys[keyName] = newKey;
                     saveGlobalSettings();
                     updateUI();
                     element.blur();
                }
            });

            element.addEventListener('blur', () => {
                element.classList.remove('is-waiting');
                updateUI();
            });
        };

        setupListener(retryInput, 'retry');
        setupListener(menuInput, 'menu');
    }
    let activeGame = null;
    let maniaInitialized = false;
    let taikoInitialized = false;
    let isRequestingFile = false;
    let shouldReEnterFullscreen = false;
    let escTimer = null;
    let isEscHeld = false;
    const LONG_PRESS_DURATION = 1000; // 1秒

    function switchToMania() {
        document.getElementById('game-selector').style.display = 'none';
        document.getElementById('taiko-wrapper').style.display = 'none';
        document.getElementById('mania-wrapper').style.display = 'block';
        activeGame = 'mania';
        if (!maniaInitialized) {
            ManiaGame.initialize();
            maniaInitialized = true;
        }
    }

    function switchToTaiko() {
        document.getElementById('game-selector').style.display = 'none';
        document.getElementById('mania-wrapper').style.display = 'none';
        document.getElementById('taiko-wrapper').style.display = 'block';
        activeGame = 'taiko';
        if (!taikoInitialized) {
            TaikoGame.initialize();
            taikoInitialized = true;
        }
    }

    function drawProgressPie(canvasId, progress) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(centerX, centerY) * 0.9;

        progress = Math.max(0, Math.min(1, progress));

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
        ctx.fillStyle = '#3a4360';
        ctx.fill();

        if (progress > 0) {
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, -Math.PI / 2, (-Math.PI / 2) + (progress * 2 * Math.PI), false);
            ctx.closePath();
            ctx.fillStyle = '#cccccc';
            ctx.fill();
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        loadGlobalSettings();
        const selectManiaBtn = document.getElementById('select-mania');
        const selectTaikoBtn = document.getElementById('select-taiko');
        selectManiaBtn.addEventListener('click', switchToMania);
        selectTaikoBtn.addEventListener('click', switchToTaiko);
    });

    document.addEventListener('keydown', (e) => {
        // ▼▼▼ 修正点：文字入力中かどうかを判定 ▼▼▼
        const activeElement = document.activeElement;
        const isTyping = activeElement && (
            activeElement.tagName === 'INPUT' || 
            activeElement.tagName === 'TEXTAREA' || 
            activeElement.isContentEditable
        );

        // --- ポーズキー (W または Esc) の処理 ---
        if ((e.key.toUpperCase() === 'W' || e.key === 'Escape') && !e.repeat) {
             e.preventDefault();
             if (activeGame === 'mania') ManiaGame.togglePauseExternal();
             if (activeGame === 'taiko') TaikoGame.togglePauseExternal();
        }

        // --- リトライキーの処理 ---
        if (e.key.toUpperCase() === shortcutKeys.retry.toUpperCase() && !e.repeat) {
            // ▼▼▼ 修正点：文字入力中ならショートカットを無効化 ▼▼▼
            if (isTyping) return;

            e.preventDefault();

            if (isRetryOnCooldown) {
                return;
            }

            isRetryOnCooldown = true;
            setTimeout(() => {
                isRetryOnCooldown = false;
            }, 3000);

            if (activeGame === 'mania') ManiaGame.retryGameExternal();
            if (activeGame === 'taiko') TaikoGame.retryGameExternal();
        }

        // --- メニューキーの処理 (こちらはクールダウンなし) ---
        if (e.key.toUpperCase() === shortcutKeys.menu.toUpperCase() && !e.repeat) {
            // ▼▼▼ 修正点：文字入力中ならショートカットを無効化 ▼▼▼
            if (isTyping) return;
            
            e.preventDefault();
            if (activeGame === 'mania') ManiaGame.returnToControlsExternal();
            if (activeGame === 'taiko') TaikoGame.returnToControlsExternal();
        }
    });


    // --- osu!mania Game Logic (Scoped) ---
    const ManiaGame = (() => {
        const root = document.getElementById('mania-wrapper');
        // ... (ManiaGameのJavaScriptコードは変更なしなので省略) ...
        const dom = {
            appContainer: root.querySelector('#app-container'),
            gameContainer: root.querySelector('#game-container'),
            controlsPanel: root.querySelector('#controls-panel'),
            playfield: root.querySelector('#playfield'),
            playfieldBackground: root.querySelector('#playfield-background'),
            lanesContainer: root.querySelector('#lanes-container'),
            keyIndicatorsContainer: root.querySelector('#key-indicators'),
            scoreElement: root.querySelector('#score'),
            accuracyElement: root.querySelector('#accuracy'),
            judgmentTextElement: root.querySelector('#judgment-text'),
            judgmentTimingTextElement: root.querySelector('#judgment-timing-text'),
            startButton: root.querySelector('#start-button'),
            oszFileInput: root.querySelector('#mania-osz-file'),
            beatmapSelectorContainer: root.querySelector('#beatmap-selector-container'),
            beatmapSelector: root.querySelector('#beatmap-selector'),
            songTitleElement: root.querySelector('#song-title'),
            songArtistElement: root.querySelector('#song-artist'),
            offsetInput: root.querySelector('#offset-input'),
            audioOffsetInput: root.querySelector('#audio-offset-input'),
            speedSlider: root.querySelector('#speed-slider'),
            speedLabel: root.querySelector('#speed-label'),
            keyConfigInputsContainer: root.querySelector('#key-config-inputs'),
            autoPlayCheckbox: root.querySelector('#auto-play-checkbox'),
            force4kContainer: root.querySelector('#force-4k-container'),
            force4kCheckbox: root.querySelector('#force-4k-checkbox'),
            pauseOverlay: root.querySelector('#pause-overlay'),
            resumeButton: root.querySelector('#resume-button'),
            retryButton: root.querySelector('#retry-button'),
            ingamePauseButton: root.querySelector('#ingame-pause-button'),
            resultsOverlay: root.querySelector('#results-overlay'),
            resultsScore: root.querySelector('#results-score-value'),
            resultsAccuracy: root.querySelector('#results-accuracy-value'),
            resultsMaxCombo: root.querySelector('#results-max-combo-value'),
            resultsPerfectPlus: root.querySelector('#results-perfect-plus-value'),
            resultsPerfectPlusPercent: root.querySelector('#results-perfect-plus-percent'),
            resultsPerfect: root.querySelector('#results-perfect-value'),
            resultsPerfectPercent: root.querySelector('#results-perfect-percent'),
            resultsGreat: root.querySelector('#results-great-value'),
            resultsGreatPercent: root.querySelector('#results-great-percent'),
            resultsGood: root.querySelector('#results-good-value'),
            resultsGoodPercent: root.querySelector('#results-good-percent'),
            resultsOk: root.querySelector('#results-ok-value'),
            resultsOkPercent: root.querySelector('#results-ok-percent'),
            resultsMiss: root.querySelector('#results-miss-value'),
            resultsMissPercent: root.querySelector('#results-miss-percent'),
            resultsRetryButton: root.querySelector('#results-retry-button'),
            resultsMenuButton: root.querySelector('#results-menu-button'),
            openSettingsButton: root.querySelector('#open-settings-button'),
            settingsOverlay: root.querySelector('#settings-overlay'),
            beatmapLibrarySelector: root.querySelector('#beatmap-library-selector'),
            addBeatmapsButton: root.querySelector('#add-beatmaps-button'),
            removeBeatmapButton: root.querySelector('#remove-beatmap-button'),
            saveOszButton: root.querySelector('#save-osz-button'),
            countdownOverlay: root.querySelector('#countdown-overlay'),
            countdownText: root.querySelector('#countdown-text'),
            videoBackground: root.querySelector('#video-background'),
            imageBackground: root.querySelector('#image-background'),
            backgroundSelectorContainer: root.querySelector('#background-selector-container'),
            backgroundSelector: root.querySelector('#background-selector'),
            comboContainer: root.querySelector('#combo-container'),
            comboCount: root.querySelector('#combo-count'),
            noteStyleSelector: root.querySelector('#note-style-selector'),
            backgroundBrightnessSlider: root.querySelector('#background-brightness-slider'),
            brightnessValue: root.querySelector('#brightness-value'),
            laneOpacitySlider: root.querySelector('#lane-opacity-slider'),
            laneOpacityLabel: root.querySelector('#lane-opacity-label'),
            laneOpacityValue: root.querySelector('#lane-opacity-value'),
            comboSizeSlider: root.querySelector('#combo-size-slider'),
            comboSizeValue: root.querySelector('#combo-size-value'),
            comboPositionSlider: root.querySelector('#combo-position-slider'),
            comboPositionValue: root.querySelector('#combo-position-value'),
            judgmentPositionSlider: root.querySelector('#judgment-position-slider'),
            judgmentPositionValue: root.querySelector('#judgment-position-value'),
            backToMenuButton: root.querySelector('#back-to-menu-button'),
            switchToTaikoButton: root.querySelector('#switch-to-taiko-button'),
            modSelectContainer: root.querySelector('#mod-select-container'),
            errorBar: root.querySelector('#error-bar'),
            keyCountSelector: root.querySelector('#key-count-selector'),
            resultsRankValue: root.querySelector('#mania-results-rank-value'), 
        };
        if (dom.settingsOverlay) { const closeBtn = dom.settingsOverlay.querySelector('.overlay-button'); if (closeBtn) closeBtn.addEventListener('click', () => dom.settingsOverlay.style.display = 'none'); }
        if (dom.openSettingsButton) { dom.openSettingsButton.addEventListener('click', () => dom.settingsOverlay.style.display = 'flex'); }
        const NOTE_SPAWN_OFFSET_Y = 100;
        const AUDIO_START_DELAY_MS = 200;
        let keyConfigs = {};
        let activeKeys = [];
        let numLanes = 4;
        let keyState = [];
        let keyJustPressed = [];
        const getGameHeight = () => dom.gameContainer.clientHeight;
        const JUDGMENT_LINE_POS_VH = 15;
        const NOTE_HEIGHT = 22;
        const BASE_FALL_MS = 1200;
        
        let JUDGMENT_WINDOWS = {};
        
        const EARLY_LATE_THRESHOLD = 5;
        const TICK_SCORE_INTERVAL = 100;
        const TICK_SCORE_AMOUNT = 10;
        const LN_EARLY_RELEASE_PERFECT_WINDOW = 120;
        let score = 0, combo = 0, maxCombo = 0, accuracy = 100, totalJudgments = 0, weightedAccuracy = 0, gameEndTime = 0;
        let judgmentCounts = { 'PERFECT+': 0, PERFECT: 0, GREAT: 0, GOOD: 0, OK: 0, MISS: 0 };
        let isGameRunning = false, isPaused = false, isAutoPlay = false;
        let selectedPauseIndex = 0;
        let allNotes = [];
        let nextUnjudgedNoteIndex = 0;
        let activeHolds = [];
        let beatmap = null;
        let audioLoaded = false;
        let animationFrameId = null;
        let currentOszFiles = { beatmaps: [], audio: {}, video: {}, image: {} };
        let db;
        let gameContext = { visualStartTime: 0, rate: 1.0 };
        let activeMods = { NF: false, HT: false, DT: false, HD: false };
        let currentBeatmapSetId = null;
        let currentBeatmapVersion = null;
        let audioContext;
        let audioBuffer;
        let audioSourceNode;
        let audioContextState = { startedAt: 0, pausedAt: 0, isReady: false };
        let playEndTime = 0; 
        let songDuration = 0;
        function generateDefaultKeyConfigs() { return { 4: ['D', 'F', 'J', 'K'], 5: ['D', 'F', ' ', 'J', 'K'], 6: ['S', 'D', 'F', 'J', 'K', 'L'], 7: ['S', 'D', 'F', ' ', 'J', 'K', 'L'], 8: ['A', 'S', 'D', 'F', 'J', 'K', 'L', ';'], 9: ['A', 'S', 'D', 'F', ' ', 'J', 'K', 'L', ';'], 10: ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';'] }; }
        function initDB() { return new Promise((resolve, reject) => { const request = indexedDB.open('maniaPlayerDB', 1); request.onerror = event => reject('Database error: ' + event.target.errorCode); request.onsuccess = event => { db = event.target.result; resolve(db); }; request.onupgradeneeded = event => { const db = event.target.result; db.createObjectStore('beatmaps', { keyPath: 'id', autoIncrement: true }); }; }); }
        async function addBeatmapsToDB(files) { if (!db) return; const transaction = db.transaction(['beatmaps'], 'readwrite'); const store = transaction.objectStore('beatmaps'); for (const file of files) { store.add({ name: file.name, file: file }); } transaction.oncomplete = () => loadBeatmapsFromDB(); transaction.onerror = (event) => console.error('Error adding beatmaps:', event.target.error); }
        async function loadBeatmapsFromDB() { if (!db) return; const transaction = db.transaction(['beatmaps'], 'readonly'); const store = transaction.objectStore('beatmaps'); const request = store.getAll(); request.onsuccess = () => { dom.beatmapLibrarySelector.innerHTML = ''; request.result.forEach(beatmapFile => { const option = new Option(beatmapFile.name, beatmapFile.id); dom.beatmapLibrarySelector.add(option); }); }; }
        async function removeBeatmapFromDB() { if (!db) return; const selectedId = parseInt(dom.beatmapLibrarySelector.value, 10); if (isNaN(selectedId)) { alert('削除する譜面を選択してください。'); return; } const transaction = db.transaction(['beatmaps'], 'readwrite'); const store = transaction.objectStore('beatmaps'); const request = store.delete(selectedId); request.onsuccess = () => { resetBeatmapSelection(); loadBeatmapsFromDB(); }; }
        async function getBeatmapRecordFromDB(id) { return new Promise((resolve, reject) => { if (!db) return reject('DB not initialized'); const transaction = db.transaction(['beatmaps'], 'readonly'); const store = transaction.objectStore('beatmaps'); const request = store.get(id); request.onsuccess = () => resolve(request.result || null); request.onerror = (event) => reject(event.target.error); }); }
        function parseBeatmap(text) {
            const lines = text.split('\n').map(l => l.trim());
            const result = {
                title: '', artist: '', keyCount: 0, hitObjects: [],
                audioFilename: '', version: '', audioLeadIn: 0,
                videoFilename: '', videoOffset: 0, overallDifficulty: 8 
            };
            let currentSection = '';
            for (const line of lines) {
                if (line.startsWith('[')) { currentSection = line; continue; }
                if (currentSection === '[General]') {
                    if (line.startsWith('AudioFilename:')) result.audioFilename = line.substring(14).trim();
                    if (line.startsWith('AudioLeadIn:')) result.audioLeadIn = parseInt(line.substring(12).trim(), 10) || 0;
                } else if (currentSection === '[Events]') {
                    if (line.startsWith('Video,')) {
                        const parts = line.split(',');
                        if (parts.length >= 3) {
                            result.videoOffset = parseInt(parts[1], 10) || 0;
                            result.videoFilename = parts[2].replace(/"/g, '');
                        }
                    }
                } else if (currentSection === '[Metadata]') {
                    if (line.startsWith('Title:')) result.title = line.substring(6).trim();
                    else if (line.startsWith('Artist:')) result.artist = line.substring(7).trim();
                    else if (line.startsWith('Version:')) result.version = line.substring(8).trim();
                } else if (currentSection === '[Difficulty]') {
                    if (line.startsWith('CircleSize:')) result.keyCount = parseInt(line.substring(11).trim(), 10);
                    if (line.startsWith('OverallDifficulty:')) result.overallDifficulty = parseFloat(line.substring(18).trim());
                } else if (currentSection === '[HitObjects]') {
                    const parts = line.split(',');
                    if (parts.length < 6) continue;
                    const x = parseInt(parts[0], 10);
                    const time = parseInt(parts[2], 10);
                    const type = parseInt(parts[3], 10);
                    const lane = Math.floor(x * result.keyCount / 512);
                    if (lane < 0 || lane >= result.keyCount) continue;
                    if (type & 128) {
                        const endTime = parseInt(parts[5].split(':')[0], 10);
                        result.hitObjects.push({ time, lane, type: 'long', endTime });
                    } else {
                        result.hitObjects.push({ time, lane, type: 'note' });
                    }
                }
            }
            result.hitObjects.sort((a, b) => a.time - b.time);
            return result;
        }
        
        function parseMalodyBeatmap(text) {
            try {
                const data = JSON.parse(text);
                const mode_ext = data.meta.mode_ext || data.meta.meta_ext;
                if (!data.meta || data.meta.mode !== 0 || !mode_ext || mode_ext.column !== 4) {
                    alert('Malody譜面の読み込みに失敗しました。4キー(Key)モードの譜面のみ対応しています。');
                    return null;
                }
                const result = {
                    title: data.meta.title || 'Unknown Title',
                    artist: data.meta.artist || 'Unknown Artist',
                    version: data.meta.version || 'Unknown Difficulty',
                    keyCount: mode_ext.column,
                    hitObjects: [],
                    audioFilename: (data.meta.audio || '').trim(),
                    audioLeadIn: 0,
                    videoFilename: '',
                    videoOffset: 0,
                    overallDifficulty: 8
                };
                const offset = data.meta.offset || 0;
                const BEATS_PER_MEASURE = 4;
                const timingPoints = (data.time || []).sort((a, b) => a.beat[0] - b.beat[0] || a.beat[1] - b.beat[1] || a.beat[2] - b.beat[2]);
                if (timingPoints.length === 0 || (timingPoints[0].beat[0] !== 0 || timingPoints[0].beat[1] !== 0)) {
                    timingPoints.unshift({ beat: [0, 0, 4], bpm: 120 });
                }
                let currentTimeMs = 0;
                let lastBeatPosition = 0;
                let lastBpm = timingPoints[0].bpm;
                for (const tp of timingPoints) {
                    const currentBeatPosition = tp.beat[0] + tp.beat[1] / tp.beat[2];
                    const beatDelta = (currentBeatPosition - lastBeatPosition) * BEATS_PER_MEASURE;
                    currentTimeMs += beatDelta * (60000 / lastBpm);
                    tp.timeMs = currentTimeMs;
                    lastBeatPosition = currentBeatPosition;
                    lastBpm = tp.bpm;
                }
                const beatToMs = (beatArray) => {
                    const [measure, numerator, denominator] = beatArray;
                    const noteBeatPosition = measure + numerator / denominator;
                    let targetTp = timingPoints[0];
                    for (let i = timingPoints.length - 1; i >= 0; i--) {
                        const tp = timingPoints[i];
                        const tpBeatPosition = tp.beat[0] + tp.beat[1] / tp.beat[2];
                        if (noteBeatPosition >= tpBeatPosition) {
                            targetTp = tp;
                            break;
                        }
                    }
                    const targetTpBeatPosition = targetTp.beat[0] + targetTp.beat[1] / targetTp.beat[2];
                    const beatDelta = (noteBeatPosition - targetTpBeatPosition) * BEATS_PER_MEASURE;
                    const msSinceTp = beatDelta * (60000 / targetTp.bpm);
                    return Math.round(targetTp.timeMs + msSinceTp + offset);
                };
                for (const note of (data.note || [])) {
                    if (note.column === undefined) continue;
                    const time = beatToMs(note.beat);
                    const lane = note.column;
                    if (note.endbeat) {
                        const endTime = beatToMs(note.endbeat);
                        result.hitObjects.push({ time, lane, type: 'long', endTime });
                    } else {
                        result.hitObjects.push({ time, lane, type: 'note' });
                    }
                }
                result.hitObjects.sort((a, b) => a.time - b.time);
                return result;
            } catch (e) {
                console.error("Malody beatmap parsing failed:", e);
                alert(`Malody譜面の解析に失敗しました: ${e.message}`);
                return null;
            }
        }

        function getBeatmapSettingsKey() { if (currentBeatmapSetId && currentBeatmapVersion) return `${currentBeatmapSetId}_${currentBeatmapVersion}`; return null; }
        function saveBeatmapSpecificSettings() { const key = getBeatmapSettingsKey(); if (!key) return; let settings = JSON.parse(localStorage.getItem('maniaPlayerBeatmapSettings')) || {}; settings[key] = { audioOffset: dom.audioOffsetInput.value, backgroundChoice: dom.backgroundSelector.value }; localStorage.setItem('maniaPlayerBeatmapSettings', JSON.stringify(settings)); }
        function loadBeatmapSpecificSettings() { const key = getBeatmapSettingsKey(); let audioOffset = 0; let backgroundChoice = 'auto'; if (key) { const settings = JSON.parse(localStorage.getItem('maniaPlayerBeatmapSettings')) || {}; const saved = settings[key]; if (typeof saved === 'object' && saved !== null) { audioOffset = saved.audioOffset || 0; backgroundChoice = saved.backgroundChoice || 'auto'; } } dom.audioOffsetInput.value = audioOffset; dom.backgroundSelector.value = backgroundChoice; }
        async function loadAudioWithWebAudioAPI(blobUrl) { audioLoaded = false; audioContextState.isReady = false; checkReadyState(); try { if (!audioContext) { audioContext = new (window.AudioContext || window.webkitAudioContext)(); } const response = await fetch(blobUrl); const arrayBuffer = await response.arrayBuffer(); audioBuffer = await audioContext.decodeAudioData(arrayBuffer); audioLoaded = true; audioContextState.isReady = true; } catch (e) { console.error("Web Audio APIでの音声デコードに失敗:", e); alert("音声ファイルの読み込みに失敗しました。Web Audio APIがサポートされていないか、ファイルが破損している可能性があります。"); audioLoaded = false; } finally { checkReadyState(); } }
        function setupFileListeners() {
            dom.addBeatmapsButton.addEventListener('click', () => {
                isRequestingFile = true;
                dom.oszFileInput.click();
            });
            dom.oszFileInput.addEventListener('change', (e) => addBeatmapsToDB(e.target.files));
            dom.removeBeatmapButton.addEventListener('click', removeBeatmapFromDB);
            dom.beatmapLibrarySelector.addEventListener('change', handleLibrarySelection);
            dom.beatmapSelector.addEventListener('change', handleDifficultySelection);
        }
        async function handleLibrarySelection() {
            const selectedId = parseInt(dom.beatmapLibrarySelector.value, 10);
            resetBeatmapSelection();
            if (isNaN(selectedId)) return;
            currentBeatmapSetId = selectedId;
            try {
                const record = await getBeatmapRecordFromDB(selectedId);
                if (!record || !record.file) throw new Error('File not found in DB.');
                const file = record.file;
                
                dom.songTitleElement.textContent = '読み込み中...';
                const jszip = new JSZip();
                const zip = await jszip.loadAsync(file);
                currentOszFiles = { beatmaps: [], audio: {}, video: {}, image: {} };
                const filePromises = [];
                zip.forEach((relativePath, zipEntry) => {
                    const lowerCasePath = relativePath.toLowerCase();
                    if (lowerCasePath.endsWith('.osu')) {
                        filePromises.push(zipEntry.async('string').then(content => currentOszFiles.beatmaps.push({ name: relativePath, content, type: 'osu' })));
                    } else if (lowerCasePath.endsWith('.mc')) {
                        filePromises.push(zipEntry.async('string').then(content => currentOszFiles.beatmaps.push({ name: relativePath, content, type: 'malody' })));
                    } else if (lowerCasePath.endsWith('.mp3') || lowerCasePath.endsWith('.ogg')) {
                        filePromises.push(zipEntry.async('blob').then(blob => currentOszFiles.audio[zipEntry.name] = URL.createObjectURL(blob)));
                    } else if (lowerCasePath.endsWith('.mp4') || lowerCasePath.endsWith('.webm')) {
                        filePromises.push(zipEntry.async('blob').then(blob => currentOszFiles.video[Object.keys(currentOszFiles.video).length] = URL.createObjectURL(blob)));
                    } else if (lowerCasePath.endsWith('.jpg') || lowerCasePath.endsWith('.jpeg') || lowerCasePath.endsWith('.png')) {
                        filePromises.push(zipEntry.async('blob').then(blob => currentOszFiles.image[Object.keys(currentOszFiles.image).length] = URL.createObjectURL(blob)));
                    }
                });
                await Promise.all(filePromises);
                if (currentOszFiles.beatmaps.length === 0) throw new Error('譜面ファイル (.osu or .mc) が見つかりません。');
                dom.beatmapSelector.innerHTML = '<option value="">-- 難易度を選択 --</option>';
                currentOszFiles.beatmaps.forEach((beatmapFile, index) => {
                    let optionText = beatmapFile.name;
                    try {
                        if (beatmapFile.type === 'osu') {
                            const tempBeatmap = parseBeatmap(beatmapFile.content);
                            optionText = `${tempBeatmap.version || beatmapFile.name} [${tempBeatmap.keyCount}K]`;
                        } else if (beatmapFile.type === 'malody') {
                            const data = JSON.parse(beatmapFile.content);
                            const mode_ext = data.meta.mode_ext || data.meta.meta_ext;
                            if (data.meta && data.meta.mode === 0 && mode_ext) {
                                const keyCount = mode_ext.column || '?';
                                const version = data.meta.version || beatmapFile.name;
                                optionText = `${version} [${keyCount}K Malody]`;
                            }
                        }
                    } catch(e) { /* ignore parse errors for preview */ }
                    const option = new Option(optionText, index);
                    dom.beatmapSelector.appendChild(option);
                });
                dom.beatmapSelectorContainer.style.display = 'block';
                const firstBeatmapFile = currentOszFiles.beatmaps[0];
                let firstBeatmap;
                if (firstBeatmapFile.type === 'malody') {
                    try {
                        const data = JSON.parse(firstBeatmapFile.content);
                        firstBeatmap = { title: data.meta.title, artist: data.meta.artist };
                    } catch(e) {
                        firstBeatmap = { title: 'Invalid Malody Chart', artist: '' };
                    }
                } else {
                    firstBeatmap = parseBeatmap(firstBeatmapFile.content);
                }
                dom.songTitleElement.textContent = firstBeatmap.title || '難易度を選択してください';
                dom.songArtistElement.textContent = firstBeatmap.artist || '';
                dom.saveOszButton.disabled = false;
            } catch (err) {
                alert('譜面の読み込みに失敗しました: ' + err.message);
                resetBeatmapSelection();
            }
        }
        function handleDifficultySelection() {
            const selectedIndex = dom.beatmapSelector.value;
            beatmap = null;
            audioLoaded = false;
            currentBeatmapVersion = null;
            checkReadyState();
            dom.backgroundSelectorContainer.style.display = 'none';
            dom.force4kContainer.style.display = 'none';
            dom.force4kCheckbox.checked = false;
            applyBackgroundChoice();
            if (selectedIndex === "") { return; }
            const selectedBeatmapFile = currentOszFiles.beatmaps[parseInt(selectedIndex, 10)];
            if (!selectedBeatmapFile) return;

            try {
                if (selectedBeatmapFile.type === 'malody') {
                    beatmap = parseMalodyBeatmap(selectedBeatmapFile.content);
                } else {
                    beatmap = parseBeatmap(selectedBeatmapFile.content);
                }
                if (!beatmap) { return; }
                
                updateJudgmentWindows(beatmap.overallDifficulty);
                
                if (beatmap.keyCount > 4) {
                    dom.force4kContainer.style.display = 'block';
                }
                setKeyCount(beatmap.keyCount);
                dom.keyCountSelector.value = beatmap.keyCount;
                dom.keyCountSelector.disabled = true;
                currentBeatmapVersion = beatmap.version;
                updateBackgroundSelector();
                loadBeatmapSpecificSettings();
                applyBackgroundChoice();
                dom.songTitleElement.textContent = beatmap.title || '（タイトル不明）';
                dom.songArtistElement.textContent = beatmap.artist || '（アーティスト不明）';

                let audioSrc = null;
                const audioFiles = Object.keys(currentOszFiles.audio);
                
                if (beatmap.audioFilename) {
                    const targetAudioPath = beatmap.audioFilename.replace(/\\/g, '/').toLowerCase();
                    
                    for (const fullPath of audioFiles) {
                        if (fullPath.replace(/\\/g, '/').toLowerCase().endsWith(targetAudioPath)) {
                            audioSrc = currentOszFiles.audio[fullPath];
                            break;
                        }
                    }
                }
                
                if (!audioSrc && audioFiles.length === 1) {
                    audioSrc = currentOszFiles.audio[audioFiles[0]];
                }

                if (audioSrc) {
                    loadAudioWithWebAudioAPI(audioSrc);
                } else {
                    alert(`音声ファイル "${beatmap.audioFilename || '指定なし'}" が見つかりません。`);
                }
            } catch (err) {
                alert('譜面ファイルの解析に失敗しました。');
                console.error(err);
            } finally {
                checkReadyState();
            }
        }
        function resetBeatmapSelection() { beatmap = null; audioLoaded = false; audioBuffer = null; currentOszFiles = { beatmaps: [], audio: {}, video: {}, image: {} }; dom.beatmapSelectorContainer.style.display = 'none'; dom.beatmapSelector.innerHTML = ''; dom.backgroundSelectorContainer.style.display = 'none'; dom.force4kContainer.style.display = 'none'; dom.force4kCheckbox.checked = false; applyBackgroundChoice(); dom.songTitleElement.textContent = '譜面を選択してください'; dom.songArtistElement.textContent = ''; dom.saveOszButton.disabled = true; currentBeatmapSetId = null; currentBeatmapVersion = null; dom.keyCountSelector.disabled = false; loadBeatmapSpecificSettings(); checkReadyState(); }
        function updateBackgroundSelector() { const hasVideo = Object.keys(currentOszFiles.video).length > 0; const hasImage = Object.keys(currentOszFiles.image).length > 0; dom.backgroundSelector.innerHTML = ''; if(hasVideo || hasImage) { dom.backgroundSelector.add(new Option('自動', 'auto')); if(hasVideo) dom.backgroundSelector.add(new Option('動画', 'video')); if(hasImage) dom.backgroundSelector.add(new Option('画像', 'image')); dom.backgroundSelector.add(new Option('なし', 'none')); dom.backgroundSelectorContainer.style.display = 'block'; } else { dom.backgroundSelectorContainer.style.display = 'none'; } }
        function applyBackgroundChoice() { const choice = dom.backgroundSelector.value; const videoURL = Object.values(currentOszFiles.video)[0]; const imageURL = Object.values(currentOszFiles.image)[0]; dom.videoBackground.style.display = 'none'; dom.imageBackground.style.display = 'none'; let show = choice; if (choice === 'auto') { if (videoURL) show = 'video'; else if (imageURL) show = 'image'; else show = 'none'; } if (show === 'video' && videoURL) { dom.videoBackground.src = videoURL; dom.videoBackground.style.display = 'block'; } else if (show === 'image' && imageURL) { dom.imageBackground.src = imageURL; dom.imageBackground.style.display = 'block'; } }
        function checkReadyState() { dom.startButton.disabled = !(beatmap && audioLoaded); }
        function updateSpeed() { dom.speedLabel.textContent = `ノーツ速度 (x${parseFloat(dom.speedSlider.value).toFixed(1)})`; }
        function getFallMs() { return BASE_FALL_MS / parseFloat(dom.speedSlider.value); }
        function setKeyCount(count) { numLanes = parseInt(count, 10); root.style.setProperty('--num-lanes', numLanes); activeKeys = keyConfigs[numLanes]; initKeyConfig(); initGameUI(); }
        function initKeyConfig() { dom.keyConfigInputsContainer.innerHTML = ''; const currentKeys = keyConfigs[numLanes] || []; for (let i = 0; i < numLanes; i++) { const keyInput = document.createElement('div'); keyInput.className = 'key-config-input'; keyInput.textContent = currentKeys[i] || '...'; keyInput.dataset.laneIndex = i; keyInput.tabIndex = 0; keyInput.addEventListener('click', e => { if (isGameRunning) return; root.querySelectorAll('.key-config-input.is-waiting').forEach(el => el.blur()); e.currentTarget.textContent = '...'; e.currentTarget.classList.add('is-waiting'); }); keyInput.addEventListener('blur', e => { e.currentTarget.classList.remove('is-waiting'); e.currentTarget.textContent = keyConfigs[numLanes][e.currentTarget.dataset.laneIndex]; }); keyInput.addEventListener('keydown', e => { e.preventDefault(); if (!e.currentTarget.classList.contains('is-waiting')) return; if (e.key === 'Escape') { e.currentTarget.blur(); return; } const newKey = e.key.toUpperCase(); if (newKey.length !== 1 && newKey !== ' ') return; const index = parseInt(e.currentTarget.dataset.laneIndex, 10); if (keyConfigs[numLanes].some((key, k_idx) => key === newKey && k_idx !== index)) { alert('そのキーは他のレーンで既に使用されています。'); return; } keyConfigs[numLanes][index] = newKey; e.currentTarget.blur(); updateKeyIndicators(); saveSettings(); }); dom.keyConfigInputsContainer.appendChild(keyInput); } }
        function initGameUI() {
            dom.lanesContainer.innerHTML = '';
            dom.keyIndicatorsContainer.innerHTML = '';
            for (let i = 0; i < numLanes; i++) {
                const laneElement = document.createElement('div');
                laneElement.classList.add('lane');
                laneElement.dataset.laneIndex = i;
                dom.lanesContainer.appendChild(laneElement);
                
                const touchStartHandler = e => {
                    e.preventDefault();
                    if (!isGameRunning || isPaused || isAutoPlay) return;
                    const laneIndex = parseInt(e.currentTarget.dataset.laneIndex, 10);
                    if (keyState[laneIndex]) return;
                    keyState[laneIndex] = true;
                    keyJustPressed[laneIndex] = true;
                };
                
                const touchEndHandler = e => {
                    e.preventDefault();
                    if (!isGameRunning || isPaused || isAutoPlay) return;
                    const laneIndex = parseInt(e.currentTarget.dataset.laneIndex, 10);
                    keyState[laneIndex] = false;
                    judgeRelease(laneIndex);
                };

                laneElement.addEventListener('touchstart', touchStartHandler, { passive: false });
                laneElement.addEventListener('touchend', touchEndHandler);
                laneElement.addEventListener('touchcancel', touchEndHandler);

                const keyIndicator = document.createElement('div');
                keyIndicator.classList.add('key');
                dom.keyIndicatorsContainer.appendChild(keyIndicator);
            }
            updateKeyIndicators();
        }
        function updateKeyIndicators() { const currentKeys = keyConfigs[numLanes] || []; dom.keyConfigInputsContainer.childNodes.forEach((input, i) => { if (currentKeys[i]) input.textContent = currentKeys[i]; }); if(dom.keyIndicatorsContainer) { dom.keyIndicatorsContainer.childNodes.forEach((indicator, i) => { if (currentKeys[i]) indicator.textContent = currentKeys[i]; }); } }
        function resetGame() {
            score = 0; combo = 0; maxCombo = 0; accuracy = 100; totalJudgments = 0; weightedAccuracy = 0; nextUnjudgedNoteIndex = 0;
            judgmentCounts = { 'PERFECT+': 0, PERFECT: 0, GREAT: 0, GOOD: 0, OK: 0, MISS: 0 };
            keyState = Array(numLanes).fill(false);
            keyJustPressed = Array(numLanes).fill(false);
            dom.scoreElement.textContent = score;
            dom.accuracyElement.textContent = '100.00%';
            if(dom.errorBar) dom.errorBar.innerHTML = '';
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            allNotes.forEach(note => { if (note.tickInterval) clearInterval(note.tickInterval); });
            allNotes = [];
            activeHolds = Array(numLanes).fill(null);
            dom.lanesContainer.querySelectorAll('.note-wrapper').forEach(n => n.remove());
            dom.keyIndicatorsContainer.childNodes.forEach(key => key.classList.remove('active'));
            dom.resultsOverlay.style.display = 'none';
            isGameRunning = false; isPaused = false;
            dom.comboContainer.classList.remove('visible');
            dom.comboCount.textContent = '0';
            if (audioSourceNode) { audioSourceNode.stop(); audioSourceNode = null; }
            audioContextState.pausedAt = 0; audioContextState.startedAt = 0;
            const canvas = root.querySelector('#mania-gameplay-progress-pie');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }
        function createNoteElement(note) { const wrapper = document.createElement('div'); wrapper.className = 'note-wrapper'; const noteHead = document.createElement('div'); noteHead.className = 'note'; if (note.type === 'long') { const body = document.createElement('div'); body.className = 'long-note-body'; wrapper.appendChild(body); } wrapper.appendChild(noteHead); note.element = wrapper; }
        async function startGame() {
            if (isGameRunning || !beatmap || !audioLoaded) return;
            const originalKeyCount = beatmap.keyCount;
            const is4kConversion = dom.force4kCheckbox.checked && originalKeyCount > 4;

            resetGame();

            gameContext.rate = 1.0;
            if (activeMods.DT) gameContext.rate = 1.5;
            if (activeMods.HT) gameContext.rate = 0.75;
            const applyRate = (time) => Math.round(time / gameContext.rate);

            let notesToPlay = beatmap.hitObjects.map(obj => ({
                ...obj,
                time: applyRate(obj.time),
                endTime: obj.endTime ? applyRate(obj.endTime) : undefined,
                element: null, spawned: false, judged: false, hit: false, released: false
            }));

            if (is4kConversion) {
                const startLane = Math.floor((originalKeyCount - 4) / 2);
                const endLane = startLane + 4;
                notesToPlay = notesToPlay
                    .filter(note => note.lane >= startLane && note.lane < endLane)
                    .map(note => ({ ...note, lane: note.lane - startLane }));
                setKeyCount(4);
            } else {
                setKeyCount(originalKeyCount);
            }
            allNotes = notesToPlay;
            activeKeys = keyConfigs[numLanes];
            keyState = Array(numLanes).fill(false);
            keyJustPressed = Array(numLanes).fill(false);

            allNotes.forEach(note => {
                createNoteElement(note);
                note.element.classList.add('hidden');
                if (dom.lanesContainer.children[note.lane]) {
                    dom.lanesContainer.children[note.lane].appendChild(note.element);
                }
            });

            dom.appContainer.style.display = 'none';
            dom.gameContainer.style.display = 'block';
            
            await new Promise(resolve => {
                let warmUpFrames = 30;
                const warmUpLoop = () => {
                    if (warmUpFrames-- <= 0) { resolve(); return; }
                    updateNotePositions(-5000, 0, (getGameHeight() / getFallMs()), getGameHeight(), getGameHeight() * (JUDGMENT_LINE_POS_VH / 100));
                    requestAnimationFrame(warmUpLoop);
                };
                warmUpLoop();
            });

            dom.countdownOverlay.style.display = 'flex'; 
            dom.gameContainer.classList.add('playing');
            for (let i = 3; i > 0; i--) {
                dom.countdownText.textContent = i;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            dom.countdownText.textContent = 'START!';
            await new Promise(resolve => setTimeout(resolve, 500));
            dom.countdownOverlay.style.display = 'none';
            
            isGameRunning = true;
            isPaused = false;
            isAutoPlay = dom.autoPlayCheckbox.checked;
            const lastNote = allNotes.length > 0 ? allNotes[allNotes.length - 1] : { endTime: 0, time: 0 };
            songDuration = (lastNote.endTime || lastNote.time);
            gameEndTime = songDuration + 3000;
            drawProgressPie('mania-gameplay-progress-pie', 0);
            const visualPreRollMs = getFallMs();
            const totalDelayMs = visualPreRollMs + AUDIO_START_DELAY_MS;
            gameContext.visualStartTime = performance.now();
            const scheduledAudioStartTime = audioContext.currentTime + (totalDelayMs / 1000.0);
            playAudio(0, scheduledAudioStartTime);
            if (dom.videoBackground.style.display !== 'none') {
                setTimeout(() => { if (isGameRunning) dom.videoBackground.play(); }, totalDelayMs);
                dom.videoBackground.currentTime = 0;
                dom.videoBackground.playbackRate = gameContext.rate;
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        function playAudio(offsetSeconds = 0, startTime = 0) { if (!audioContextState.isReady || !audioBuffer) return; if (audioSourceNode) { audioSourceNode.stop(); } audioSourceNode = audioContext.createBufferSource(); audioSourceNode.buffer = audioBuffer; audioSourceNode.connect(audioContext.destination); audioSourceNode.playbackRate.value = gameContext.rate; const startOffset = Math.max(0, offsetSeconds); const scheduledStart = Math.max(audioContext.currentTime, startTime); audioContextState.startedAt = scheduledStart - startOffset; audioSourceNode.start(scheduledStart, startOffset); }
        function getCurrentBeatmapTime() { if (!isGameRunning) return -Infinity; if (isPaused) { return (audioContextState.pausedAt * 1000) - (applyRateToTime(beatmap.audioLeadIn) || 0) + (parseInt(dom.audioOffsetInput.value, 10) || 0); } if (audioContextState.startedAt > 0) { const elapsed = (audioContext.currentTime - audioContextState.startedAt) * 1000 * gameContext.rate; return elapsed - (beatmap.audioLeadIn || 0) + (parseInt(dom.audioOffsetInput.value, 10) || 0); } const visualElapsed = performance.now() - gameContext.visualStartTime; return (visualElapsed - (getFallMs() + AUDIO_START_DELAY_MS)) * gameContext.rate; }
        function applyRateToTime(time) { return time / gameContext.rate; }
        function gameLoop() {
            if (!isGameRunning) return;
            if (!isPaused) {
                const now = getCurrentBeatmapTime() / gameContext.rate;
                const noteUserOffset = parseInt(dom.offsetInput.value, 10) || 0;
                
                if (songDuration > 0) {
                    const progress = now / songDuration;
                    drawProgressPie('mania-gameplay-progress-pie', progress);
                }
                
                if (isAutoPlay) {
                    autoPlayHandler(now, noteUserOffset);
                } else {
                    processHitsInLoop(now, noteUserOffset);
                    updateNoteStates(now, noteUserOffset);
                }

                // Visual updates
                const fallMs = getFallMs();
                const gameHeight = getGameHeight();
                const judgmentLinePx = gameHeight * (JUDGMENT_LINE_POS_VH / 100);
                const totalFallDistance = (gameHeight - judgmentLinePx) + NOTE_SPAWN_OFFSET_Y;
                const pixelsPerMs = totalFallDistance / fallMs;
                updateNotePositions(now, noteUserOffset, pixelsPerMs, gameHeight, judgmentLinePx);
                updateLaneLights();

                if (now > gameEndTime) {
                    isGameRunning = false;
                    showResults();
                }
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        function updateLaneLights() {
            for (let i = 0; i < numLanes; i++) {
                dom.keyIndicatorsContainer.children[i].classList.toggle('active', keyState[i]);
            }
        }
        function updateNotePositions(now, userOffset, pixelsPerMs, gameHeight, judgmentLinePx) { const isCircleStyle = dom.playfield.classList.contains('note-style-circle'); const noteHeightForOffset = isCircleStyle ? 70 : 22; const yOffset = noteHeightForOffset / 2; for (const note of allNotes) { if ((note.judged && note.type === 'note') || note.released) continue; const timeToHit = (note.time + userOffset) - now; let headY = (gameHeight - judgmentLinePx) - (timeToHit * pixelsPerMs); if (!note.spawned && headY > -noteHeightForOffset) { note.spawned = true; note.element.classList.remove('hidden'); } if (note.element) { if (activeMods.HD) { const fadeInEndPos = gameHeight * 0.40; const fadeOutStartPos = gameHeight * 0.75; if (headY > fadeInEndPos) { const fadeProgress = Math.max(0, Math.min(1, (headY - fadeInEndPos) / (fadeOutStartPos - fadeInEndPos))); note.element.style.opacity = 1 - fadeProgress; } else { note.element.style.opacity = 1; } } if (note.type === 'long' && note.hit) { headY = gameHeight - judgmentLinePx; if (note.element.querySelector('.note')) note.element.querySelector('.note').style.display = 'none'; } note.element.style.transform = `translateY(${headY - yOffset}px)`; if (note.type === 'long') { const body = note.element.querySelector('.long-note-body'); if (body) { const timeToRelease = (note.endTime + userOffset) - now; const tailY = (gameHeight - judgmentLinePx) - (timeToRelease * pixelsPerMs); const headHeight = noteHeightForOffset; const bodyTopOffset = headHeight / 2; body.style.top = `${tailY - headY}px`; body.style.height = `${Math.max(0, (headY + bodyTopOffset) - tailY)}px`; } } } if (headY > gameHeight + 50) { if (note.element) note.element.classList.add('hidden'); note.judged = true; note.released = true; } } }
        function autoPlayHandler(now, userOffset) { for (const note of allNotes) { if (!note.judged && now >= (note.time + userOffset)) handleHit('PERFECT+', note, 0); if (note.type === 'long' && note.hit && !note.released && now >= (note.endTime + userOffset)) judgeRelease(note.lane, { isAutoCompletion: true }); } }
        function updateNoteStates(now, userOffset) {
            while (nextUnjudgedNoteIndex < allNotes.length) {
                const note = allNotes[nextUnjudgedNoteIndex];
                if (note.judged) {
                    nextUnjudgedNoteIndex++;
                    continue;
                }
                if (now > (note.time + userOffset) + JUDGMENT_WINDOWS.MISS) {
                    handleHit('MISS', note, JUDGMENT_WINDOWS.MISS + 1);
                } else {
                    break;
                }
            }
            for (let i = 0; i < activeHolds.length; i++) {
                const holdNote = activeHolds[i];
                if (holdNote && now > (holdNote.endTime + userOffset)) {
                    judgeRelease(i, { isAutoCompletion: true });
                }
            }
        }
        function processHitsInLoop(now, userOffset) {
            for(let laneIndex=0; laneIndex<numLanes; ++laneIndex) {
                if(keyJustPressed[laneIndex]) {
                    keyJustPressed[laneIndex] = false; // Consume the press
                    let bestNote = null;
                    let bestDiff = Infinity;
                    
                    for (let i = nextUnjudgedNoteIndex; i < allNotes.length; i++) {
                        const note = allNotes[i];
                        if (note.time + userOffset > now + JUDGMENT_WINDOWS.MISS) {
                            break;
                        }
                        if (note.lane === laneIndex && !note.judged) {
                            const diff = Math.abs(now - (note.time + userOffset));
                             if (diff < bestDiff) {
                                bestDiff = diff;
                                bestNote = note;
                            }
                        }
                    }

                    if (bestNote && bestDiff <= JUDGMENT_WINDOWS.MISS) {
                         let judgment = 'MISS';
                         if (bestDiff <= JUDGMENT_WINDOWS.OK) judgment = 'OK';
                         if (bestDiff <= JUDGMENT_WINDOWS.GOOD) judgment = 'GOOD';
                         if (bestDiff <= JUDGMENT_WINDOWS.GREAT) judgment = 'GREAT';
                         if (bestDiff <= JUDGMENT_WINDOWS.PERFECT) judgment = 'PERFECT';
                         if (bestDiff <= JUDGMENT_WINDOWS.PERFECT_PLUS) judgment = 'PERFECT+';
                         
                         handleHit(judgment, bestNote, now - (bestNote.time + userOffset));
                    }
                }
            }
        }
        function judgeRelease(laneIndex, { isAutoCompletion = false } = {}) { const holdNote = activeHolds[laneIndex]; if (!holdNote) return; const cleanup = () => { clearInterval(holdNote.tickInterval); holdNote.tickInterval = null; activeHolds[laneIndex] = null; holdNote.released = true; if (holdNote.element) holdNote.element.classList.add('hidden'); dom.scoreElement.textContent = score; }; if (isAutoCompletion) { showJudgment('PERFECT+'); updateAccuracy('PERFECT+'); score += 300; judgmentCounts['PERFECT+']++; cleanup(); return; } const userOffset = parseInt(dom.offsetInput.value, 10) || 0; const now = getCurrentBeatmapTime() / gameContext.rate; const diff = now - (holdNote.endTime + userOffset); if (diff >= -JUDGMENT_WINDOWS.GOOD) { showJudgment('PERFECT+'); updateAccuracy('PERFECT+'); score += 300; judgmentCounts['PERFECT+']++; } else { combo = 0; dom.comboContainer.classList.remove('visible'); showJudgment('MISS'); updateAccuracy('MISS'); judgmentCounts.MISS++; } cleanup(); }
        
        function handleKeydown(e) {
            if (activeGame !== 'mania' || e.repeat) return;
	    e.preventDefault();
            if (!isGameRunning || isPaused || isAutoPlay) return; 
            const laneIndex = activeKeys.indexOf(e.key.toUpperCase());
            if (laneIndex === -1 || keyState[laneIndex]) return; 
            keyState[laneIndex] = true; 
            keyJustPressed[laneIndex] = true; 
        }

        function handleKeyup(e) {
            if(activeGame !== 'mania') return;
            if (!isGameRunning || isPaused || isAutoPlay) return;
            const laneIndex = activeKeys.indexOf(e.key.toUpperCase());
            if (laneIndex === -1) return;
            keyState[laneIndex] = false;
            judgeRelease(laneIndex);
        }

        document.addEventListener('keydown', handleKeydown);
        document.addEventListener('keyup', handleKeyup);

        function handleHit(judgment, note, diff) { if (note.judged) return; note.judged = true; judgmentCounts[judgment]++; updateAccuracy(judgment); if (judgment === 'MISS') { combo = 0; dom.comboContainer.classList.remove('visible'); } else { if (judgment === 'PERFECT+') score += 300; else if (judgment === 'PERFECT') score += 290; else if (judgment === 'GREAT') score += 200; else if (judgment === 'GOOD') score += 100; else if (judgment === 'OK') score += 50; combo++; note.hit = true; showHitError(diff); showJudgmentTiming(diff); } if (combo > maxCombo) maxCombo = combo; if (combo > 2) { dom.comboContainer.classList.add('visible'); dom.comboCount.textContent = combo; dom.comboCount.classList.remove('combo-anim'); void dom.comboCount.offsetWidth; dom.comboCount.classList.add('combo-anim'); } showJudgment(judgment); if (note.type === 'note') { if(note.element) note.element.classList.add('hidden'); } else if (note.type === 'long') { if (judgment !== 'MISS') { activeHolds[note.lane] = note; note.tickInterval = setInterval(() => { score += TICK_SCORE_AMOUNT; dom.scoreElement.textContent = score; }, TICK_SCORE_INTERVAL); } else { if(note.element) note.element.classList.add('hidden'); } } dom.scoreElement.textContent = score; }
        function updateAccuracy(judgment) {
            totalJudgments++;
            if (judgment === 'PERFECT+') weightedAccuracy += 300;
            else if (judgment === 'PERFECT') weightedAccuracy += 290;
            else if (judgment === 'GREAT') weightedAccuracy += 200;
            else if (judgment === 'GOOD') weightedAccuracy += 100;
            else if (judgment === 'OK') weightedAccuracy += 50;
            accuracy = (weightedAccuracy / (totalJudgments * 300)) * 100;
            dom.accuracyElement.textContent = accuracy.toFixed(2) + '%';
        }
        function showHitError(diff) {
            if (!dom.errorBar) return;
            const tick = document.createElement('div');
            tick.className = 'error-tick';
            const percentage = (diff + JUDGMENT_WINDOWS.MISS) / (JUDGMENT_WINDOWS.MISS * 2) * 100;
            tick.style.left = `${Math.max(0, Math.min(100, percentage))}%`;
            dom.errorBar.appendChild(tick);
            setTimeout(() => {
                if(tick.parentNode) {
                    tick.remove();
                }
            }, 1500); // Match animation duration
        }
        function showJudgment(text) {
            const el = dom.judgmentTextElement;
            const judgmentStyles = {
                'PERFECT+': { bg: 'transparent', color: '#FFD700' }, 
                PERFECT: { bg: 'transparent', color: '#4CAF50' },
                GREAT: { bg: 'transparent', color: '#2196F3' },
                GOOD: { bg: 'transparent', color: '#FFC107' },
                OK: { bg: 'transparent', color: '#dda0dd' },
                MISS: { bg: 'transparent', color: '#F44336' }
            };
            const style = judgmentStyles[text] || { bg: 'transparent', color: 'white' };
            el.textContent = text;
            el.style.backgroundColor = style.bg;
            el.style.color = style.color;
            el.style.animation = 'none';
            el.offsetHeight;
            el.style.animation = null;
        }
        function showJudgmentTiming(diff) { const el = dom.judgmentTimingTextElement; let text = ''; if (diff < -EARLY_LATE_THRESHOLD) text = 'Early'; else if (diff > EARLY_LATE_THRESHOLD) text = 'Late'; el.textContent = text; el.style.animation = 'none'; el.offsetHeight; el.style.animation = null; }
        function updatePauseSelection() { const buttons = dom.pauseOverlay.querySelectorAll('.overlay-button'); buttons.forEach((btn, index) => { btn.classList.toggle('selected', index === selectedPauseIndex); }); }
        
        function togglePause() { 
            if (!isGameRunning) return; 
            isPaused = !isPaused; 
            if (isPaused) { 
                if (audioSourceNode) { 
                    audioSourceNode.stop(); 
                    audioSourceNode = null; 
                } 
                audioContextState.pausedAt = (audioContext.currentTime - audioContextState.startedAt); 
                if(dom.videoBackground.style.display !== 'none') dom.videoBackground.pause(); 
                dom.gameContainer.classList.remove('playing'); 
                dom.pauseOverlay.style.display = 'flex'; 
                selectedPauseIndex = 0; 
                updatePauseSelection(); 
            } else { 
                playAudio(audioContextState.pausedAt, 0); 
                if(dom.videoBackground.style.display !== 'none') dom.videoBackground.play(); 
                dom.gameContainer.classList.add('playing'); 
                dom.pauseOverlay.style.display = 'none'; 
            } 
        }

        document.addEventListener('keydown', e => {
            if (activeGame === 'mania' && isPaused) {
                const buttons = dom.pauseOverlay.querySelectorAll('.overlay-button');
                if (buttons.length === 0) return;
                
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedPauseIndex = (selectedPauseIndex - 1 + buttons.length) % buttons.length;
                    updatePauseSelection();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedPauseIndex = (selectedPauseIndex + 1) % buttons.length;
                    updatePauseSelection();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    buttons[selectedPauseIndex].click();
                }
            }
        });

        function retryGame() { if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; isGameRunning = false; isPaused = false; if(dom.videoBackground.src) { dom.videoBackground.pause(); dom.videoBackground.currentTime = 0; } dom.pauseOverlay.style.display = 'none'; dom.resultsOverlay.style.display = 'none'; startGame(); }
        function returnToControls() {
            isGameRunning = false;
            isPaused = false;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            if(dom.videoBackground.src) {
                dom.videoBackground.pause();
                dom.videoBackground.currentTime = 0;
            }
            dom.pauseOverlay.style.display = 'none';
            dom.resultsOverlay.style.display = 'none';
            dom.gameContainer.classList.remove('playing');
            dom.gameContainer.style.display = 'none';
            dom.appContainer.style.display = 'flex';
            resetGame();
        }
        function showResults() {
            playEndTime = getCurrentBeatmapTime();
            dom.resultsScore.textContent = score;
            dom.resultsAccuracy.textContent = accuracy.toFixed(2);
            dom.resultsMaxCombo.textContent = maxCombo;
            
            const totalNotes = Object.values(judgmentCounts).reduce((a, b) => a + b, 0);
            
            const updateResult = (name, valueElem, percentElem) => {
                const count = judgmentCounts[name];
                valueElem.textContent = count;
                const percent = totalNotes > 0 ? (count / totalNotes * 100).toFixed(2) : 0;
                percentElem.textContent = `(${percent}%)`;
            };

            updateResult('PERFECT+', dom.resultsPerfectPlus, dom.resultsPerfectPlusPercent);
            updateResult('PERFECT', dom.resultsPerfect, dom.resultsPerfectPercent);
            updateResult('GREAT', dom.resultsGreat, dom.resultsGreatPercent);
            updateResult('GOOD', dom.resultsGood, dom.resultsGoodPercent);
            updateResult('OK', dom.resultsOk, dom.resultsOkPercent);
            updateResult('MISS', dom.resultsMiss, dom.resultsMissPercent);

            let rank = 'S';
            if (accuracy < 95) rank = 'A';
            if (accuracy < 90) rank = 'B';
            if (accuracy < 80) rank = 'C';
            if (accuracy < 70) rank = 'D';
            if (dom.resultsRankValue) dom.resultsRankValue.textContent = rank;

            dom.resultsOverlay.style.display = 'flex';
            dom.gameContainer.classList.remove('playing');
        }
        async function saveOszFileToPC() {
            const selector = dom.beatmapLibrarySelector;
            const selectedId = parseInt(selector.value, 10);
            if (isNaN(selectedId)) {
                alert('保存する譜面をライブラリから選択してください。');
                return;
            }
            
            const selectedOption = selector.options[selector.selectedIndex];
            if (!selectedOption) {
                 alert('有効な譜面が選択されていません。');
                 return;
            }
            
            try {
                const record = await getBeatmapRecordFromDB(selectedId);
                if (!record || !record.file) throw new Error('データベースから譜面ファイルが見つかりませんでした。');
        
                const fileBlob = record.file;
                const fileName = selectedOption.text;
        
                const url = URL.createObjectURL(fileBlob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (err) {
                alert(`ファイルの保存に失敗しました。\nエラー: ${err.message}`);
                console.error('Failed to save .osz file:', err);
            }
        }
        function setupMods() { dom.modSelectContainer.addEventListener('click', (e) => { const button = e.target.closest('.mod-button'); if (!button) return; const mod = button.dataset.mod; activeMods[mod] = !activeMods[mod]; button.classList.toggle('active', activeMods[mod]); if (mod === 'HT' && activeMods.HT) { activeMods.DT = false; dom.modSelectContainer.querySelector('[data-mod="DT"]').classList.remove('active'); } if (mod === 'DT' && activeMods.DT) { activeMods.HT = false; dom.modSelectContainer.querySelector('[data-mod="HT"]').classList.remove('active'); } saveSettings(); }); }
        function applyBrightness(value) { root.style.setProperty('--background-brightness', value / 100); if (dom.brightnessValue) dom.brightnessValue.textContent = value; }
        function applyLaneOpacity(value) { if (dom.noteStyleSelector.value === 'circle') { root.style.setProperty('--playfield-bg-opacity', value / 100); } else { root.style.setProperty('--lane-opacity', value / 100); } if (dom.laneOpacityValue) dom.laneOpacityValue.textContent = value; }
        function updateOpacitySliderLabel() { const labelText = (dom.noteStyleSelector.value === 'circle') ? 'プレイエリアの不透明度: ' : 'レーンの不透明度: '; dom.laneOpacityLabel.firstChild.textContent = labelText; }
        function applyComboSize(value) { root.style.setProperty('--combo-size-scale', value / 100); if (dom.comboSizeValue) dom.comboSizeValue.textContent = value; }
        function applyComboPositionY(value) { root.style.setProperty('--combo-position-y', value + '%'); if (dom.comboPositionValue) dom.comboPositionValue.textContent = value; }
        function applyJudgmentPositionY(value) { root.style.setProperty('--judgment-text-top', value + 'vh'); if (dom.judgmentPositionValue) dom.judgmentPositionValue.textContent = value; }
        function applyNoteStyle(style) { dom.playfield.classList.toggle('note-style-circle', style === 'circle'); updateOpacitySliderLabel(); applyLaneOpacity(dom.laneOpacitySlider.value); }
        function saveSettings() { const settings = { speed: dom.speedSlider.value, offset: dom.offsetInput.value, autoPlay: dom.autoPlayCheckbox.checked, force4k: dom.force4kCheckbox.checked, keyConfigs: keyConfigs, mods: activeMods, noteStyle: dom.noteStyleSelector.value, brightness: dom.backgroundBrightnessSlider.value, laneOpacity: dom.laneOpacitySlider.value, comboSize: dom.comboSizeSlider.value, comboPosition: dom.comboPositionSlider.value, judgmentPosition: dom.judgmentPositionSlider.value, keyCount: numLanes }; localStorage.setItem('maniaPlayerSettings', JSON.stringify(settings)); }
        function loadSettings() { const savedSettings = localStorage.getItem('maniaPlayerSettings'); const defaultConfigs = generateDefaultKeyConfigs(); if (savedSettings) { const settings = JSON.parse(savedSettings); dom.speedSlider.value = settings.speed || 1.5; dom.offsetInput.value = settings.offset || 0; dom.autoPlayCheckbox.checked = settings.autoPlay || false; dom.force4kCheckbox.checked = settings.force4k || false; keyConfigs = { ...defaultConfigs, ...settings.keyConfigs }; if(settings.mods) { activeMods = settings.mods; Object.keys(activeMods).forEach(modKey => { const button = dom.modSelectContainer.querySelector(`[data-mod="${modKey}"]`); if (button) button.classList.toggle('active', activeMods[modKey]); }); } const noteStyle = settings.noteStyle || 'bar'; dom.noteStyleSelector.value = noteStyle; dom.backgroundBrightnessSlider.value = settings.brightness || 50; dom.laneOpacitySlider.value = settings.laneOpacity || 50; dom.comboSizeSlider.value = settings.comboSize || 100; dom.comboPositionSlider.value = settings.comboPosition || 45; dom.judgmentPositionSlider.value = settings.judgmentPosition || 65; dom.keyCountSelector.value = settings.keyCount || 4; } else { keyConfigs = defaultConfigs; } setKeyCount(dom.keyCountSelector.value); updateSpeed(); applyBrightness(dom.backgroundBrightnessSlider.value); applyComboSize(dom.comboSizeSlider.value); applyComboPositionY(dom.comboPositionSlider.value); applyJudgmentPositionY(dom.judgmentPositionSlider.value); applyNoteStyle(dom.noteStyleSelector.value); }
        function updateJudgmentWindows(od) {
            JUDGMENT_WINDOWS = {
                PERFECT_PLUS: 16,
                PERFECT: 64 - (3 * od),
                GREAT: 97 - (3 * od),
                GOOD: 127 - (3 * od),
                OK: 151 - (3 * od),
                MISS: 188 - (3 * od)
            };
        }
        
        return {
            initialize: async function() {
                for (let i = 4; i <= 10; i++) { dom.keyCountSelector.add(new Option(`${i}K`, i)); }
                loadSettings();
                setupMods();
                try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { alert("Web Audio APIがこのブラウザではサポートされていません。"); }
                try { await initDB(); await loadBeatmapsFromDB(); } catch (error) { console.error("Failed to initialize DB:", error); alert("データベースの初期化に失敗しました。譜面ライブラリ機能は使用できません。"); }
                setupFileListeners();
                dom.startButton.addEventListener('click', startGame);
                dom.resumeButton.addEventListener('click', togglePause);
                dom.retryButton.addEventListener('click', retryGame);
                dom.backToMenuButton.addEventListener('click', returnToControls);
                dom.resultsRetryButton.addEventListener('click', retryGame);
                dom.resultsMenuButton.addEventListener('click', returnToControls);
                dom.switchToTaikoButton.addEventListener('click', switchToTaiko);
                dom.ingamePauseButton.addEventListener('click', togglePause);
                dom.saveOszButton.addEventListener('click', saveOszFileToPC);
                dom.speedSlider.addEventListener('input', () => { updateSpeed(); saveSettings(); });
                dom.offsetInput.addEventListener('change', saveSettings);
                dom.audioOffsetInput.addEventListener('change', saveBeatmapSpecificSettings);
                dom.backgroundSelector.addEventListener('change', () => { applyBackgroundChoice(); saveBeatmapSpecificSettings(); });
                dom.autoPlayCheckbox.addEventListener('change', saveSettings);
                dom.force4kCheckbox.addEventListener('change', saveSettings);
                dom.noteStyleSelector.addEventListener('input', (e) => { applyNoteStyle(e.target.value); saveSettings(); });
                dom.backgroundBrightnessSlider.addEventListener('input', (e) => { applyBrightness(e.target.value); saveSettings(); });
                dom.laneOpacitySlider.addEventListener('input', (e) => { applyLaneOpacity(e.target.value); saveSettings(); });
                dom.comboSizeSlider.addEventListener('input', (e) => { applyComboSize(e.target.value); saveSettings(); });
                dom.comboPositionSlider.addEventListener('input', (e) => { applyComboPositionY(e.target.value); saveSettings(); });
                dom.judgmentPositionSlider.addEventListener('input', (e) => { applyJudgmentPositionY(e.target.value); saveSettings(); });
                dom.keyCountSelector.addEventListener('change', (e) => { setKeyCount(e.target.value); saveSettings(); });
                initializeShortcutKeySetup('mania-shortcut-retry', 'mania-shortcut-menu');
            },
            togglePauseExternal: togglePause,
            retryGameExternal: function() { if (isGameRunning) retryGame(); },
            returnToControlsExternal: function() { if (isGameRunning) returnToControls(); }
        };
    })();

    // --- osu!taiko Game Logic (Scoped) ---
    const TaikoGame = (() => {
        const root = document.getElementById('taiko-wrapper');
        const dom = {
            appContainer: root.querySelector('#app-container'),
            gameContainer: root.querySelector('#taiko-game-container'),
            oszFileInput: root.querySelector('#taiko-osz-file'),
            oszFileLabel: root.querySelector('#osz-file-label'),
            beatmapSelectorContainer: root.querySelector('#taiko-beatmap-selector-container'),
            beatmapSelector: root.querySelector('#taiko-beatmap-selector'),
            songTitleElement: root.querySelector('#taiko-song-title'),
            songArtistElement: root.querySelector('#taiko-song-artist'),
            donSoundFileInput: root.querySelector('#don-sound-file'),
            katsuSoundFileInput: root.querySelector('#katsu-sound-file'),
            speedSlider: root.querySelector('#taiko-speed-slider'),
            speedLabel: root.querySelector('#taiko-speed-label'),
            offsetInput: root.querySelector('#taiko-offset-input'),
            individualOffsetInput: root.querySelector('#taiko-individual-offset-input'),
            videoOffsetInput: root.querySelector('#video-offset-input'),
            seOffsetInput: root.querySelector('#se-offset-input'),
            autoPlayCheckbox: root.querySelector('#taiko-auto-play-checkbox'),
            singleHandBigNoteCheckbox: root.querySelector('#single-hand-big-note-checkbox'),
            autoSeCheckbox: root.querySelector('#auto-se-checkbox'),
            keyConfigInputs: root.querySelector('#taiko-key-config-inputs'),
            startButton: root.querySelector('#taiko-start-button'),
            saveSongToPcButton: root.querySelector('#save-song-to-pc-button'),
            backgroundVideo: root.querySelector('#taiko-background-video'),
            backgroundImage: root.querySelector('#taiko-background-image'),
            playfield: root.querySelector('#taiko-playfield'),
            canvas: root.querySelector('#game-canvas'),
            ctx: root.querySelector('#game-canvas').getContext('2d'),
            scoreElement: root.querySelector('#taiko-score'),
            accuracyElement: root.querySelector('#taiko-accuracy'),
            comboElement: root.querySelector('#combo'),
            comboDisplay: root.querySelector('#combo-display'),
            rollCounterDisplay: root.querySelector('#roll-counter-display'),
            judgmentTextElement: root.querySelector('#taiko-judgment-text'),
            progressBar: root.querySelector('#progress-bar'),
            pauseOverlay: root.querySelector('#taiko-pause-overlay'),
            resumeButton: root.querySelector('#taiko-resume-button'),
            retryButton: root.querySelector('#taiko-retry-button'),
            backToTitlePause: root.querySelector('#back-to-title-button-pause'),
            backToTitleResults: root.querySelector('#back-to-title-button-results'),
            switchToManiaButton: root.querySelector('#switch-to-mania-button'),
            resultsOverlay: root.querySelector('#taiko-results-overlay'),
            resultsSongTitle: root.querySelector('#results-song-title'),
            resultsScoreValue: root.querySelector('#taiko-results-score-value'),
            resultsRankValue: root.querySelector('#results-rank-value'),
            resultsMaxComboValue: root.querySelector('#taiko-results-max-combo-value'),
            resultsRyoValue: root.querySelector('#results-ryo-value'),
            resultsKaValue: root.querySelector('#results-ka-value'),
            resultsFukaValue: root.querySelector('#results-fuka-value'),
            resultsRetryButton: root.querySelector('#taiko-results-retry-button'),
            audioPlayer: root.querySelector('#audio-player'),
            drumDonLeft: root.querySelector('#drum-don-left'),
            drumDonRight: root.querySelector('#drum-don-right'),
            drumKatsuLeft: root.querySelector('#drum-katsu-left'),
            drumKatsuRight: root.querySelector('#drum-katsu-right'),
            laneOpacitySlider: root.querySelector('#taiko-lane-opacity-slider'),
            laneOpacityLabel: root.querySelector('#taiko-lane-opacity-label'),
            bgBrightnessSlider: root.querySelector('#bg-brightness-slider'),
            bgBrightnessLabel: root.querySelector('#bg-brightness-label'),
            laneCoverSlider: root.querySelector('#lane-cover-slider'),
            laneCoverLabel: root.querySelector('#lane-cover-label'),
            backgroundSelectWrapper: root.querySelector('#background-select-wrapper'),
            backgroundSelect: root.querySelector('#background-select'),
            savedSongsList: root.querySelector('#saved-songs-list'),
            deleteSongButton: root.querySelector('#delete-song-button'),
            songSearchInput: root.querySelector('#song-search-input'),
            errorBar: root.querySelector('#taiko-error-bar'),
        };
        const db = { _db: null, DB_NAME: 'TaikoPlayerDB', STORE_NAME: 'songs', init() { return new Promise((resolve, reject) => { const request = indexedDB.open(this.DB_NAME, 1); request.onupgradeneeded = (event) => { const db = event.target.result; if (!db.objectStoreNames.contains(this.STORE_NAME)) { db.createObjectStore(this.STORE_NAME, { keyPath: 'id' }); } }; request.onsuccess = (event) => { this._db = event.target.result; resolve(); }; request.onerror = (event) => { console.error('Database error:', event.target.errorCode); reject(event.target.errorCode); }; }); }, addSong(songData) { return new Promise((resolve, reject) => { const transaction = this._db.transaction([this.STORE_NAME], 'readwrite'); const store = transaction.objectStore(this.STORE_NAME); const request = store.add(songData); request.onsuccess = () => resolve(); request.onerror = (event) => reject(event.target.error); }); }, getSongsMeta() { return new Promise((resolve, reject) => { const transaction = this._db.transaction([this.STORE_NAME], 'readonly'); const store = transaction.objectStore(this.STORE_NAME); const request = store.getAll(); request.onsuccess = (event) => { const songs = event.target.result.map(({ id, title, artist }) => ({ id, title, artist })); resolve(songs); }; request.onerror = (event) => reject(event.target.error); }); }, getSongBlob(id) { return new Promise((resolve, reject) => { const transaction = this._db.transaction([this.STORE_NAME], 'readonly'); const store = transaction.objectStore(this.STORE_NAME); const request = store.get(id); request.onsuccess = (event) => { if (event.target.result) { resolve(event.target.result.blob); } else { reject('Song not found'); } }; request.onerror = (event) => reject(event.target.error); }); }, deleteSong(id) { return new Promise((resolve, reject) => { const transaction = this._db.transaction([this.STORE_NAME], 'readwrite'); const store = transaction.objectStore(this.STORE_NAME); const request = store.delete(id); request.onsuccess = () => resolve(); request.onerror = (event) => reject(event.target.error); }); } };
        let KEYS = { don_left: 'D', don_right: 'K', katsu_left: 'S', katsu_right: 'L' };
        const BASE_SCROLL_SPEED = 6;
        let uiScrollSpeed = BASE_SCROLL_SPEED;
        const HIT_WINDOW_PERFECT = 25, HIT_WINDOW_GOOD = 70, HIT_WINDOW_BAD = 100;
        const EARLY_MISS_WINDOW = 100;
        const JUDGE_POINT_X = 390;
        let audioContext;
        let donSoundBuffer = null, katsuSoundBuffer = null;
        let fileContent = null, audioSrc = null;
        let songInfo = { title: '', artist: '', version: '', audioFilename: '' };
        let hitObjects = [], barLines = [], goGoSections = [];
        let audioLoaded = false, beatmapLoaded = false;
        let isGameRunning = false, isPaused = false, isAutoPlay = false, isAutoSE = false;
        let pausedTime = 0;
        let isSingleHandBigNoteEnabled = true;
        let score = 0, combo = 0, offset = 0, maxCombo = 0, accuracy = 100;
        let judgmentCounts = { ryo: 0, ka: 0, fuka: 0 };
        let animationFrameId = null;
        let lastNoteTime = 0;
        let gameStartTime = 0;
        let pauseStartTime = 0;
        let totalPauseDuration = 0;
        let selectedPauseIndex = 0;
        let pressedKeys = new Set();
        let osz_zip = null;
        let osz_beatmaps = [];
        let availableBackgrounds = { video: null, image: null };
        let selectedBackgroundType = 'none';
        let lastCheckedNoteIndex = 0;
        let lastAutoSEIndex = 0;
        let activeRollHits = 0;
        let rollCounterClearTime = 0;
        let isGoGoNow = false;
        let drumHitTimeouts = {};
        const SETTINGS_KEY = 'taikoPlayerSettings';
        let laneCoverPercentage = 0;
        let isPauseButtonCoolingDown = false;
        let isInitialCooldown = false;
        let autoPlayHitCounter = 0;
        let currentSongId = null;
        let playEndTime = 0;

        function initAudioContext() { if (!audioContext) { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); if (audioContext.state === 'suspended') { audioContext.resume(); } } catch (e) { console.error("Web Audio API is not supported in this browser"); } } document.body.removeEventListener('click', initAudioContext, true); document.body.removeEventListener('keydown', initAudioContext, true); }
        document.body.addEventListener('click', initAudioContext, true);
        document.body.addEventListener('keydown', initAudioContext, true);
        function saveSettings() { try { const settings = { offset: dom.offsetInput.value, videoOffset: dom.videoOffsetInput.value, seOffset: dom.seOffsetInput.value, keys: KEYS, autoPlay: dom.autoPlayCheckbox.checked, singleHandBigNote: dom.singleHandBigNoteCheckbox.checked, autoSE: dom.autoSeCheckbox.checked, laneOpacity: dom.laneOpacitySlider.value, bgBrightness: dom.bgBrightnessSlider.value, laneCover: dom.laneCoverSlider.value }; localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); } catch (e) { console.error("Failed to save settings:", e); } }
        function loadSettings() { const savedSettings = localStorage.getItem(SETTINGS_KEY); if (savedSettings) { try { const settings = JSON.parse(savedSettings); if (settings.offset !== undefined) dom.offsetInput.value = settings.offset; if (settings.videoOffset !== undefined) dom.videoOffsetInput.value = settings.videoOffset; if (settings.seOffset !== undefined) dom.seOffsetInput.value = settings.seOffset; if (settings.keys) { KEYS = settings.keys; for (const keyId in KEYS) { const elId = `key-${keyId.replace('_', '-')}`; const el = root.querySelector(`#${elId}`); if (el) el.textContent = KEYS[keyId]; } } if (settings.autoPlay !== undefined) dom.autoPlayCheckbox.checked = settings.autoPlay; if (settings.singleHandBigNote !== undefined) dom.singleHandBigNoteCheckbox.checked = settings.singleHandBigNote; if (settings.autoSE !== undefined) dom.autoSeCheckbox.checked = settings.autoSE; if (settings.laneOpacity !== undefined) dom.laneOpacitySlider.value = settings.laneOpacity; if (settings.bgBrightness !== undefined) dom.bgBrightnessSlider.value = settings.bgBrightness; if (settings.laneCover !== undefined) dom.laneCoverSlider.value = settings.laneCover; } catch (e) { console.error("Failed to load settings:", e); localStorage.removeItem(SETTINGS_KEY); } } }
        
        function getTaikoBeatmapSettingsKey() {
            if (currentSongId && songInfo && songInfo.version) {
                const sanitizedVersion = songInfo.version.replace(/[^a-zA-Z0-9-_]/g, '');
                return `taiko_${currentSongId}_${sanitizedVersion}`;
            }
            return null;
        }

        function saveTaikoBeatmapSpecificSettings() {
            const key = getTaikoBeatmapSettingsKey();
            if (!key) return;
            let settings = JSON.parse(localStorage.getItem('taikoPlayerBeatmapSettings')) || {};
            settings[key] = {
                individualOffset: dom.individualOffsetInput.value,
                speed: dom.speedSlider.value,
                backgroundChoice: dom.backgroundSelect.value
            };
            localStorage.setItem('taikoPlayerBeatmapSettings', JSON.stringify(settings));
        }

        function loadTaikoBeatmapSpecificSettings() {
            const key = getTaikoBeatmapSettingsKey();
            let individualOffset = 0;
            let speed = 0; // デフォルト値をスライダーの中央(x1.0)に
            let backgroundChoice = 'video';
            if (key) {
                const settings = JSON.parse(localStorage.getItem('taikoPlayerBeatmapSettings')) || {};
                const saved = settings[key];
                if (typeof saved === 'object' && saved !== null) {
                    individualOffset = saved.individualOffset || 0;
                    if (saved.speed !== undefined && saved.speed !== null) {
                        speed = saved.speed;
                    }
                    backgroundChoice = saved.backgroundChoice || 'video';
                }
            }
            dom.individualOffsetInput.value = individualOffset;
            dom.speedSlider.value = speed;
            updateSpeed();

            if (dom.backgroundSelectWrapper.style.display === 'block') {
                dom.backgroundSelect.value = backgroundChoice;
                selectedBackgroundType = backgroundChoice;
            }
        }
        
        function parseOsuFile(content) { try { hitObjects = []; barLines = []; goGoSections = []; songInfo = { title: '', artist: '', version: '', audioFilename: '' }; let uninheritedTimingPoints = []; let velocityChanges = []; const allTimingPoints = []; const lines = content.split('\n').map(l => l.trim()); let section = ''; let sliderMultiplier = 1.4; let gameMode = -1; for (const line of lines) { if (line.startsWith('[')) { section = line.toLowerCase(); continue; } if (!section) continue; const lowerLine = line.toLowerCase(); if (section === '[general]' && lowerLine.startsWith('mode:')) { gameMode = parseInt(line.split(':')[1].trim(), 10); } else if (section === '[general]' && lowerLine.startsWith('audiofilename:')) songInfo.audioFilename = line.substring(line.indexOf(':') + 1).trim(); else if (section === '[metadata]') { if (lowerLine.startsWith('title:')) songInfo.title = line.substring(line.indexOf(':') + 1).trim(); else if (lowerLine.startsWith('artist:')) songInfo.artist = line.substring(line.indexOf(':') + 1).trim(); else if (lowerLine.startsWith('version:')) songInfo.version = line.substring(line.indexOf(':') + 1).trim(); } else if (section === '[difficulty]') { if (lowerLine.startsWith('slidermultiplier:')) sliderMultiplier = parseFloat(line.split(':')[1]); } else if (section === '[timingpoints]') { const parts = line.split(','); if (parts.length < 2) continue; const time = parseFloat(parts[0]); const val = parseFloat(parts[1]); const meter = parts.length > 2 ? parseInt(parts[2], 10) : 4; const kiai = parts.length > 7 ? (parseInt(parts[7], 10) & 1) !== 0 : false; allTimingPoints.push({ time, kiai }); if (val > 0) { uninheritedTimingPoints.push({ time, beatLength: val, meter }); } else if (val < 0) { velocityChanges.push({ time, multiplier: -100 / val }); } } } if (gameMode !== 1) { console.warn(`Unsupported game mode detected: ${gameMode}. Only Taiko (mode 1) is supported.`); return false; } if (uninheritedTimingPoints.length === 0) uninheritedTimingPoints.push({time: 0, beatLength: 500, meter: 4}); velocityChanges.sort((a,b) => a.time - b.time); const getScrollMultiplier = (time) => { for (let i = velocityChanges.length - 1; i >= 0; i--) { if (velocityChanges[i].time <= time) return velocityChanges[i].multiplier; } return 1.0; }; section = ''; for (const line of lines) { if (line.startsWith('[')) { section = line.toLowerCase(); continue; } if (section !== '[hitobjects]') continue; const parts = line.split(','); if (parts.length < 5) continue; const time = parseInt(parts[2], 10), type = parseInt(parts[3], 10), hitSound = parseInt(parts[4], 10); const isBig = (hitSound & 4) !== 0; const scrollMultiplier = getScrollMultiplier(time); const noteProps = { time, judged: false, scrollSpeed: scrollMultiplier, sePlayed: false }; if (type & 2) { const parentTimingPoint = uninheritedTimingPoints.findLast(p => p.time <= time) || uninheritedTimingPoints[0]; const pixelLength = parseFloat(parts[7]); const duration = pixelLength / (sliderMultiplier * scrollMultiplier * 100) * parentTimingPoint.beatLength; hitObjects.push({ ...noteProps, type: 'roll', isBig, endTime: time + duration, lastAutoHitTime: 0, hitsMade: 0 }); } else if (type & 8) { const endTime = parseInt(parts[5], 10); const duration = endTime - time; const hitsRequired = Math.max(3, Math.ceil(duration / 200)); hitObjects.push({ ...noteProps, type: 'balloon', endTime, hitsRequired, hitsMade: 0, lastAutoHitTime: 0 }); } else if (type & 1) { let noteType = 'don'; if ((hitSound & 2) || (hitSound & 8)) noteType = 'katsu'; hitObjects.push({ ...noteProps, type: noteType, isBig }); } } allTimingPoints.sort((a,b) => a.time - b.time); let kiaiActive = false, kiaiStartTime = 0; const currentLastNoteTime = hitObjects.reduce((max, note) => Math.max(max, note.endTime || note.time), 0); for(const point of allTimingPoints) { if(point.kiai && !kiaiActive) { kiaiActive = true; kiaiStartTime = point.time; } else if (!point.kiai && kiaiActive) { kiaiActive = false; goGoSections.push({start: kiaiStartTime, end: point.time}); } } if(kiaiActive) goGoSections.push({start: kiaiStartTime, end: currentLastNoteTime + 5000}); if (uninheritedTimingPoints.length > 0 && hitObjects.length > 0) { for (let i = 0; i < uninheritedTimingPoints.length; i++) { const currentPoint = uninheritedTimingPoints[i]; const measureLength = currentPoint.beatLength * currentPoint.meter; if(measureLength <= 0) continue; const barEndTime = (i + 1 < uninheritedTimingPoints.length) ? uninheritedTimingPoints[i+1].time : currentLastNoteTime + 2000; for(let t = currentPoint.time; t < barEndTime; t += measureLength) { barLines.push({time: t, scrollSpeed: getScrollMultiplier(t)}); } } } hitObjects.sort((a, b) => a.time - b.time); lastNoteTime = hitObjects.length > 0 ? (hitObjects[hitObjects.length - 1].endTime || hitObjects[hitObjects.length - 1].time) : 1; return hitObjects.length > 0; } catch (error) { console.error("Error during .osu parsing:", error); alert("譜面の解析に失敗しました。"); return false; } }
        function setupFileListeners() {
            dom.oszFileInput.addEventListener('change', handleNewFiles);
            dom.oszFileLabel.addEventListener('click', () => { isRequestingFile = true; });
            dom.donSoundFileInput.addEventListener('change', e => { isRequestingFile = true; loadAndDecodeSound(e.target.files[0], true); });
            dom.katsuSoundFileInput.addEventListener('change', e => { isRequestingFile = true; loadAndDecodeSound(e.target.files[0], false); });
            dom.beatmapSelector.addEventListener('change', handleBeatmapSelection);
            dom.savedSongsList.addEventListener('change', handleSavedSongSelect);
            dom.deleteSongButton.addEventListener('click', handleDeleteSong);
            dom.songSearchInput.addEventListener('input', handleSongSearch);
        }
        async function loadSavedSongsList() { try { const songsMeta = await db.getSongsMeta(); dom.savedSongsList.innerHTML = '<option value="">-- 保存済み譜面を選択 --</option>'; songsMeta.sort((a,b) => `${a.artist} - ${a.title}`.localeCompare(`${b.artist} - ${b.title}`)).forEach(meta => { const option = document.createElement('option'); option.value = meta.id; option.textContent = `${meta.artist} - ${meta.title}`; dom.savedSongsList.appendChild(option); }); handleSongSearch(); } catch (e) { console.error('Failed to load saved songs list:', e); } }
        function handleSongSearch() { const searchTerm = dom.songSearchInput.value.toLowerCase(); for (const option of dom.savedSongsList.options) { if (option.value === "") continue; const songTitle = option.textContent.toLowerCase(); option.style.display = songTitle.includes(searchTerm) ? '' : 'none'; } }
        async function handleSavedSongSelect(e) { const songId = e.target.value; currentSongId = songId; dom.saveSongToPcButton.disabled = !songId; if (!songId) { resetGameAndFiles(false); return; } try { dom.beatmapSelectorContainer.style.display = 'none'; dom.songTitleElement.textContent = '読み込み中...'; const blob = await db.getSongBlob(songId); await processOszBlob(blob); } catch(e) { alert('保存済み譜面の読み込みに失敗しました。'); console.error(e); } }
        async function handleDeleteSong() { const songId = dom.savedSongsList.value; if (!songId) { alert('削除する譜面を選択してください。'); return; } if (confirm(`「${dom.savedSongsList.options[dom.savedSongsList.selectedIndex].text}」を削除しますか？`)) { try { await db.deleteSong(songId); await loadSavedSongsList(); resetGameAndFiles(true); alert('譜面を削除しました。'); } catch (e) { alert('譜面の削除に失敗しました。'); console.error(e); } } }
        function loadAndDecodeSound(file, isDon) { if (!file || !audioContext) return; const reader = new FileReader(); reader.onload = (e) => { const arrayBuffer = e.target.result; audioContext.decodeAudioData(arrayBuffer, (buffer) => { if (isDon) { donSoundBuffer = buffer; } else { katsuSoundBuffer = buffer; } }, (error) => { console.error(`Error decoding audio data for ${isDon ? 'Don' : 'Katsu'}:`, error); alert("サウンドファイルのデコードに失敗しました。"); }); }; reader.onerror = () => { alert("サウンドファイルの読み込みに失敗しました。"); }; reader.readAsArrayBuffer(file); }
        async function handleNewFiles(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            dom.oszFileLabel.classList.add('is-loading');
            dom.oszFileInput.disabled = true;
            let successCount = 0;
            let errorCount = 0;
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                dom.songTitleElement.textContent = `処理中 (${i + 1}/${files.length})...`;
                dom.songArtistElement.textContent = file.name;

                if (!file.name.toLowerCase().endsWith('.osz')) {
                    console.warn(`Skipping non-osz file: ${file.name}`);
                    errorCount++;
                    continue;
                }
                try {
                    const tempZip = new JSZip();
                    const loadedZip = await tempZip.loadAsync(file);
                    const osuFiles = [];
                    loadedZip.forEach((relativePath, zipEntry) => {
                        if (relativePath.toLowerCase().endsWith('.osu')) {
                            osuFiles.push(zipEntry);
                        }
                    });

                    if (osuFiles.length === 0) {
                        console.warn(`Skipping osz without .osu file: ${file.name}`);
                        errorCount++;
                        continue;
                    }

                    let firstTaikoOsuContent = null;
                    for (const osuFile of osuFiles) {
                         const content = await osuFile.async('string');
                         const lines = content.split('\n');
                         let isTaikoMode = false;
                         for(const line of lines) {
                             const trimmed = line.trim().toLowerCase();
                             if (trimmed.startsWith('mode:') && trimmed.includes('1')) {
                                 isTaikoMode = true;
                                 break;
                             }
                         }
                         if (isTaikoMode) {
                             firstTaikoOsuContent = content;
                             break;
                         }
                    }

                    if (!firstTaikoOsuContent) {
                        console.warn(`Skipping osz without Taiko-mode beatmap: ${file.name}`);
                        errorCount++;
                        continue;
                    }

                    const tempInfo = { title: 'Unknown', artist: 'Unknown' };
                    const lines = firstTaikoOsuContent.split('\n');
                    for (const line of lines) {
                        const trimmedLine = line.trim().toLowerCase();
                        if (trimmedLine.startsWith('title:')) tempInfo.title = line.substring(6).trim();
                        else if (trimmedLine.startsWith('artist:')) tempInfo.artist = line.substring(7).trim();
                    }
                    const songData = { id: `${Date.now()}-${file.name}`, title: tempInfo.title, artist: tempInfo.artist, blob: file };
                    await db.addSong(songData);
                    successCount++;
                } catch (err) {
                    console.error(`Failed to process file ${file.name}:`, err);
                    errorCount++;
                    if (err.name === 'QuotaExceededError') {
                        alert(`「${file.name}」の保存に失敗しました。\nブラウザの保存容量が上限に達した可能性があります。不要な譜面を削除して、再度お試しください。`);
                    }
                }
            }
            
            dom.songTitleElement.textContent = '譜面を選択してください';
            dom.songArtistElement.textContent = '';
            dom.oszFileLabel.classList.remove('is-loading');
            dom.oszFileInput.disabled = false;
            e.target.value = '';
            let message = `${successCount}個の譜面を保存しました。`;
            if (errorCount > 0) {
                message += `\n${errorCount}個の譜面は失敗しました。`;
            }
            if(successCount > 0 || errorCount > 0) {
               alert(message);
            }
            if (successCount > 0) {
                await loadSavedSongsList();
                resetGameAndFiles(true);
            }
        }
        async function processOszBlob(blob) {
            resetGameAndFiles(false);
            dom.songTitleElement.textContent = '読み込み中...';
            dom.songArtistElement.textContent = '';
            try {
                osz_zip = new JSZip();
                const zip = await osz_zip.loadAsync(blob);
                const filePromises = [];
                osz_beatmaps = [];
                const imageExtensions = ['.jpg', '.jpeg', '.png'];
                const videoExtensions = ['.mp4', '.avi', '.webm'];
                zip.forEach((relativePath, zipEntry) => {
                    const lowerCasePath = relativePath.toLowerCase();
                    if (lowerCasePath.endsWith('.osu')) {
                        filePromises.push(zipEntry.async('string').then(content => {
                            const lines = content.split('\n');
                            let isTaikoMode = false;
                            let inGeneralSection = false;
                            for (const line of lines) {
                                const trimmedLine = line.trim().toLowerCase();
                                if (trimmedLine === '[general]') {
                                    inGeneralSection = true;
                                    continue;
                                }
                                if (inGeneralSection && trimmedLine.startsWith('[')) {
                                    inGeneralSection = false;
                                    break;
                                }
                                if (inGeneralSection && trimmedLine.startsWith('mode:')) {
                                    if (trimmedLine.includes('1')) {
                                        isTaikoMode = true;
                                    }
                                    break;
                                }
                            }
                            if (isTaikoMode) {
                                const tempInfo = { title: '', artist: '', version: '', difficulty: 0 };
                                let currentSection = '';
                                for (const line of lines) {
                                    const trimmedLine = line.trim();
                                    if (trimmedLine.startsWith('[')) {
                                        currentSection = trimmedLine.toLowerCase();
                                        continue;
                                    }
                                    if (currentSection === '[metadata]') {
                                        if (trimmedLine.toLowerCase().startsWith('title:')) tempInfo.title = trimmedLine.substring(6).trim();
                                        else if (trimmedLine.toLowerCase().startsWith('artist:')) tempInfo.artist = trimmedLine.substring(7).trim();
                                        else if (trimmedLine.toLowerCase().startsWith('version:')) tempInfo.version = trimmedLine.substring(8).trim();
                                    } else if (currentSection === '[difficulty]') {
                                        if (trimmedLine.toLowerCase().startsWith('overalldifficulty:')) {
                                            tempInfo.difficulty = parseFloat(trimmedLine.split(':')[1].trim());
                                        }
                                    }
                                }
                                osz_beatmaps.push({ name: relativePath, content: content, info: tempInfo });
                            }
                        }));
                    } else if (videoExtensions.some(ext => lowerCasePath.endsWith(ext))) {
                        if (!availableBackgrounds.video) {
                            filePromises.push(zipEntry.async('blob').then(blob => {
                                availableBackgrounds.video = URL.createObjectURL(blob);
                            }));
                        }
                    } else if (imageExtensions.some(ext => lowerCasePath.endsWith(ext))) {
                        if (!availableBackgrounds.image) {
                            filePromises.push(zipEntry.async('blob').then(blob => {
                                availableBackgrounds.image = URL.createObjectURL(blob);
                            }));
                        }
                    }
                });
                await Promise.all(filePromises);
                updateBackgroundSelector();
                if (osz_beatmaps.length === 0) {
                    throw new Error('.osuファイルが見つかりませんでした (太鼓モードの譜面がありません)。');
                }
                dom.beatmapSelector.innerHTML = '<option value="">-- 難易度を選択 --</option>';
                osz_beatmaps.sort((a, b) => a.info.difficulty - b.info.difficulty);
                osz_beatmaps.forEach((osuFile, index) => {
                    const difficultyText = osuFile.info.difficulty ? ` (Lv.${osuFile.info.difficulty.toFixed(2)})` : '';
                    const optionText = `${osuFile.info.version || osuFile.name}${difficultyText}`;
                    const option = new Option(optionText, index);
                    dom.beatmapSelector.appendChild(option);
                });
                dom.beatmapSelectorContainer.style.display = 'block';
                dom.beatmapSelector.selectedIndex = 1;
                handleBeatmapSelection();
            } catch (err) {
                alert('譜面の処理に失敗しました: ' + err.message);
                console.error(err);
                resetGameAndFiles(false);
            }
        }
        async function handleBeatmapSelection() {
            const selectedIndex = dom.beatmapSelector.value;
            beatmapLoaded = false;
            audioLoaded = false;
            checkReadyState();

            if (selectedIndex === "") {
                dom.songTitleElement.textContent = '難易度を選択してください';
                dom.songArtistElement.textContent = '';
                return;
            }

            const selectedOsu = osz_beatmaps[parseInt(selectedIndex, 10)];
            if (!selectedOsu) return;

            fileContent = selectedOsu.content;

            if (parseOsuFile(fileContent)) {
                beatmapLoaded = true;
                dom.songTitleElement.textContent = songInfo.title || '（タイトル不明）';
                dom.songArtistElement.textContent = songInfo.artist || '（アーティスト不明）';

                loadTaikoBeatmapSpecificSettings();

                if (dom.backgroundSelectWrapper.style.display === 'block') {
                    if (availableBackgrounds.video) {
                        dom.backgroundSelect.value = 'video';
                    } else if (availableBackgrounds.image) {
                        dom.backgroundSelect.value = 'image';
                    }
                    selectedBackgroundType = dom.backgroundSelect.value;
                    saveTaikoBeatmapSpecificSettings();
                }

                if (osz_zip && songInfo.audioFilename) {
                    const targetAudioName = songInfo.audioFilename.replace(/\\/g, '/').toLowerCase();
                    const audioFileEntry = Object.values(osz_zip.files).find(file => !file.dir && file.name.replace(/\\/g, '/').toLowerCase().endsWith(targetAudioName));
                    if (audioFileEntry) {
                        try {
                            const audioBlob = await audioFileEntry.async('blob');
                            if (audioSrc) URL.revokeObjectURL(audioSrc);
                            audioSrc = URL.createObjectURL(audioBlob);
                            dom.audioPlayer.src = audioSrc;
                            audioLoaded = true;
                        } catch (e) {
                            alert(`音声ファイル "${songInfo.audioFilename}" の読み込みに失敗しました。`);
                        }
                    } else {
                        alert(`音声ファイル "${songInfo.audioFilename}" が見つかりません。`);
                    }
                }
            } else {
                beatmapLoaded = false;
                audioLoaded = false;
                dom.songTitleElement.textContent = '非対応の譜面です';
                dom.songArtistElement.textContent = '太鼓モードの難易度を選択してください';
                alert('この譜面は太鼓モードではありません。');
            }
            checkReadyState();
        }
        function resetGameAndFiles(fullReset = true) {
            resetGame();
            if (availableBackgrounds.video) URL.revokeObjectURL(availableBackgrounds.video);
            if (availableBackgrounds.image) URL.revokeObjectURL(availableBackgrounds.image);
            availableBackgrounds = { video: null, image: null };
            updateBackgroundSelector();
            dom.saveSongToPcButton.disabled = true;
            dom.individualOffsetInput.value = 0;
            if (fullReset) {
                fileContent = null;
                osz_zip = null;
                osz_beatmaps = [];
                beatmapLoaded = false;
                audioLoaded = false;
                dom.beatmapSelectorContainer.style.display = 'none';
                dom.beatmapSelector.innerHTML = '';
                dom.songTitleElement.textContent = '譜面を選択してください';
                dom.songArtistElement.textContent = '';
                dom.savedSongsList.value = '';
                currentSongId = null;
            }
            checkReadyState();
        }
        function checkReadyState() { dom.startButton.disabled = !(beatmapLoaded && audioLoaded); }
        function updateBackgroundSelector() { const selector = dom.backgroundSelect; const wrapper = dom.backgroundSelectWrapper; selector.innerHTML = ''; const addOption = (value, text) => { const option = document.createElement('option'); option.value = value; option.textContent = text; selector.appendChild(option); }; let hasOptions = false; if (availableBackgrounds.video || availableBackgrounds.image) { addOption('none', '背景なし'); if (availableBackgrounds.video) addOption('video', '動画'); if (availableBackgrounds.image) addOption('image', '画像'); hasOptions = true; } if (hasOptions) { wrapper.style.display = 'block'; if (availableBackgrounds.video) { selector.value = 'video'; selectedBackgroundType = 'video'; } else if (availableBackgrounds.image) { selector.value = 'image'; selectedBackgroundType = 'image'; } } else { wrapper.style.display = 'none'; selectedBackgroundType = 'none'; } }
        function updateSpeed() { const val = parseFloat(dom.speedSlider.value); const displayVal = (1.0 + val / 6.0).toFixed(1); dom.speedLabel.textContent = `スクロール速度 (x${displayVal})`; uiScrollSpeed = BASE_SCROLL_SPEED + val; if (uiScrollSpeed < 1) uiScrollSpeed = 1; }
        function updateLaneOpacity() { const opacity = dom.laneOpacitySlider.value; dom.laneOpacityLabel.textContent = `レーン不透明度 (${Math.round(opacity * 100)}%)`; dom.playfield.style.backgroundColor = `rgba(18, 18, 18, ${opacity})`; }
        function updateBgBrightness() { const brightness = dom.bgBrightnessSlider.value; dom.bgBrightnessLabel.textContent = `背景の明るさ (${Math.round(brightness * 100)}%)`; const filterValue = `brightness(${brightness})`; dom.backgroundVideo.style.filter = filterValue; dom.backgroundImage.style.filter = filterValue; }
        function updateLaneCover() { const value = dom.laneCoverSlider.value; laneCoverPercentage = parseInt(value, 10); dom.laneCoverLabel.textContent = `レーンカバー (${laneCoverPercentage}%)`; }
        function initKeyConfig() { dom.keyConfigInputs.querySelectorAll('.key-config-input').forEach(keyInput => { keyInput.addEventListener('click', e => { if (isGameRunning) return; root.querySelectorAll('.key-config-input.is-waiting').forEach(el => el.blur()); e.currentTarget.textContent = '...'; e.currentTarget.classList.add('is-waiting'); }); keyInput.addEventListener('blur', e => { const keyId = e.currentTarget.dataset.keyId; e.currentTarget.classList.remove('is-waiting'); e.currentTarget.textContent = KEYS[keyId]; saveSettings(); }); keyInput.addEventListener('keydown', e => { e.preventDefault(); const keyDiv = e.currentTarget; if (!keyDiv.classList.contains('is-waiting')) return; if (e.key === 'Escape') { keyDiv.blur(); return; } const newKey = e.key.toUpperCase(); if (newKey.length > 1 && !['SPACE', 'BACKSPACE', 'ENTER'].includes(newKey) ) return; const keyId = keyDiv.dataset.keyId; if (Object.values(KEYS).some((key, k_idx) => key === newKey && Object.keys(KEYS)[k_idx] !== keyId)) { alert('そのキーは他のアクションで既に使用されています。'); return; } KEYS[keyId] = newKey; keyDiv.blur(); }); }); }
        function initGameUI() { const rect = dom.playfield.getBoundingClientRect(); dom.canvas.width = rect.width; dom.canvas.height = rect.height; }
        function resetGame() {
            score = 0;
            combo = 0;
            maxCombo = 0;
            totalPauseDuration = 0;
            judgmentCounts = { ryo: 0, ka: 0, fuka: 0 };
            accuracy = 100;
            dom.scoreElement.textContent = score;
            dom.accuracyElement.textContent = `S 100.00%`;
             if (dom.errorBar) dom.errorBar.innerHTML = '';
            updateComboDisplay();
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            if (hitObjects && hitObjects.length > 0) {
                hitObjects.forEach(note => {
                    note.judged = false;
                    note.sePlayed = false;
                    if ('hitsMade' in note) {
                        note.hitsMade = 0;
                    }
                });
            }
            lastCheckedNoteIndex = 0;
            lastAutoSEIndex = 0;
            activeRollHits = 0;
            rollCounterClearTime = 0;
            isGoGoNow = false;
            pressedKeys.clear();
            autoPlayHitCounter = 0;
            dom.resultsOverlay.style.display = 'none';
            isGameRunning = false;
            isPaused = false;
            const canvas = root.querySelector('#taiko-gameplay-progress-pie');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }
        async function startGame() {
            if (isGameRunning || !beatmapLoaded || !audioLoaded) return;
            if (audioSrc && dom.audioPlayer.currentSrc !== audioSrc) {
                dom.audioPlayer.src = audioSrc;
            }
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            resetGame();
            dom.appContainer.style.display = 'none';
            dom.gameContainer.style.display = 'block';
            dom.gameContainer.classList.add('playing');
            initGameUI();
            dom.backgroundVideo.style.display = 'none';
            dom.backgroundImage.style.display = 'none';
            
            drawProgressPie('taiko-gameplay-progress-pie', 0);

            isAutoPlay = dom.autoPlayCheckbox.checked;
            isAutoSE = dom.autoSeCheckbox.checked;
            isSingleHandBigNoteEnabled = dom.singleHandBigNoteCheckbox.checked;
            const globalOffset = parseInt(dom.offsetInput.value, 10) || 0;
            const individualOffset = parseInt(dom.individualOffsetInput.value, 10) || 0;
            offset = 130;

            const audioReadyPromise = new Promise(resolve => {
                if (dom.audioPlayer.readyState >= 4) {
                    resolve();
                } else {
                    dom.audioPlayer.addEventListener('canplaythrough', resolve, { once: true });
                }
            });
            
            let videoReadyPromise = Promise.resolve();
            if (selectedBackgroundType === 'video' && availableBackgrounds.video) {
                videoReadyPromise = new Promise((resolve) => {
                    const videoEl = dom.backgroundVideo;
                    
                    const onSuccess = () => {
                        videoEl.removeEventListener('error', onError);
                        resolve();
                    };
                    const onError = () => {
                        videoEl.removeEventListener('loadeddata', onSuccess);
                        console.error("Video loading failed.");
                        resolve('video_error');
                    };
                    
                    videoEl.addEventListener('loadeddata', onSuccess, { once: true });
                    videoEl.addEventListener('error', onError, { once: true });

                    videoEl.src = availableBackgrounds.video;
                    videoEl.load(); 
                    videoEl.style.display = 'block';

                    if (videoEl.readyState >= 2) {
                        onSuccess();
                    }
                });
            } else if (selectedBackgroundType === 'image' && availableBackgrounds.image) {
                dom.backgroundImage.src = availableBackgrounds.image;
                dom.backgroundImage.style.display = 'block';
            }

            const loadResults = await Promise.all([audioReadyPromise, videoReadyPromise]);
            const videoResult = loadResults[1];

            if (videoResult === 'video_error') {
                alert("動画の読み込みに失敗しました。背景を画像（あれば）に切り替えます。");
                dom.backgroundVideo.style.display = 'none';
                if (availableBackgrounds.image) {
                    dom.backgroundImage.src = availableBackgrounds.image;
                    dom.backgroundImage.style.display = 'block';
                    selectedBackgroundType = 'image';
                    if (dom.backgroundSelect) dom.backgroundSelect.value = 'image';
                } else {
                    selectedBackgroundType = 'none';
                    if (dom.backgroundSelect) dom.backgroundSelect.value = 'none';
                }
            }

            isGameRunning = true;
            isPaused = false;
            
            const initialDelay = 3000;
            const videoOffsetMs = parseInt(dom.videoOffsetInput.value, 10) || 0;
            gameStartTime = performance.now() + initialDelay;
            totalPauseDuration = 0;
            dom.audioPlayer.currentTime = 0;
            let videoPlayDelay = 0;
            let audioPlayDelay = 0;
            if (selectedBackgroundType === 'video' && availableBackgrounds.video) {
                dom.backgroundVideo.currentTime = 0;
                if (videoOffsetMs > 0) {
                    videoPlayDelay = videoOffsetMs;
                } else {
                    audioPlayDelay = Math.abs(videoOffsetMs);
                    dom.backgroundVideo.currentTime = Math.abs(videoOffsetMs) / 1000;
                }
            }
            isInitialCooldown = true;
            setTimeout(() => {
                if (!isGameRunning || isPaused) return;
                setTimeout(() => {
                    if (isGameRunning && !isPaused) dom.audioPlayer.play();
                }, audioPlayDelay);
                if (selectedBackgroundType === 'video' && availableBackgrounds.video && videoResult !== 'video_error') {
                    setTimeout(() => {
                        if (isGameRunning && !isPaused) dom.backgroundVideo.play();
                    }, videoPlayDelay);
                }
                setTimeout(() => { isInitialCooldown = false; }, 500);
            }, initialDelay);
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        function getGameTime() { if(isPaused) return pauseStartTime - gameStartTime - totalPauseDuration; return performance.now() - gameStartTime - totalPauseDuration; }
        function updateLastCheckedNoteIndex() { while(hitObjects[lastCheckedNoteIndex] && hitObjects[lastCheckedNoteIndex].judged) { lastCheckedNoteIndex++; } }
        
        function drawCapsule(ctx, x1, x2, y, radius, color) {
            if (x1 > x2) [x1, x2] = [x2, x1]; 
            ctx.beginPath();
            ctx.arc(x1, y, radius, Math.PI / 2, -Math.PI / 2);
            ctx.arc(x2, y, radius, -Math.PI / 2, Math.PI / 2);
            ctx.closePath();
            if (color) {
                ctx.fillStyle = color;
                ctx.fill();
            }
        }

        function gameLoop() {
            if (!isGameRunning) return;
            animationFrameId = requestAnimationFrame(gameLoop);
            if (isPaused) return;
            const elapsedTime = getGameTime() - offset;
            isGoGoNow = false;
            for (const section of goGoSections) {
                if (elapsedTime >= section.start && elapsedTime < section.end) {
                    isGoGoNow = true;
                    break;
                }
            }
            dom.ctx.clearRect(0, 0, dom.canvas.width, dom.canvas.height);
            
            drawJudgmentFrame();
            if (isGoGoNow) {
                drawGameArea(true);
            }

            if (laneCoverPercentage > 0) {
                const visibleWidth = dom.canvas.width * (1 - laneCoverPercentage / 100);
                dom.ctx.save();
                dom.ctx.beginPath();
                dom.ctx.rect(0, 0, visibleWidth, dom.canvas.height);
                dom.ctx.clip();
            }

            drawBarLines(elapsedTime);
            drawNotes(elapsedTime);

            if (laneCoverPercentage > 0) {
                dom.ctx.restore();
            }

            drawRollCounter(elapsedTime);
            if (isAutoPlay) {
                autoPlayHandler(elapsedTime);
            } else {
                checkMisses(elapsedTime);
                if (isAutoSE) {
                    autoSEHandler(elapsedTime);
                }
            }
            updateLastCheckedNoteIndex();
            const progress = Math.min(1, elapsedTime / lastNoteTime);
            drawProgressPie('taiko-gameplay-progress-pie', progress);
            if (progress >= 1 && elapsedTime > lastNoteTime + 3000) {
                showResults();
            }
        }

        function drawJudgmentFrame() {
            const y = dom.canvas.height / 2;
            const ctx = dom.ctx;
            const normalNoteRadius = (dom.canvas.height / 2) * 0.41;
            const bigNoteRadius = (dom.canvas.height / 2) * 0.65;
            const centerCircleRadius = (dom.canvas.height / 2) * 0.35;

            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(JUDGE_POINT_X, y, bigNoteRadius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = '#CCCCCC';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(JUDGE_POINT_X, y, normalNoteRadius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.fillStyle = '#777777';
            ctx.beginPath();
            ctx.arc(JUDGE_POINT_X, y, centerCircleRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawGameArea(isGoGo) {
            if (isGoGo) {
                const fireGradient = dom.ctx.createLinearGradient(0, 0, 0, dom.canvas.height);
                fireGradient.addColorStop(0, "rgba(255, 100, 0, 0.3)");
                fireGradient.addColorStop(0.5, "rgba(255, 69, 0, 0.2)");
                fireGradient.addColorStop(1, "rgba(255, 100, 0, 0.3)");
                dom.ctx.fillStyle = fireGradient;
                dom.ctx.fillRect(0, 0, dom.canvas.width, dom.canvas.height);
            }
        }
        function drawBarLines(elapsedTime) {
            const pixelMultiplier = uiScrollSpeed * 0.1;
            dom.ctx.strokeStyle = '#FFFFFF';
            dom.ctx.lineWidth = 2;
            dom.ctx.globalAlpha = 0.5;
            barLines.forEach(line => {
                const timeToJudge = line.time - elapsedTime;
                const x = JUDGE_POINT_X + timeToJudge * line.scrollSpeed * pixelMultiplier;
                if (x < JUDGE_POINT_X - 50) return;
                dom.ctx.beginPath();
                dom.ctx.moveTo(x, 0);
                dom.ctx.lineTo(x, dom.canvas.height);
                dom.ctx.stroke();
            });
            dom.ctx.globalAlpha = 1.0;
        }
        
        function drawNotes(elapsedTime) {
            const y = dom.canvas.height / 2;
            const pixelMultiplier = uiScrollSpeed * 0.1;
            const BEIGE_RING = '#F0EAD6';
            const BLACK_BORDER = '#000000';

            for (let i = hitObjects.length - 1; i >= 0; i--) {
                const note = hitObjects[i];

                if (note.judged) continue;
                const timeToJudge = note.time - elapsedTime;
                const startX = JUDGE_POINT_X + timeToJudge * note.scrollSpeed * pixelMultiplier;

                if (note.type === 'roll') {
                    const timeToEnd = note.endTime - elapsedTime;
                    const endX = JUDGE_POINT_X + timeToEnd * note.scrollSpeed * pixelMultiplier;
                    if (endX < JUDGE_POINT_X - 50 || startX > dom.canvas.width + 50) continue;

                    const barHeight = note.isBig ? y * 0.8 : y * 0.8;
                    const headRadius = barHeight / 2;

                    // ▼▼▼ ここを変更 ▼▼▼
                    // 棒の太さを調整するためのスケール（倍率）
                    const BAR_THICKNESS_SCALE = 1.046; // ← この数値を 1.0 に変更（またはそれ以上）

                    const barRadius = headRadius * BAR_THICKNESS_SCALE;
                    
                    const BLACK_BORDER_THICKNESS = 2;
                    const WHITE_BORDER_THICKNESS = 6;

                    // 長い棒（カプセル）部分の描画
                    drawCapsule(dom.ctx, startX, endX, y, barRadius, BLACK_BORDER);
                    drawCapsule(dom.ctx, startX, endX, y, barRadius - BLACK_BORDER_THICKNESS, BEIGE_RING);
                    drawCapsule(dom.ctx, startX, endX, y, barRadius - BLACK_BORDER_THICKNESS - WHITE_BORDER_THICKNESS, '#FFC700');

                    // 先頭の丸い部分の描画
                    dom.ctx.fillStyle = BLACK_BORDER;
                    dom.ctx.beginPath();
                    dom.ctx.arc(startX, y, headRadius, 0, Math.PI * 2);
                    dom.ctx.fill();

                    dom.ctx.fillStyle = BEIGE_RING;
                    dom.ctx.beginPath();
                    dom.ctx.arc(startX, y, headRadius - BLACK_BORDER_THICKNESS, 0, Math.PI * 2);
                    dom.ctx.fill();

                    dom.ctx.fillStyle = '#FFC700';
                    dom.ctx.beginPath();
                    dom.ctx.arc(startX, y, headRadius - BLACK_BORDER_THICKNESS - WHITE_BORDER_THICKNESS, 0, Math.PI * 2);
                    dom.ctx.fill();
                

                } else if (note.type === 'balloon') {
                     const timeToEnd = note.endTime - elapsedTime;
                    const endX = JUDGE_POINT_X + timeToEnd * note.scrollSpeed * pixelMultiplier;
                    
                    const radius = y * 0.45; 
                    let currentX = startX;
                    if (startX < JUDGE_POINT_X && endX > JUDGE_POINT_X) {
                        currentX = JUDGE_POINT_X;
                    }
                    if (currentX < -radius) continue;

                    const BLACK_BORDER_THICKNESS = 2;
                    const WHITE_BORDER_THICKNESS = 6;
                    const ORANGE_FILL = '#F98025';

                    dom.ctx.fillStyle = BLACK_BORDER;
                    dom.ctx.beginPath();
                    dom.ctx.arc(currentX, y, radius, 0, Math.PI * 2);
                    dom.ctx.fill();

                    dom.ctx.fillStyle = BEIGE_RING;
                    dom.ctx.beginPath();
                    dom.ctx.arc(currentX, y, radius - BLACK_BORDER_THICKNESS, 0, Math.PI * 2);
                    dom.ctx.fill();

                    dom.ctx.fillStyle = ORANGE_FILL;
                    dom.ctx.beginPath();
                    dom.ctx.arc(currentX, y, radius - BLACK_BORDER_THICKNESS - WHITE_BORDER_THICKNESS, 0, Math.PI * 2);
                    dom.ctx.fill();
                    
                    const remainingHits = note.hitsRequired - note.hitsMade;
                    if (remainingHits > 0) {
                        dom.ctx.fillStyle = '#fff';
                        dom.ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                        dom.ctx.lineWidth = 4;
                        dom.ctx.font = `bold ${radius}px sans-serif`;
                        dom.ctx.textAlign = 'center';
                        dom.ctx.textBaseline = 'middle';
                        dom.ctx.strokeText(remainingHits, currentX, y);
                        dom.ctx.fillText(remainingHits, currentX, y);
                    }

                } else { 
                    if (startX > dom.canvas.width + 50 || startX < JUDGE_POINT_X - 50) continue;
                    
                    const color = note.type === 'don' ? '#F83838' : '#46B6B6';
                    const baseRadius = note.isBig ? y * 0.65 : y * 0.42;
                    
                    const BLACK_BORDER_THICKNESS = 2;
                    const WHITE_BORDER_THICKNESS = 6;

                    dom.ctx.fillStyle = BLACK_BORDER;
                    dom.ctx.beginPath();
                    dom.ctx.arc(startX, y, baseRadius, 0, Math.PI * 2);
                    dom.ctx.fill();

                    dom.ctx.fillStyle = BEIGE_RING;
                    dom.ctx.beginPath();
                    dom.ctx.arc(startX, y, baseRadius - BLACK_BORDER_THICKNESS, 0, Math.PI * 2);
                    dom.ctx.fill();

                    dom.ctx.fillStyle = color;
                    dom.ctx.beginPath();
                    dom.ctx.arc(startX, y, baseRadius - BLACK_BORDER_THICKNESS - WHITE_BORDER_THICKNESS, 0, Math.PI * 2);
                    dom.ctx.fill();
                }
            }
        }
        function drawRollCounter(elapsedTime) { if (rollCounterClearTime > 0 && elapsedTime >= rollCounterClearTime) { activeRollHits = 0; rollCounterClearTime = 0; } if (activeRollHits > 0) { dom.rollCounterDisplay.textContent = activeRollHits; dom.rollCounterDisplay.classList.add('visible'); } else { dom.rollCounterDisplay.classList.remove('visible'); } }
        
        function playHitSound(type, offset = 0) { if (!audioContext) return; const buffer = (type === 'don') ? donSoundBuffer : katsuSoundBuffer; if (!buffer) return; const source = audioContext.createBufferSource(); source.buffer = buffer; source.connect(audioContext.destination); const offsetInSeconds = offset / 1000; let playTime = audioContext.currentTime; let playOffset = 0; if (offsetInSeconds >= 0) { playTime += offsetInSeconds; } else { playOffset = -offsetInSeconds; } if (playOffset < buffer.duration) { source.start(playTime, playOffset); } }
        function autoSEHandler(elapsedTime) { for (let i = lastAutoSEIndex; i < hitObjects.length; i++) { const note = hitObjects[i]; if (note.sePlayed) continue; if (elapsedTime >= note.time) { if (note.type === 'don' || note.type === 'katsu') { playHitSound(note.type); note.sePlayed = true; } } else { break; } } while(hitObjects[lastAutoSEIndex] && hitObjects[lastAutoSEIndex].sePlayed) { lastAutoSEIndex++; } }
        function showHitError(diff) {
            if (!dom.errorBar) return;
            const tick = document.createElement('div');
            tick.className = 'error-tick';
            const percentage = (diff + HIT_WINDOW_BAD) / (HIT_WINDOW_BAD * 2) * 100;
            tick.style.left = `${Math.max(0, Math.min(100, percentage))}%`;
            dom.errorBar.appendChild(tick);
            setTimeout(() => {
                if (tick.parentNode) {
                    tick.remove();
                }
            }, 1500);
        }
        function autoPlayHandler(elapsedTime) { const AUTO_HIT_INTERVAL = 25; for (const note of hitObjects) { if (note.judged) continue; if (note.type === 'balloon' || note.type === 'roll') { if (elapsedTime >= note.time && elapsedTime <= note.endTime) { if (elapsedTime - (note.lastAutoHitTime || 0) > AUTO_HIT_INTERVAL) { playHitSound('don'); const hitSide = autoPlayHitCounter % 2 === 0 ? 'don_right' : 'don_left'; showDrumHit(hitSide); autoPlayHitCounter++; let hitScore = 100; if (isGoGoNow) hitScore *= 1.2; score += hitScore; note.hitsMade++; if (note.type === 'roll') { activeRollHits = note.hitsMade; rollCounterClearTime = 0; } else if (note.type === 'balloon' && note.hitsMade >= note.hitsRequired) { let burstBonus = 5000; if (isGoGoNow) burstBonus *= 1.2; score += burstBonus; note.judged = true; } dom.scoreElement.textContent = Math.floor(score); note.lastAutoHitTime = elapsedTime; } } if (elapsedTime > note.endTime && !note.judged) { if (note.type === 'roll' && note.hitsMade > 0) rollCounterClearTime = elapsedTime + 2000; note.judged = true; } } else if (elapsedTime >= note.time) { playHitSound(note.type); const isBigNoteTwoHands = note.isBig && !isSingleHandBigNoteEnabled; if (note.type === 'don') { if (isBigNoteTwoHands) { showDrumHit('don_left'); showDrumHit('don_right'); } else { const hitSide = autoPlayHitCounter % 2 === 0 ? 'don_right' : 'don_left'; showDrumHit(hitSide); } } else if (note.type === 'katsu') { if (isBigNoteTwoHands) { showDrumHit('katsu_left'); showDrumHit('katsu_right'); } else { const hitSide = autoPlayHitCounter % 2 === 0 ? 'katsu_right' : 'katsu_left'; showDrumHit(hitSide); } } autoPlayHitCounter++; handleJudgment('ryo', note, 0); } } }
        function showDrumHit(keyId) { const hitMap = { don_left: dom.drumDonLeft, don_right: dom.drumDonRight, katsu_left: dom.drumKatsuLeft, katsu_right: dom.drumKatsuRight, }; const element = hitMap[keyId]; if (!element) return; if (drumHitTimeouts[keyId]) { clearTimeout(drumHitTimeouts[keyId]); } element.classList.add('active'); drumHitTimeouts[keyId] = setTimeout(() => { element.classList.remove('active'); }, 50); }
        
        function handleKeydown(e) {
            if (activeGame !== 'taiko' || e.repeat || !isGameRunning || isPaused || isAutoPlay) return;
            
            e.preventDefault();

            const key = e.key.toUpperCase();
            let hitKeyId = null;
            for (const id in KEYS) {
                if (KEYS[id] === key) {
                    hitKeyId = id;
                    break;
                }
            }
            if (!hitKeyId) return;

            pressedKeys.add(key);
            const keyType = hitKeyId.startsWith('don') ? 'don' : 'katsu';
            showDrumHit(hitKeyId);
            const seOffset = parseInt(dom.seOffsetInput.value, 10) || 0;
            const elapsedTime = (getGameTime() - offset) + seOffset;
            if (elapsedTime < -500) return;

             let activeLongNote = null;
            for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) {
                const note = hitObjects[i];
                if (note.judged) continue;
                if (elapsedTime >= note.time && elapsedTime <= note.endTime + HIT_WINDOW_BAD) {
                    if (note.type === 'roll' || note.type === 'balloon') {
                        activeLongNote = note;
                        break;
                    }
                }
                if (note.time > elapsedTime + 200) break;
            }

            if (activeLongNote) {
                if (activeLongNote.type === 'roll') {
                    playHitSound(keyType);
                    let scoreToAdd = activeLongNote.isBig ? 200 : 100;
                    if (isGoGoNow) scoreToAdd *= 1.2;
                    score += scoreToAdd;
                    activeLongNote.hitsMade++;
                    activeRollHits = activeLongNote.hitsMade;
                    rollCounterClearTime = 0;
                    dom.scoreElement.textContent = Math.floor(score);
                } else if (activeLongNote.type === 'balloon') {
                    if (keyType === 'don') {
                        playHitSound('don');
                        let scoreToAdd = 300;
                        if (isGoGoNow) scoreToAdd *= 1.2;
                        score += scoreToAdd;
                        activeLongNote.hitsMade++;
                        if (activeLongNote.hitsMade >= activeLongNote.hitsRequired) {
                            let balloonBurstBonus = 5000;
                            if (isGoGoNow) balloonBurstBonus *= 1.2;
                            score += balloonBurstBonus;
                            activeLongNote.judged = true;
                        }
                        dom.scoreElement.textContent = Math.floor(score);
                    } else {
                        if (!isAutoSE) playHitSound('katsu');
                    }
                }
                return;
            }
            
            let potentialNote = null;
            let minTimeDiff = Infinity;

            for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) {
                const note = hitObjects[i];
                if (note.judged || note.type === 'balloon' || note.type === 'roll') continue;
                if (note.type !== keyType) continue;

                const timeDiff = Math.abs(note.time - elapsedTime);
                
                if (timeDiff < EARLY_MISS_WINDOW) {
                    if (timeDiff < minTimeDiff) {
                        minTimeDiff = timeDiff;
                        potentialNote = note;
                    }
                }
                
                if (note.time > elapsedTime + EARLY_MISS_WINDOW + 100) break;
            }

            if (potentialNote) {
                const actualTimeDiff = elapsedTime - potentialNote.time;

                if (!potentialNote.sePlayed) {
                    playHitSound(keyType);
                }

                if (Math.abs(actualTimeDiff) <= HIT_WINDOW_PERFECT) {
                    handleJudgment('ryo', potentialNote, actualTimeDiff);
                } else if (Math.abs(actualTimeDiff) <= HIT_WINDOW_GOOD) {
                    handleJudgment('ka', potentialNote, actualTimeDiff);
                } else if (actualTimeDiff < 0) {
                    handleJudgment('fuka', potentialNote);
                }
            } else {
                if (!isAutoSE) {
                    playHitSound(keyType);
                }
            }
        }
        document.addEventListener('keydown', handleKeydown);
        document.addEventListener('keyup', e => { 
            if (activeGame !== 'taiko') return;
            pressedKeys.delete(e.key.toUpperCase());
        });

        function checkMisses(elapsedTime) { for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) { const note = hitObjects[i]; if (note.judged) { continue; } if (note.time > elapsedTime + HIT_WINDOW_BAD) break; if (note.type !== 'balloon' && note.type !== 'roll') { if (elapsedTime > note.time + HIT_WINDOW_BAD) { handleJudgment('fuka', note); } } else { if (elapsedTime > note.endTime) { if (note.type === 'roll' && note.hitsMade > 0) rollCounterClearTime = elapsedTime + 2000; note.judged = true; } } } }
        function handleJudgment(judgement, note, diff = null) {
            if(note.judged) return;
            note.judged = true;
            note.sePlayed = true;
            if (diff !== null) {
                showHitError(diff);
            }
            const judgmentMap = { ryo: '良', ka: '可', fuka: '不可'};
            showJudgment(judgmentMap[judgement]);
            judgmentCounts[judgement]++;
            if(judgement === 'ryo' || judgement === 'ka') {
                const basePoints = judgement === 'ryo' ? 300 : 100;
                let scoreMultiplier = 1;
                if(note.isBig) {
                    if (isSingleHandBigNoteEnabled) {
                        scoreMultiplier = 2;
                    } else {
                        const isDonHit = note.type === 'don' && pressedKeys.has(KEYS.don_left) && pressedKeys.has(KEYS.don_right);
                        const isKatsuHit = note.type === 'katsu' && pressedKeys.has(KEYS.katsu_left) && pressedKeys.has(KEYS.katsu_right);
                        if (isDonHit || isKatsuHit) scoreMultiplier = 2;
                    }
                }
                updateScore(basePoints * scoreMultiplier);
                updateCombo(true);
            } else {
                updateCombo(false);
            }
            updateAccuracy();
        }
        function updateScore(points) { let currentPoints = points + (points * Math.floor(combo / 10) * 0.1); if(isGoGoNow) { currentPoints *= 1.2; } score += currentPoints; dom.scoreElement.textContent = Math.floor(score); }
        function updateCombo(hit) { if (hit) { combo++; if (combo > maxCombo) maxCombo = combo; } else { combo = 0; } updateComboDisplay(); }
        function updateAccuracy() { const totalHits = judgmentCounts.ryo + judgmentCounts.ka + judgmentCounts.fuka; if (totalHits === 0) { accuracy = 100; } else { const accVal = (judgmentCounts.ryo * 300 + judgmentCounts.ka * 150) / (totalHits * 300); accuracy = accVal * 100; } let rank = 'S'; if (accuracy < 100) rank = 'S'; if (accuracy < 95) rank = 'A'; if (accuracy < 90) rank = 'B'; if (accuracy < 80) rank = 'C'; if (accuracy < 70) rank = 'D'; dom.accuracyElement.textContent = `${rank} ${accuracy.toFixed(2)}%`; }
        function showJudgment(text) { const el = dom.judgmentTextElement; const judgmentStyles = { "良": 'gold', "可": 'white', "不可": '#dda0dd' }; el.textContent = text; el.style.color = judgmentStyles[text] || 'white'; el.style.animation = 'none'; void el.offsetHeight; el.style.animation = null; }
        function updateComboDisplay() { if (combo > 0) { dom.comboElement.textContent = combo; dom.comboDisplay.classList.add('visible'); } else { dom.comboDisplay.classList.remove('visible'); } }
        function updatePauseSelection() { const buttons = dom.pauseOverlay.querySelectorAll('.overlay-button'); buttons.forEach((btn, index) => { btn.classList.toggle('selected', index === selectedPauseIndex); }); }
        
        function togglePause() { 
            if (isInitialCooldown || !isGameRunning || isPauseButtonCoolingDown) return; 
            isPauseButtonCoolingDown = true; setTimeout(() => { isPauseButtonCoolingDown = false; }, 500); 
            isPaused = !isPaused; 
            if (isPaused) { 
                pauseStartTime = performance.now(); 
                pausedTime = dom.audioPlayer.currentTime;
                dom.audioPlayer.pause(); 
                if (selectedBackgroundType === 'video' && availableBackgrounds.video) dom.backgroundVideo.pause(); 
                dom.gameContainer.classList.remove('playing'); 
                cancelAnimationFrame(animationFrameId); 
                dom.pauseOverlay.style.display = 'flex'; 
                selectedPauseIndex = 0; 
                updatePauseSelection(); 
            } else { 
                totalPauseDuration += performance.now() - pauseStartTime; 
                dom.audioPlayer.currentTime = pausedTime;
                dom.audioPlayer.play(); 
                if (selectedBackgroundType === 'video' && availableBackgrounds.video) dom.backgroundVideo.play(); 
                dom.gameContainer.classList.add('playing'); 
                animationFrameId = requestAnimationFrame(gameLoop); 
                dom.pauseOverlay.style.display = 'none'; 
            } 
        }

        document.addEventListener('keydown', e => {
            if (activeGame === 'taiko') {
                if (isPaused) {
                    const buttons = dom.pauseOverlay.querySelectorAll('.overlay-button');
                    if (buttons.length === 0) return;

                    // キー入力のハンドリングをswitch文に変更して可読性を向上
                    switch (e.key) {
                        case 'ArrowUp':
                            e.preventDefault();
                            selectedPauseIndex = (selectedPauseIndex - 1 + buttons.length) % buttons.length;
                            updatePauseSelection();
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            selectedPauseIndex = (selectedPauseIndex + 1) % buttons.length;
                            updatePauseSelection();
                            break;
                        case 'Enter':
                            e.preventDefault();
                            buttons[selectedPauseIndex].click();
                            break;
                        // ▼▼▼ この部分を追加 ▼▼▼
                        case 'ArrowLeft':
                        case 'ArrowRight':
                            e.preventDefault(); // 左右キーのデフォルト動作をキャンセルしてUIのずれを防ぐ
                            break;
                        // ▲▲▲ 追加部分ここまで ▲▲▲
                    }
                } else if (isGameRunning && e.code === 'Space') {
                    e.preventDefault();
                } else if (!isGameRunning && e.code === 'Space' && !dom.startButton.disabled) {
                    e.preventDefault();
                    startGame();
                } else if (!isGameRunning && e.key.toUpperCase() === '' && !isTyping) {
                    e.preventDefault();
                    switchToMania();
                }
            }
        });

        function retryGame() { 
            isGameRunning = false; 
            if(animationFrameId) cancelAnimationFrame(animationFrameId); 
            dom.audioPlayer.pause(); 
            dom.audioPlayer.load();
            if (selectedBackgroundType === 'video' && dom.backgroundVideo) dom.backgroundVideo.pause(); 
            dom.pauseOverlay.style.display = 'none'; 
            dom.resultsOverlay.style.display = 'none'; 
            if (beatmapLoaded && audioLoaded) { 
                startGame(); 
            } else { 
                returnToControls(); 
            } 
        }
        function returnToControls() {
            isGameRunning = false;
            isPaused = false;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            if (dom.audioPlayer) {
                dom.audioPlayer.pause();
                dom.audioPlayer.currentTime = 0;
            }
            if (selectedBackgroundType === 'video' && dom.backgroundVideo) {
                dom.backgroundVideo.pause();
		dom.backgroundVideo.load();
                dom.backgroundVideo.currentTime = 0;
            }
            dom.pauseOverlay.style.display = 'none';
            dom.resultsOverlay.style.display = 'none';
            dom.gameContainer.classList.remove('playing');
            dom.gameContainer.style.display = 'none';
            dom.appContainer.style.display = 'flex';
            resetGame();
        }
        function showResults() { 
            if(!isGameRunning && dom.resultsOverlay.style.display === 'flex') return;
            playEndTime = getGameTime();
            isGameRunning = false; 
            cancelAnimationFrame(animationFrameId); 
            dom.gameContainer.classList.remove('playing'); 
            const totalHits = judgmentCounts.ryo + judgmentCounts.ka + judgmentCounts.fuka; 
            let finalAccuracy = 100; 
            if (totalHits > 0) { const accVal = (judgmentCounts.ryo * 300 + judgmentCounts.ka * 150) / (totalHits * 300); finalAccuracy = accVal * 100; } 
            let rank = 'S'; 
            if (finalAccuracy < 95) rank = 'A'; 
            if (finalAccuracy < 90) rank = 'B'; 
            if (finalAccuracy < 80) rank = 'C'; 
            if (finalAccuracy < 70) rank = 'D'; 
            dom.resultsSongTitle.textContent = `${songInfo.title} - ${songInfo.version}`; 
            dom.resultsScoreValue.textContent = Math.floor(score); 
            dom.resultsRankValue.textContent = rank; 
            dom.resultsMaxComboValue.textContent = maxCombo; 
            dom.resultsRyoValue.textContent = judgmentCounts.ryo; 
            dom.resultsKaValue.textContent = judgmentCounts.ka; 
            dom.resultsFukaValue.textContent = judgmentCounts.fuka; 

            dom.resultsOverlay.style.display = 'flex'; 
            if (selectedBackgroundType === 'video') dom.backgroundVideo.pause(); 
        }
        async function saveSongToPc() {
            const songId = dom.savedSongsList.value;
            if (!songId) {
                alert('PCに保存する譜面を「保存済み譜面」から選択してください。');
                return;
            }
            dom.saveSongToPcButton.textContent = '準備中...';
            dom.saveSongToPcButton.disabled = true;
            try {
                const blob = await db.getSongBlob(songId);
                if (!blob) throw new Error('Blob data not found in DB.');

                const fileName = songId.substring(songId.indexOf('-') + 1);

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (err) {
                alert('ファイルの保存に失敗しました。');
                console.error('Failed to save .osz file from Taiko player:', err);
            } finally {
                dom.saveSongToPcButton.textContent = 'PCへ保存';
                dom.saveSongToPcButton.disabled = !dom.savedSongsList.value;
            }
        }

        return {
            initialize: async function() {
                initKeyConfig();
                setupFileListeners();
                loadSettings();
                updateLaneOpacity();
                updateBgBrightness();
                updateLaneCover();
                dom.startButton.addEventListener('click', startGame);
                dom.speedSlider.addEventListener('input', () => {
                    updateSpeed();
                    saveTaikoBeatmapSpecificSettings();
                });
                dom.offsetInput.addEventListener('change', saveSettings);
                dom.videoOffsetInput.addEventListener('change', saveSettings);
                dom.seOffsetInput.addEventListener('change', saveSettings);
                dom.autoPlayCheckbox.addEventListener('change', saveSettings);
                dom.singleHandBigNoteCheckbox.addEventListener('change', saveSettings);
                dom.autoSeCheckbox.addEventListener('change', saveSettings);
                dom.individualOffsetInput.addEventListener('change', saveTaikoBeatmapSpecificSettings);
                dom.saveSongToPcButton.addEventListener('click', saveSongToPc);
                dom.resumeButton.addEventListener('click', togglePause);
                dom.retryButton.addEventListener('click', retryGame);
                dom.backToTitlePause.addEventListener('click', returnToControls);
                dom.resultsRetryButton.addEventListener('click', retryGame);
                dom.backToTitleResults.addEventListener('click', returnToControls);
                dom.switchToManiaButton.addEventListener('click', switchToMania);
                dom.laneOpacitySlider.addEventListener('input', () => { updateLaneOpacity(); saveSettings(); });
                dom.bgBrightnessSlider.addEventListener('input', () => { updateBgBrightness(); saveSettings(); });
                dom.laneCoverSlider.addEventListener('input', () => { updateLaneCover(); saveSettings(); });
                dom.backgroundSelect.addEventListener('change', e => { selectedBackgroundType = e.target.value; saveTaikoBeatmapSpecificSettings(); });
                window.addEventListener('resize', initGameUI);
                try {
                    await db.init();
                    await loadSavedSongsList();
                } catch (e) {
                    console.error('Application initialization failed:', e);
                    alert('データベースの初期化に失敗しました。保存機能は利用できません。');
                }
                initializeShortcutKeySetup('taiko-shortcut-retry', 'taiko-shortcut-menu');
            },
            togglePauseExternal: togglePause,
            retryGameExternal: function() {
                if (isGameRunning || isPaused || dom.resultsOverlay.style.display === 'flex') {
                    retryGame();
                }
            },
            returnToControlsExternal: function() { 
                if (isGameRunning || isPaused || dom.resultsOverlay.style.display === 'flex') {
                    returnToControls();
                }
            }
        };
    })();

    </script>
    <!-- ↓ PWAに必要なService Worker登録スクリプトを追加 -->
    <script>
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js').then(registration => {
              console.log('ServiceWorker registration successful with scope: ', registration.scope);
            }, err => {
              console.log('ServiceWorker registration failed: ', err);
            });
          });
        }
    </script>
</body>
</html>
