<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Game Chart Converter Suite</title>
    
    <!-- 外部ライブラリ (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/encoding-japanese/2.0.0/encoding.min.js"></script>

    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background: white;
            padding: 20px 30px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 900px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 2px solid #ddd;
            margin-bottom: 20px;
        }
        .tab-btn {
            padding: 15px 20px;
            cursor: pointer;
            font-weight: bold;
            color: #666;
            border: none;
            background: none;
            font-size: 16px;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }
        .tab-btn:hover { background-color: #f9f9f9; color: #333; }
        .tab-btn.active {
            color: #333;
            border-bottom: 3px solid;
        }
        /* Tab Colors */
        .tab-btn[data-target="o2t"].active { color: #ff66aa; border-color: #ff66aa; }
        .tab-btn[data-target="t2o"].active { color: #e91e63; border-color: #e91e63; }

        /* Sections */
        .converter-section { display: none; }
        .converter-section.active { display: block; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        h2 { margin-top: 0; font-size: 20px; }
        .o2t-color { color: #ff66aa; }
        .t2o-color { color: #e91e63; }

        .row { display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; }
        .col { flex: 1; min-width: 250px; }
        
        label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 14px; }
        
        input[type="text"], input[type="number"], select {
            width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;
        }

        /* Drop Zone */
        .drop-zone {
            border: 2px dashed #ccc;
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 10px;
            position: relative;
        }
        .active-o2t .drop-zone:hover { background: #fff0f5; border-color: #ff66aa; }
        .active-t2o .drop-zone:hover { background: #fff0f5; border-color: #e91e63; }
        .drop-zone.active { background: #e6ffea; border-color: #4CAF50 !important; }
        .drop-zone p { margin: 0; font-size: 14px; color: #666; pointer-events: none; }
        .drop-zone .file-name { font-weight: bold; color: #333; margin-top: 5px; display: block; }
        
        textarea {
            width: 100%; height: 350px;
            font-family: "Consolas", "Monaco", monospace;
            font-size: 13px; line-height: 1.4;
            padding: 10px; box-sizing: border-box;
            border: 1px solid #ccc; border-radius: 4px;
            background-color: #2d2d2d; color: #f8f8f2;
            resize: vertical;
        }

        .filename-group {
            margin-top: 20px;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #eee;
        }

        button {
            color: white; border: none;
            padding: 15px 30px; border-radius: 4px;
            cursor: pointer; font-size: 18px;
            width: 100%; margin-top: 10px; font-weight: bold;
            transition: background 0.2s;
        }
        button:disabled { background-color: #ccc !important; cursor: not-allowed; }

        /* Button Colors based on section */
        #o2t-download-btn { background-color: #ff66aa; }
        #o2t-download-btn:hover { background-color: #e65c99; }
        
        #t2o-download-btn { background-color: #e91e63; }
        #t2o-download-btn:hover { background-color: #c2185b; }

        /* 追加リンクのスタイル */
        .external-link-container {
            margin-top: 15px;
            text-align: right;
        }
        .external-link {
            color: #888;
            text-decoration: none;
            font-size: 14px;
            transition: color 0.2s;
        }
        .external-link:hover {
            color: #ff66aa;
            text-decoration: underline;
        }

        .footer { margin-top: 30px; font-size: 12px; color: #888; text-align: center; }
    </style>
</head>
<body>

<div class="container">
    <div class="tabs">
        <button class="tab-btn active" data-target="o2t">osu! to TJA</button>
        <button class="tab-btn" data-target="t2o">TJA to osu!</button>
    </div>

    <!-- ========================================== -->
    <!-- SECTION: osu! to TJA -->
    <!-- ========================================== -->
    <div id="o2t-section" class="converter-section active active-o2t">
        <h2 class="o2t-color">osu! to TJA Converter (Output: .zip)</h2>
        
        <div class="row">
            <div class="col">
                <label>COURSE (難易度)</label>
                <select id="o2t-course">
                    <option value="Oni">Oni (おに)</option>
                    <option value="Hard">Hard (むずかしい)</option>
                    <option value="Normal">Normal (ふつう)</option>
                    <option value="Easy">Easy (かんたん)</option>
                    <option value="Edit">Edit (エディット)</option>
                </select>
            </div>
            <div class="col">
                <label>LEVEL (★の数)</label>
                <input type="number" id="o2t-level" value="8" min="1" max="10">
            </div>
        </div>

        <div class="row">
            <div class="col">
                <label>1. osu!ファイル (.osu)</label>
                <div class="drop-zone" id="o2t-zone-osu">
                    <p>クリックまたはドロップ</p>
                    <span class="file-name" id="o2t-name-osu">未選択</span>
                    <input type="file" id="o2t-input-osu" accept=".osu" style="display:none">
                </div>
            </div>
            <div class="col">
                <label>2. 音楽ファイル (.mp3/.ogg)</label>
                <div class="drop-zone" id="o2t-zone-audio">
                    <p>クリックまたはドロップ</p>
                    <span class="file-name" id="o2t-name-audio">なし (TJAのみ)</span>
                    <input type="file" id="o2t-input-audio" accept="audio/*" style="display:none">
                </div>
            </div>
        </div>

        <div class="editor-area">
            <label>TJA プレビュー・編集</label>
            <textarea id="o2t-editor" placeholder="osu!ファイルを読み込むとここに変換結果が表示されます..."></textarea>
        </div>

        <div class="filename-group">
            <label>保存するファイル名 (.zip)</label>
            <input type="text" id="o2t-filename" placeholder="ファイル名 (自動入力)">
            <button id="o2t-download-btn" disabled>ZIPをダウンロード</button>
            
            <!-- ここにリンクを追加 -->
            <div class="external-link-container">
                <a href="https://masaki0420.github.io/osu2zip.html" class="external-link" target="_blank" rel="noopener noreferrer">OSU2zip</a>
            </div>
        </div>
    </div>

    <!-- ========================================== -->
    <!-- SECTION: TJA to osu! -->
    <!-- ========================================== -->
    <div id="t2o-section" class="converter-section active-t2o">
        <h2 class="t2o-color">TJA to osu! Converter (Output: .osz)</h2>

        <div class="row">
            <div class="col">
                <label>1. TJAファイル (.tja)</label>
                <div class="drop-zone" id="t2o-zone-tja">
                    <p>クリックまたはドロップ</p>
                    <span class="file-name" id="t2o-name-tja">未選択</span>
                    <input type="file" id="t2o-input-tja" accept=".tja,.txt" style="display:none">
                </div>
            </div>
            <div class="col">
                <label>2. 音楽ファイル (.mp3/.ogg)</label>
                <div class="drop-zone" id="t2o-zone-audio">
                    <p>クリックまたはドロップ</p>
                    <span class="file-name" id="t2o-name-audio">なし (osuのみ)</span>
                    <input type="file" id="t2o-input-audio" accept="audio/*" style="display:none">
                </div>
            </div>
        </div>

        <div class="editor-area">
            <label>osu! プレビュー・編集</label>
            <textarea id="t2o-editor" placeholder="TJAファイルを読み込むとここに変換結果が表示されます..."></textarea>
        </div>

        <div class="filename-group">
            <label>保存するファイル名 (.osz)</label>
            <input type="text" id="t2o-filename" placeholder="ファイル名 (自動入力)">
            <button id="t2o-download-btn" disabled>.osz をダウンロード</button>
        </div>
    </div>

</div>

<div class="footer">
    Requires Internet Connection for JSZip & Encoding.js.
</div>

<script>
    // --- SHARED UTILITIES ---
    function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }
    function gcdOfList(list) { return list.length === 0 ? 1 : list.reduce((a, b) => gcd(a, b)); }
    function round2(num) { return Math.round(num * 100) / 100; }

    function setupDropZone(zone, input, callback) {
        zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.classList.add('active'); });
        zone.addEventListener('dragleave', () => zone.classList.remove('active'));
        zone.addEventListener('drop', (e) => {
            e.preventDefault(); zone.classList.remove('active');
            if(e.dataTransfer.files.length) callback(e.dataTransfer.files[0]);
        });
        zone.addEventListener('click', () => input.click());
        input.addEventListener('change', () => { if(input.files.length) callback(input.files[0]); });
    }

    // --- TAB SWITCHING ---
    const tabs = document.querySelectorAll('.tab-btn');
    const sections = {
        'o2t': document.getElementById('o2t-section'),
        't2o': document.getElementById('t2o-section')
    };

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            // UI Toggle
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            // Section Toggle
            Object.values(sections).forEach(s => s.classList.remove('active'));
            sections[tab.dataset.target].classList.add('active');
        });
    });

    // ==========================================
    // LOGIC: osu! to TJA
    // ==========================================
    (function() {
        // Constants
        const T_MINUTE = 60000;
        const WATER_MARK = "//Auto generated by osu2tja (Web)";
        const MEASURE_TABLE = [[0.25,"1/16"],[1,"1/4"],[1.25,"5/16"],[1.5,"3/8"],[2,"2/4"],[2.25,"9/16"],[2.5,"5/8"],[3,"3/4"],[3.75,"15/16"],[4,"4/4"],[4.5,"9/8"],[5,"5/4"],[6,"6/4"],[7,"7/4"],[8,"8/4"],[9,"9/4"]];

        class OsuToTjaConverter {
            constructor(fileContent, course, level, audioFilename) {
                this.lines = fileContent.split(/\r?\n/);
                this.course = course; this.level = level;
                this.audioFilename = audioFilename || "";
                this.timingpoints = []; this.hitobjects = []; this.balloons = [];
                this.sliderVelocity = 1.4; this.taikoMode = false;
                this.commandsWithin = []; this.tailFix = false;
                this.title = ""; this.subtitle = ""; this.creator = ""; this.artist = "";
                this.preview = 0; this.audioFromOsu = "";
                this.tjaHeads = []; this.tjaContents = []; this.comboCnt = 0;
            }

            getBaseTimingPoint(t, redlineOnly = false) {
                let pool = redlineOnly ? this.timingpoints.filter(tp => tp.redline) : this.timingpoints;
                if (pool.length === 0) return null;
                if (t < pool[0].offset) return {...pool[0]};
                let base = pool[0];
                for (let tp of pool) { if (tp.offset > t) break; base = tp; }
                return {...base};
            }
            getRealOffset(intOffset) {
                const tm = this.getBaseTimingPoint(intOffset, true);
                if(!tm) return intOffset;
                const intDelta = Math.abs(intOffset - tm.offset);
                const sign = (intOffset - tm.offset > 0) ? 1 : -1;
                const tUnitCnt = Math.round(intDelta * tm.bpm * 24 / T_MINUTE);
                return tm.offset + (tUnitCnt / 24.0) * T_MINUTE * sign / tm.bpm;
            }
            getRealBeatCnt(tm, beatCnt) { return Math.round(beatCnt * 24) / 24; }
            getSliderTime(l, tm) { return (l * (T_MINUTE / tm.bpm)) / (100 * this.sliderVelocity * tm.scroll); }
            getSliderBeatCnt(l, tm) { return this.getRealBeatCnt(tm, l / (100 * this.sliderVelocity * tm.scroll)); }
            getDonKatsu(sound) {
                if (sound === 0) return '1'; // Normal
                if (sound & 8 || sound & 2) return '2'; // Clap/Whistle
                if (sound === 4) return '3'; // Finish
                if ((sound & 4) && (sound & 8 || sound & 2)) return '4'; // Finish+Clap
                return '1';
            }

            parse() {
                let currSec = "";
                for (let line of this.lines) {
                    line = line.trim();
                    if (!line) continue;
                    if (line.startsWith('[') && line.endsWith(']')) { currSec = line.slice(1, -1); continue; }
                    let vname = "", vval = "";
                    const idx = line.indexOf(':');
                    if (idx !== -1) { vname = line.substring(0, idx).trim(); vval = line.substring(idx + 1).trim(); }

                    if (currSec === "General") {
                        if (vname === "AudioFilename") this.audioFromOsu = vval;
                        else if (vname === "PreviewTime") this.preview = parseInt(vval);
                        else if (vname === "Mode") this.taikoMode = (parseInt(vval) === 1);
                    } else if (currSec === "Metadata") {
                        if (vname === "Title" || vname === "TitleUnicode") this.title = vval || this.title;
                        else if (vname === "Creator") this.creator = vval;
                        else if (vname === "Source") this.subtitle = vval;
                        else if (vname === "Artist" || vname === "ArtistUnicode") this.artist = vval || this.artist;
                    } else if (currSec === "Difficulty") {
                        if (vname === "SliderMultiplier") this.sliderVelocity = parseFloat(vval);
                    } else if (currSec === "TimingPoints") {
                        const p = line.split(',');
                        if (p.length >= 2) {
                            const offset = parseInt(p[0]); const rawbpm = parseFloat(p[1]);
                            const beats = p.length > 2 ? parseInt(p[2]) : 4;
                            const isGGT = p.length > 7 ? (p[7] !== '0') : false;
                            let tp = { offset, beats, GGT: isGGT, redline: true, scroll: 1.0, bpm: 0 };
                            if (rawbpm > 0) { tp.bpm = 60000 / rawbpm; } 
                            else {
                                const prev = this.timingpoints.length ? this.timingpoints[this.timingpoints.length-1] : {bpm:120};
                                tp.bpm = prev.bpm; tp.scroll = Math.max(0.1, -100.0 / rawbpm);
                                tp.redline = false; tp.offset = this.getRealOffset(offset);
                            }
                            this.timingpoints.push(tp);
                        }
                    } else if (currSec === "HitObjects") { this.parseHitObject(line); }
                }
                if (!this.audioFilename && this.audioFromOsu) this.audioFilename = this.audioFromOsu;
                this.processObjects();
                return this.generateString();
            }

            parseHitObject(line) {
                const p = line.split(','); if (p.length < 5) return;
                const time = parseInt(p[2]); let type = parseInt(p[3]); const sound = parseInt(p[4]);
                const offset = this.getRealOffset(time); type &= (~4);
                if (type === 1) { // Circle
                    this.hitobjects.push({ note: this.getDonKatsu(sound), offset });
                } else if (type === 2) { // Slider
                    const slides = parseInt(p[6]); const len = parseFloat(p[7]);
                    const tm = this.getBaseTimingPoint(this.timingpoints, offset);
                    const beatCnt = this.getSliderBeatCnt(len, tm);
                    let edgeSounds = [];
                    if (p.length > 8) edgeSounds = p[8].split('|').map(Number);
                    else edgeSounds = Array(slides+1).fill(parseInt(p[4]));
                    
                    if ((this.taikoMode && beatCnt < 1.0) || (!this.taikoMode && beatCnt * slides < 2.0)) {
                        for(let i=0; i<=slides; i++) {
                            if (i < edgeSounds.length) {
                                const pOffset = this.getRealOffset(offset + this.getSliderTime(len*i, tm));
                                this.hitobjects.push({ note: this.getDonKatsu(edgeSounds[i]), offset: pOffset });
                            }
                        }
                    } else {
                        const note = (sound === 0) ? '5' : '6';
                        const dur = this.getSliderTime(len, tm) * slides;
                        this.hitobjects.push({ note, offset });
                        this.hitobjects.push({ note: '8', offset: offset + dur });
                    }
                } else if (type === 8) { // Spinner
                    const endT = parseInt(p[5]);
                    this.hitobjects.push({ note: '7', offset });
                    const rEnd = this.getRealOffset(endT);
                    this.hitobjects.push({ note: '8', offset: rEnd });
                    this.balloons.push(Math.max(1, Math.floor((rEnd - offset) / 60)));
                }
            }

            writeBar(tm, data, begin, end) {
                const tUnit = (T_MINUTE / tm.bpm) / 24;
                let offsets = [begin, ...data.map(d=>d.offset), end];
                let deltas = [];
                for(let i=0; i<offsets.length-1; i++) deltas.push(Math.round((offsets[i+1]-offsets[i])/tUnit));
                if(deltas.length && Math.abs(deltas[deltas.length-1]) < 1) {
                    this.tailFix = true; if(data.length) this.writeBar(tm, data.slice(0,-1), begin, end); return;
                }
                let s = ""; const g = gcdOfList(deltas); if(g <= 0) return;
                s += "0".repeat(Math.floor(deltas[0]/g));
                for(let i=0; i<deltas.length-1; i++) {
                    const note = data[i];
                    while(this.commandsWithin.length && note.offset >= this.commandsWithin[0].offset) {
                        this.tjaContents.push(this.commandsWithin.shift().val);
                    }
                    s += note.note; s += "0".repeat(Math.floor(deltas[i+1]/g) - 1);
                    if(['1','2','3','4'].includes(note.note)) this.comboCnt++;
                }
                this.tjaContents.push(s + ",");
            }

            writeIncomplete(tm, data, begin, end) {
                if(!data.length && Math.abs(begin-end)<1) return;
                if(!data.length) {
                    const d = (end-begin)/1000.0;
                    if(d > 0.001) this.tjaContents.push(`#DELAY ${d.toFixed(3)}`);
                    return;
                }
                const lastOff = data[data.length-1].offset;
                const minBeats = this.getRealBeatCnt(tm, tm.bpm*(lastOff-begin)/T_MINUTE) + 1.0/24;
                for(let m of MEASURE_TABLE) {
                    const dur = m[0] * T_MINUTE / tm.bpm;
                    if(m[0] >= minBeats && (begin+dur) <= end+1) {
                        this.tjaContents.push("#MEASURE " + m[1]);
                        const mEnd = begin+dur; this.writeBar(tm, data, begin, mEnd);
                        const delay = end - mEnd;
                        if(delay >= 1) this.tjaContents.push(`#DELAY ${(delay/1000.0).toFixed(3)}`);
                        return;
                    }
                }
                this.tjaContents.push("// Irregular Measure");
                this.writeBar(tm, data, begin, end);
            }

            processObjects() {
                if(!this.hitobjects.length || !this.timingpoints.length) return;
                this.hitobjects.sort((a,b)=>a.offset-b.offset); this.timingpoints.sort((a,b)=>a.offset-b.offset);
                if(this.hitobjects[0].offset < this.timingpoints[0].offset) {
                    let n = {...this.timingpoints[0], offset: this.hitobjects[0].offset}; this.timingpoints.unshift(n);
                }
                let cScroll=1.0, cGgt=false;
                for(let tp of this.timingpoints) {
                    if(tp.scroll !== cScroll) this.commandsWithin.push({offset:tp.offset, val:`#SCROLL ${tp.scroll}`});
                    if(tp.GGT !== cGgt) this.commandsWithin.push({offset:tp.offset, val:tp.GGT ? '#GOGOSTART' : '#GOGOEND'});
                    cScroll=tp.scroll; cGgt=tp.GGT;
                }
                let tmIdx=0, objIdx=0; let meas = this.timingpoints[0].beats; let cBpm = this.timingpoints[0].bpm;
                let barBegin = this.timingpoints[0].offset; let barMax = meas * T_MINUTE / cBpm; let barData = [];
                
                this.tjaHeads.push(`TITLE:${this.title}`);
                this.tjaHeads.push(`SUBTITLE:${this.subtitle || this.artist}`);
                this.tjaHeads.push(`WAVE:${this.audioFilename}`);
                this.tjaHeads.push(`BPM:${round2(this.timingpoints[0].bpm)}`);
                this.tjaHeads.push(`OFFSET:${-(this.timingpoints[0].offset/1000.0).toFixed(3)}`);
                this.tjaHeads.push(`DEMOSTART:${(this.preview/1000.0).toFixed(3)}`);
                this.tjaHeads.push(`COURSE:${this.course}`);
                this.tjaHeads.push(`LEVEL:${this.level}`);
                this.tjaHeads.push(`BALLOON:${this.balloons.join(',')}`);
                this.tjaHeads.push(""); this.tjaHeads.push("#START");

                const isNew = (tp) => tp.bpm !== cBpm || tp.beats !== meas || tp.redline;
                while(objIdx < this.hitobjects.length) {
                    const obj = this.hitobjects[objIdx];
                    let nextM = (tmIdx < this.timingpoints.length) ? this.timingpoints[tmIdx].offset : barBegin+barMax+1;
                    if(tmIdx < this.timingpoints.length && !isNew(this.timingpoints[tmIdx])) { tmIdx++; continue; }
                    const tpb = T_MINUTE / cBpm; const end = Math.min(barBegin+barMax, nextM);
                    if(obj.offset + tpb/24 >= end) {
                        if(Math.abs(end - (barBegin+barMax)) < 1) {
                            this.writeBar(this.getBaseTimingPoint(barBegin), barData, barBegin, end);
                            barData = []; barBegin = this.getRealOffset(end); barMax = meas * T_MINUTE / cBpm;
                        } else {
                            this.writeIncomplete(this.getBaseTimingPoint(barBegin), barData, barBegin, end);
                            barData = []; const nTp = this.timingpoints[tmIdx]; meas = nTp.beats;
                            if(nTp.redline) { cBpm = nTp.bpm; barBegin = nextM; this.tjaContents.push(`#BPMCHANGE ${cBpm}`); } 
                            else { barBegin = end; }
                            barMax = meas * T_MINUTE / cBpm;
                            if(this.tailFix) { this.tailFix = false; objIdx--; this.hitobjects[objIdx].offset = barBegin; }
                            this.tjaContents.push(`#MEASURE ${meas}/4`); tmIdx++;
                        }
                    } else {
                        if(obj.offset < barBegin) barData.push({...obj, offset:barBegin}); else barData.push(obj);
                        objIdx++;
                    }
                }
                if(barData.length) this.writeBar(this.getBaseTimingPoint(barBegin), barData, barBegin, barBegin+barMax);
                this.tjaContents.push("#END"); this.tjaContents.push(WATER_MARK);
            }
            generateString() { return this.tjaHeads.concat(this.tjaContents).join('\r\n'); }
        }

        // --- UI Interactions (o2t) ---
        let currentOsuFile = null, currentAudioFile = null;
        const els = {
            zoneOsu: document.getElementById('o2t-zone-osu'), inputOsu: document.getElementById('o2t-input-osu'), nameOsu: document.getElementById('o2t-name-osu'),
            zoneAudio: document.getElementById('o2t-zone-audio'), inputAudio: document.getElementById('o2t-input-audio'), nameAudio: document.getElementById('o2t-name-audio'),
            editor: document.getElementById('o2t-editor'), downloadBtn: document.getElementById('o2t-download-btn'),
            course: document.getElementById('o2t-course'), level: document.getElementById('o2t-level'), filename: document.getElementById('o2t-filename')
        };

        setupDropZone(els.zoneOsu, els.inputOsu, file => {
            if (!file.name.toLowerCase().endsWith('.osu')) return alert("osuファイルを選択してください");
            currentOsuFile = file;
            els.filename.value = file.name.replace(/\.osu$/i, "");
            els.nameOsu.textContent = file.name; els.nameOsu.style.color = "#ff66aa";
            runConversion();
        });
        setupDropZone(els.zoneAudio, els.inputAudio, file => {
            currentAudioFile = file;
            els.nameAudio.textContent = file.name; els.nameAudio.style.color = "#4CAF50";
            let text = els.editor.value;
            if (text && /^(WAVE:).*$/m.test(text)) els.editor.value = text.replace(/^(WAVE:).*$/m, `WAVE:${file.name}`);
        });

        const runConversion = () => {
            if (!currentOsuFile) return;
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const conv = new OsuToTjaConverter(e.target.result, els.course.value, parseInt(els.level.value), currentAudioFile?.name);
                    els.editor.value = conv.parse(); els.downloadBtn.disabled = false;
                } catch(err) { els.editor.value = "Error:\n" + err.message; }
            };
            reader.readAsText(currentOsuFile, "UTF-8");
        };
        els.course.addEventListener('change', () => currentOsuFile && runConversion());
        els.level.addEventListener('change', () => currentOsuFile && runConversion());

        els.downloadBtn.addEventListener('click', async () => {
            const text = els.editor.value; if (!text) return;
            let fname = els.filename.value.trim() || "converted";
            try {
                els.downloadBtn.disabled = true; els.downloadBtn.textContent = "ZIP作成中...";
                const zip = new JSZip();
                const buffer = Encoding.convert(text, { to: 'SJIS', from: 'UNICODE', type: 'arraybuffer' });
                zip.file(`${fname}.tja`, new Uint8Array(buffer));
                if (currentAudioFile) zip.file(currentAudioFile.name, currentAudioFile);
                const content = await zip.generateAsync({type: "blob"});
                const a = document.createElement("a"); a.href = URL.createObjectURL(content);
                a.download = `${fname}.zip`; document.body.appendChild(a); a.click(); document.body.removeChild(a);
            } catch(e) { alert("Error: " + e.message); } 
            finally { els.downloadBtn.disabled = false; els.downloadBtn.textContent = "ZIPをダウンロード"; }
        });
    })();

    // ==========================================
    // LOGIC: TJA to osu!
    // ==========================================
    (function() {
        class TjaToOsuConverter {
            constructor(tjaContent, audioFilename) {
                this.lines = tjaContent.split(/\r?\n/);
                this.audioFilename = audioFilename || "";
                this.TITLE = "NO TITLE"; this.SUBTITLE = ""; this.BPM = 120.0; this.WAVE = "audio.mp3";
                this.OFFSET = 0.0; this.DEMOSTART = 0.0; this.COURSE = "Oni";
                this.SliderMultiplier = 1.4; this.SampleSet = "Normal";
                this.timingPoints = []; this.hitObjects = []; this.barData = [];
                this.currentTime = 0.0; this.hasStarted = false; this.lastingNote = null;
                this.parseMetadata(); this.parseBody();
            }

            parseMetadata() {
                for (let line of this.lines) {
                    line = line.trim(); if (line.startsWith("//") || line === "") continue;
                    const p = line.split(":");
                    if (p.length >= 2) {
                        const key = p[0].trim().toUpperCase(); const val = p.slice(1).join(":").trim();
                        if (key === "TITLE") this.TITLE = val;
                        else if (key === "SUBTITLE") this.SUBTITLE = val;
                        else if (key === "BPM") this.BPM = parseFloat(val);
                        else if (key === "WAVE") this.WAVE = val;
                        else if (key === "OFFSET") this.OFFSET = parseFloat(val);
                        else if (key === "DEMOSTART") this.DEMOSTART = parseFloat(val);
                        else if (key === "COURSE") this.COURSE = val;
                    }
                    if (line.startsWith("#START")) break;
                }
                if (this.audioFilename) this.WAVE = this.audioFilename;
            }

            addDefaultTimingPoint() {
                this.currentTime = -this.OFFSET * 1000.0;
                this.timingPoints.push({ offset: this.currentTime, bpm: this.BPM, beatLength: 60000.0 / this.BPM, meter: 4, redline: true, scroll: 1.0, ggt: false });
            }

            parseBody() {
                this.addDefaultTimingPoint();
                for (let line of this.lines) {
                    line = line.trim(); const cIdx = line.indexOf("//"); if (cIdx !== -1) line = line.substring(0, cIdx).trim();
                    if (!line) continue;
                    if (line.startsWith("#START")) { this.hasStarted = true; continue; }
                    if (line.startsWith("#END")) break;
                    if (!this.hasStarted) continue;
                    if (line.startsWith("#")) this.handleCommand(line); else this.handleNote(line);
                }
            }

            handleCommand(line) { if (this.barData.length > 0) this.barData.push(line); else this.executeCommand(line); }
            handleNote(line) { for (let char of line) { if (char.match(/[0-9]/)) this.barData.push(char); else if (char === ',') this.processBar(); } }

            executeCommand(cmdStr) {
                const parts = cmdStr.split(/[ \t]+/); const cmd = parts[0].toUpperCase(); const val = parts.length > 1 ? parseFloat(parts[1]) : 0;
                if (cmd === "#DELAY") { this.currentTime += val * 1000; return; }
                const lastTp = this.getLastTimingPoint();
                let newTp = { ...lastTp, offset: this.currentTime, redline: false }; let changed = false;
                if (cmd === "#BPMCHANGE") { newTp.bpm = val; newTp.beatLength = 60000.0 / val; newTp.redline = true; changed = true; }
                else if (cmd === "#MEASURE") { const frac = parts[1].split('/'); if(frac.length===2) { newTp.meter = (parseFloat(frac[0])/parseFloat(frac[1]))*4; newTp.redline = true; changed = true; } }
                else if (cmd === "#SCROLL") { newTp.scroll = val; newTp.redline = false; changed = true; }
                else if (cmd === "#GOGOSTART") { newTp.ggt = true; newTp.redline = false; changed = true; }
                else if (cmd === "#GOGOEND") { newTp.ggt = false; newTp.redline = false; changed = true; }

                if (changed) {
                    const existingIdx = this.timingPoints.findIndex(tp => Math.abs(tp.offset - this.currentTime) < 1);
                    if (existingIdx !== -1) {
                        if (cmd === "#BPMCHANGE") { Object.assign(this.timingPoints[existingIdx], {bpm:newTp.bpm, beatLength:newTp.beatLength, redline:true}); }
                        else if (cmd === "#MEASURE") { this.timingPoints[existingIdx].meter = newTp.meter; this.timingPoints[existingIdx].redline = true; }
                        else if (cmd === "#SCROLL") this.timingPoints[existingIdx].scroll = newTp.scroll;
                        else if (cmd.includes("GOGO")) this.timingPoints[existingIdx].ggt = newTp.ggt;
                    } else this.timingPoints.push(newTp);
                }
            }

            processBar() {
                if (this.barData.length === 0) return;
                const notes = this.barData.filter(d => d.length === 1 && d.match(/[0-9]/));
                const lastTp = this.getLastTimingPoint();
                const measureTime = (60000.0 / lastTp.bpm) * lastTp.meter;
                const timePerUnit = notes.length > 0 ? measureTime / notes.length : 0;
                for (let data of this.barData) {
                    if (data.startsWith("#")) this.executeCommand(data);
                    else {
                        const char = data;
                        if (char !== '0' && !(this.lastingNote && char !== '8')) this.addNote(char, this.currentTime);
                        this.currentTime += timePerUnit;
                    }
                }
                this.barData = [];
            }

            addNote(char, time) {
                const type = parseInt(char); const offset = Math.round(time);
                let hitType = 1, sound = 0;
                if (type === 1) sound = 0; else if (type === 2) sound = 8; else if (type === 3) sound = 4; else if (type === 4) sound = 12;
                else if (type === 5 || type === 6) { this.lastingNote = { type: 'slider', startTime: time, sound: (type===6?4:0) }; return; }
                else if (type === 7 || type === 9) { this.lastingNote = { type: 'spinner', startTime: time, sound: 0 }; return; }
                else if (type === 8) { if (this.lastingNote) { this.endLastingNote(time); this.lastingNote = null; } return; }
                else return;
                this.hitObjects.push({ x: 256, y: 192, time: offset, type: hitType, hitSound: sound, extras: "0:0:0:0:" });
            }

            endLastingNote(endTime) {
                const ln = this.lastingNote; const startOffset = Math.round(ln.startTime);
                if (ln.type === 'slider') {
                    const dur = endTime - ln.startTime;
                    const tp = this.getTimingPointAt(ln.startTime);
                    const length = (this.SliderMultiplier * 100 * tp.scroll) * (dur / (60000.0 / tp.bpm));
                    this.hitObjects.push({ x: 256, y: 192, time: startOffset, type: 2, hitSound: ln.sound, extras: `L|${Math.round(256+length)}:192,1,${length.toFixed(2)}` });
                } else if (ln.type === 'spinner') {
                    this.hitObjects.push({ x: 256, y: 192, time: startOffset, type: 8, hitSound: ln.sound, extras: Math.round(endTime) });
                }
            }

            getLastTimingPoint() { return this.timingPoints.length > 0 ? this.timingPoints[this.timingPoints.length - 1] : {bpm: 120, meter: 4, scroll: 1}; }
            getTimingPointAt(time) {
                let best = this.timingPoints[0];
                for (let tp of this.timingPoints) { if (tp.offset <= time + 1) best = tp; else break; }
                return best;
            }

            generateOsu() {
                let s = "osu file format v14\n\n[General]\n";
                s += `AudioFilename: ${this.WAVE}\nAudioLeadIn: 0\nPreviewTime: ${Math.round(this.DEMOSTART * 1000)}\n`;
                s += `Countdown: 0\nSampleSet: ${this.SampleSet}\nStackLeniency: 0.7\nMode: 1\nLetterboxInBreaks: 0\n\n[Metadata]\n`;
                s += `Title:${this.TITLE}\nTitleUnicode:${this.TITLE}\nArtist:Unknown\nArtistUnicode:Unknown\nCreator:TJA2OSU\nVersion:${this.COURSE}\nSource:${this.SUBTITLE}\nTags:Taiko Jiro Convert\n\n`;
                s += `[Difficulty]\nHPDrainRate:5\nCircleSize:5\nOverallDifficulty:5\nApproachRate:9\nSliderMultiplier:${this.SliderMultiplier}\nSliderTickRate:1\n\n[TimingPoints]\n`;
                for (let tp of this.timingPoints) {
                    let val = tp.redline ? tp.beatLength : -100.0 / Math.max(0.1, tp.scroll);
                    s += `${Math.round(tp.offset)},${val.toFixed(6)},${Math.round(tp.meter)},1,0,100,${tp.redline?1:0},${tp.ggt?1:0}\n`;
                }
                s += "\n[HitObjects]\n";
                for (let ho of this.hitObjects) {
                    if (ho.type === 8) s += `${ho.x},${ho.y},${ho.time},${ho.type},${ho.hitSound},${ho.extras},0:0:0:0:\n`;
                    else s += `${ho.x},${ho.y},${ho.time},${ho.type},${ho.hitSound},${ho.extras}\n`;
                }
                return s;
            }
        }

        // --- UI Interactions (t2o) ---
        let currentTjaFile = null, currentAudioFile = null;
        const els = {
            zoneTja: document.getElementById('t2o-zone-tja'), inputTja: document.getElementById('t2o-input-tja'), nameTja: document.getElementById('t2o-name-tja'),
            zoneAudio: document.getElementById('t2o-zone-audio'), inputAudio: document.getElementById('t2o-input-audio'), nameAudio: document.getElementById('t2o-name-audio'),
            editor: document.getElementById('t2o-editor'), downloadBtn: document.getElementById('t2o-download-btn'), filename: document.getElementById('t2o-filename')
        };

        setupDropZone(els.zoneTja, els.inputTja, file => {
            if (!file.name.match(/\.(tja|txt)$/i)) return alert("TJAファイルを選択してください");
            currentTjaFile = file;
            els.filename.value = file.name.replace(/\.(tja|txt)$/i, "");
            els.nameTja.textContent = file.name; els.nameTja.style.color = "#e91e63";
            const reader = new FileReader();
            reader.onload = e => {
                const buffer = e.target.result;
                const detected = Encoding.detect(new Uint8Array(buffer));
                const text = Encoding.codeToString(Encoding.convert(new Uint8Array(buffer), { to: 'UNICODE', from: detected }));
                try {
                    const conv = new TjaToOsuConverter(text, currentAudioFile?.name);
                    els.editor.value = conv.generateOsu(); els.downloadBtn.disabled = false;
                } catch(err) { els.editor.value = "Error:\n" + err.message; }
            };
            reader.readAsArrayBuffer(file);
        });

        setupDropZone(els.zoneAudio, els.inputAudio, file => {
            currentAudioFile = file;
            els.nameAudio.textContent = file.name; els.nameAudio.style.color = "#4CAF50";
            let text = els.editor.value;
            if (text && /^(AudioFilename:).*$/m.test(text)) els.editor.value = text.replace(/^(AudioFilename:).*$/m, `AudioFilename: ${file.name}`);
        });

        els.downloadBtn.addEventListener('click', async () => {
            const text = els.editor.value; if (!text) return;
            let fname = els.filename.value.trim() || "converted";
            try {
                els.downloadBtn.disabled = true; els.downloadBtn.textContent = ".osz 作成中...";
                const zip = new JSZip();
                zip.file(`${fname}.osu`, text);
                if (currentAudioFile) zip.file(currentAudioFile.name, currentAudioFile);
                const content = await zip.generateAsync({type: "blob"});
                const a = document.createElement("a"); a.href = URL.createObjectURL(content);
                a.download = `${fname}.osz`; document.body.appendChild(a); a.click(); document.body.removeChild(a);
            } catch(e) { alert("Error: " + e.message); } 
            finally { els.downloadBtn.disabled = false; els.downloadBtn.textContent = ".osz をダウンロード"; }
        });
    })();
</script>

</body>
</html>
