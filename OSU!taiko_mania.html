<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rhythm Game Player</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* --- Global and Game Selector Styles --- */
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: #0d0d1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            color: white;
        }

        .game-wrapper {
            width: 100%;
            height: 100%;
            display: none; /* Initially hidden */
        }
        
        #mania-wrapper #game-container.playing,
        #taiko-wrapper #game-container.playing {
            cursor: none;
        }

        #game-selector {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 30px;
            text-align: center;
        }

        #game-selector h1 {
            font-size: 3em;
            font-weight: 600;
            color: #e0e5f0;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }

        .game-select-button {
            padding: 20px 40px;
            font-size: 1.5em;
            font-weight: 500;
            color: white;
            border: 2px solid #4a5578;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: #1f2940;
            min-width: 300px;
        }

        #select-mania:hover {
            background-color: #3d7eff;
            border-color: #3d7eff;
            box-shadow: 0 0 20px #3d7eff;
        }

        #select-taiko:hover {
            background-color: #d9534f;
            border-color: #d9534f;
            box-shadow: 0 0 20px #d9534f;
        }

        /* --- osu!mania Styles (Scoped) --- */
        #mania-wrapper {
            --num-lanes: 4;
            --note-height: 22px;
            --receptor-size: 70px;
            --judgment-line-pos: 15vh;
            --judgment-text-top: 65vh;
            --panel-bg: #1f2940;
            --panel-text: #e0e5f0;
            --panel-border: #4a5578;
            --accent-color: #3d7eff;
            --disabled-color: #555c6f;
            --background-brightness: 0.5;
            --combo-size-scale: 1.0;
            --combo-position-y: 45%;
            --lane-opacity: 0.5;
            --playfield-bg-opacity: 0.5;
        }
        #mania-wrapper #video-background, #mania-wrapper #image-background { position: fixed; top: 50%; left: 50%; min-width: 100%; min-height: 100%; width: auto; height: auto; transform: translateX(-50%) translateY(-50%); z-index: 1; display: none; filter: brightness(var(--background-brightness)); object-fit: cover; }
        #mania-wrapper #app-container { z-index: 2; position: relative; display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; }
        #mania-wrapper #controls-panel { width: 95%; max-width: 900px; background-color: var(--panel-bg); border: 1px solid var(--panel-border); padding: 25px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); color: var(--panel-text); display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: auto 1fr auto auto auto; gap: 20px 25px; align-items: flex-start; }
        #mania-wrapper .panel-column { display: flex; flex-direction: column; gap: 20px; min-height: 350px; }
        #mania-wrapper #beatmap-library-selector { width: 100%; background-color: #2a344d; color: var(--panel-text); border: 1px solid var(--panel-border); border-radius: 6px; padding: 8px; height: 190px; }
        #mania-wrapper #beatmap-library-selector option { padding: 5px; }
        #mania-wrapper .library-buttons, #mania-wrapper .settings-buttons { display: flex; gap: 10px; }
        #mania-wrapper .library-buttons .control-button { flex-grow: 1; }
        #mania-wrapper #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; overflow: hidden; display: none; z-index: 10; }
        #mania-wrapper #playfield { position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 100%; max-width: 500px; height: 100%; z-index: 10; }
        #mania-wrapper #playfield-background { position: absolute; width: 100%; height: 100%; background-color: #000; z-index: -1; display: none; opacity: var(--playfield-bg-opacity); }
        #mania-wrapper .grid-item-full { grid-column: 1 / -1; }
        #mania-wrapper #controls-panel h2 { grid-column: 1 / -1; text-align: center; margin: 0 0 10px 0; font-size: 1.8em; font-weight: 600; }
        #mania-wrapper #controls-panel label { font-size: 0.9em; font-weight: 500; color: #a0a8c0; margin-bottom: 8px; display: block; }
        #mania-wrapper #controls-panel p { grid-column: 1 / -1; font-size: 0.8em; color: #828aa1; text-align: center; margin: 0; }
        #mania-wrapper input[type="file"] { width: 0.1px; height: 0.1px; opacity: 0; overflow: hidden; position: absolute; z-index: -1; }
        #mania-wrapper .control-button, #mania-wrapper .styled-select { width: 100%; padding: 12px; font-size: 1em; font-weight: 500; color: var(--panel-text); background-color: #394362; border: 1px solid var(--panel-border); border-radius: 8px; cursor: pointer; transition: background-color 0.2s; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23e0e5f0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 1em top 50%; background-size: .65em auto; padding-right: 2.5em; }
        #mania-wrapper .control-button:hover, #mania-wrapper .styled-select:hover { background-color: #4a5578; }
        #mania-wrapper .control-button:disabled, #mania-wrapper .styled-select:disabled { background-color: var(--disabled-color); cursor: not-allowed; color: #8c92a3; }
        #mania-wrapper input[type="range"] { -webkit-appearance: none; width: 100%; height: 6px; background: #2a344d; border-radius: 3px; outline: none; cursor: pointer; }
        #mania-wrapper input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--accent-color); border-radius: 50%; cursor: pointer; }
        #mania-wrapper input[type="number"] { width: 100%; background-color: #2a344d; color: var(--panel-text); border: 1px solid var(--panel-border); border-radius: 6px; padding: 8px; text-align: center; font-size: 1em; box-sizing: border-box; }
        #mania-wrapper #key-config-inputs { display: flex; justify-content: space-between; gap: 5px; width: 100%; }
        #mania-wrapper .key-config-input { flex-grow: 1; height: 45px; background-color: #2a344d; border: 1px solid var(--panel-border); border-radius: 6px; color: var(--panel-text); font-size: 1.3em; font-weight: bold; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; user-select: none; }
        #mania-wrapper .key-config-input:hover { background-color: #394362; }
        #mania-wrapper .key-config-input:focus, #mania-wrapper .key-config-input.is-waiting { background-color: var(--accent-color); border-color: var(--accent-color); outline: none; color: white; }
        #mania-wrapper .checkbox-wrapper { display: flex; align-items: center; cursor: pointer; }
        #mania-wrapper input[type="checkbox"] { display: none; }
        #mania-wrapper .custom-checkbox { width: 20px; height: 20px; background-color: #2a344d; border: 1px solid var(--panel-border); border-radius: 4px; display: inline-block; position: relative; margin-right: 10px; transition: background-color 0.2s; }
        #mania-wrapper input[type="checkbox"]:checked + .custom-checkbox { background-color: var(--accent-color); }
        #mania-wrapper .custom-checkbox::after { content: ''; position: absolute; left: 6px; top: 2px; width: 5px; height: 10px; border: solid white; border-width: 0 3px 3px 0; transform: rotate(45deg); display: none; }
        #mania-wrapper input[type="checkbox"]:checked + .custom-checkbox::after { display: block; }
        #mania-wrapper #start-button { grid-column: 1 / -1; padding: 15px; font-size: 1.2em; font-weight: 600; color: white; background-color: var(--accent-color); border: none; }
        #mania-wrapper #start-button:disabled { background-color: var(--disabled-color); }
        #mania-wrapper #song-info { grid-column: 1 / -1; min-height: 20px; text-align: center; }
        #mania-wrapper .offset-controls-container { display: flex; gap: 10px; }
        #mania-wrapper .offset-control { flex: 1; }
        #mania-wrapper #lanes-container { display: flex; height: 100%; }
        #mania-wrapper .lane { width: calc(100% / var(--num-lanes)); height: 100%; border-left: 1px solid rgba(255, 255, 255, 0.2); background-color: rgba(0,0,0, var(--lane-opacity)); position: relative; box-sizing: border-box; user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent; }
        #mania-wrapper .lane:last-child { border-right: 1px solid rgba(255, 255, 255, 0.2); }
        #mania-wrapper #judgment-line { position: absolute; bottom: var(--judgment-line-pos); left: 0; width: 100%; height: 2px; background-color: rgba(255,255,255,0.8); box-shadow: 0 0 10px white; z-index: 15; }
        #mania-wrapper .note-wrapper { position: absolute; left: 0; width: 100%; top: 0; will-change: transform; pointer-events: none; display: flex; justify-content: center; }
        #mania-wrapper .note-wrapper.hidden { display: none; }
        #mania-wrapper .note-wrapper:has(.long-note-body) .note { position: relative; z-index: 2; }
        #mania-wrapper .long-note-body { width: 90%; background: #a13d53; border-radius: 4px 4px 0 0; position: absolute; z-index: 1; transform: translateY(calc(var(--note-height) / 2)); padding-bottom: calc(var(--note-height) / 2); box-sizing: content-box; }
        #mania-wrapper #playfield.note-style-circle .note-wrapper:has(.long-note-body) .note { width: var(--receptor-size); height: var(--receptor-size); border-radius: 50%; background: #a0d8ef; border: 2px solid rgba(255,255,255,0.7); box-sizing: border-box; box-shadow: none; aspect-ratio: 1/1; }
        #mania-wrapper #playfield.note-style-circle .long-note-body { width: var(--receptor-size); background: #5c8a9f; border-radius: calc(var(--receptor-size) / 2) calc(var(--receptor-size) / 2) 0 0; transform: none; padding-bottom: 0; box-sizing: border-box; }
        #mania-wrapper .note { width: 90%; margin: auto; height: var(--note-height); background: linear-gradient(90deg, #FF4D6D, #FF8FA3); border-radius: 4px; position: absolute; top: 0; box-shadow: 0 0 12px #FF4D6D; }
        #mania-wrapper #playfield.note-style-circle .note { width: var(--receptor-size); height: var(--receptor-size); border-radius: 50%; background: #a0d8ef; border: 2px solid white; box-sizing: border-box; box-shadow: none; aspect-ratio: 1/1; }
        #mania-wrapper #playfield.note-style-circle #playfield-background { display: block; }
        #mania-wrapper #playfield.note-style-circle .lane { background-color: transparent; border-left: none; border-right: 1px solid rgba(255, 255, 255, 0.25); }
        #mania-wrapper #playfield.note-style-circle .lane:first-child { border-left: 1px solid rgba(255, 255, 255, 0.25); }
        #mania-wrapper #playfield.note-style-circle #judgment-line { display: none; }
        #mania-wrapper #playfield.note-style-circle #key-indicators { bottom: var(--judgment-line-pos); transform: translateY(50%); height: auto; z-index: 12; pointer-events: none; }
        #mania-wrapper #playfield.note-style-circle .key { width: 100%; background-color: transparent; border: none; margin: 0; height: var(--receptor-size); display: flex; align-items: center; justify-content: center; font-size: 0; }
        #mania-wrapper #playfield.note-style-circle .key::before { content: ''; display: block; height: var(--receptor-size); width: var(--receptor-size); border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%; background-color: rgba(0, 0, 0, 0.3); transition: background-color 0.05s, box-shadow 0.05s; box-sizing: border-box; }
        #mania-wrapper #playfield.note-style-circle .key.active::before { background-color: rgba(255, 255, 255, 5.0); box-shadow: 0 0 20px inset; }
        #mania-wrapper #key-indicators { position: absolute; bottom: 0; left: 0; width: 100%; height: var(--judgment-line-pos); display: flex; z-index: 12; pointer-events: none; }
        #mania-wrapper .key { width: calc(100% / var(--num-lanes)); text-align: center; font-size: 1.5em; color: rgba(255, 255, 255, 0.5); font-weight: 500; display: flex; align-items: center; justify-content: center; padding-bottom: 2vh; }
        #mania-wrapper #ui-panel { position: absolute; top: 20px; right: 30px; text-align: right; color: white; z-index: 20; }
        #mania-wrapper #score { font-size: 3em; font-weight: 600; }
        #mania-wrapper #accuracy { font-size: 1.5em; font-weight: 400; margin-top: 5px; }
        #mania-wrapper #judgment-timing-text { position: absolute; top: calc(var(--judgment-text-top) - 3.5vh); left: 50%; transform: translateX(-50%); font-size: 1.2em; opacity: 0; z-index: 22; color: #ccc; animation: mania-judgment-anim-new 0.4s ease-out; pointer-events: none; }
        #mania-wrapper #judgment-text { position: absolute; top: var(--judgment-text-top); left: 50%; transform: translateX(-50%); font-size: 2.2em; font-weight: bold; opacity: 0; z-index: 22; padding: 5px 20px; border-radius: 4px; color: white; text-align: center; animation: mania-judgment-anim-new 0.4s ease-out; pointer-events: none; }
        @keyframes mania-judgment-anim-new { 0% { transform: translateX(-50%) scale(0.9); opacity: 1; } 80% { transform: translateX(-50%) scale(1.05); opacity: 1; } 100% { transform: translateX(-50%) scale(1.05); opacity: 0; } }
        #mania-wrapper #combo-container { position: absolute; top: var(--combo-position-y); left: 50%; transform: translate(-50%, -50%); z-index: 13; color: white; text-align: center; opacity: 0; transition: opacity 0.2s; pointer-events: none; }
        #mania-wrapper #combo-container.visible { opacity: 1; }
        #mania-wrapper #combo-count { font-size: calc(7em * var(--combo-size-scale)); font-weight: bold; line-height: 1; text-shadow: 0 0 15px rgba(0,0,0,0.8); }
        #mania-wrapper #combo-label { font-size: calc(1.8em * var(--combo-size-scale)); font-weight: 500; }
        #mania-wrapper .combo-anim { animation: combo-pop 0.1s ease-out; }
        @keyframes combo-pop { 0% { transform: scale(1.3); } 100% { transform: scale(1); } }
        #mania-wrapper #ingame-pause-button { position: absolute; top: 20px; left: 20px; width: 48px; height: 48px; background-color: rgba(255,255,255,0.1); border: 2px solid white; border-radius: 50%; color: white; font-size: 1.8em; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 100; }
        #mania-wrapper .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); color: white; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 200; }
        #mania-wrapper .overlay-menu { text-align: center; padding: 20px; background-color: #16213e; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,0.5); }
        #mania-wrapper .overlay-menu h2 { font-size: 2.5em; margin-top: 0; margin-bottom: 30px; }
        #mania-wrapper .overlay-button { display: block; width: 200px; padding: 15px; margin: 10px auto; font-size: 1.2em; color: white; border: 2px solid white; background-color: transparent; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, color 0.2s; }
        #mania-wrapper .overlay-button:hover, #mania-wrapper .overlay-button.selected { background-color: white; color: black; }
        #mania-wrapper #results-menu .results-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px 20px; margin-bottom: 20px; font-size: 1.2em; }
        #mania-wrapper #results-accuracy-container { font-size: 1.5em; font-weight: bold; margin-bottom: 30px; }
        #mania-wrapper #countdown-text { font-size: 8em; font-weight: bold; text-shadow: 0 0 20px rgba(0,0,0,0.7); }
        #mania-wrapper .settings-item { margin-bottom: 20px; text-align: left; padding: 0 20px; width: 250px; }
        #mania-wrapper .settings-item label { display: block; margin-bottom: 10px; }
        #mania-wrapper .settings-item input[type="range"] { width: 100%; }
        #mania-wrapper .mod-select-container { display: flex; flex-wrap: wrap; gap: 8px; }
        #mania-wrapper .mod-button { padding: 8px 12px; font-size: 0.9em; font-weight: 500; color: var(--panel-text); background-color: #394362; border: 1px solid var(--panel-border); border-radius: 20px; cursor: pointer; transition: all 0.2s; user-select: none; }
        #mania-wrapper .mod-button.active { background-color: var(--accent-color); color: white; border-color: var(--accent-color); }
        #mania-wrapper .e2wrror-tick { position: absolute; top: -2px; width: 2px; height: 9px; background-color: white; transform: translateX(-50%); opacity: 0; animation: tick-fade 1s forwards; }
        @keyframes tick-fade { 0% { opacity: 1; } 100% { opacity: 0; } }

        /* --- osu!taiko Styles (Scoped) --- */
        #taiko-wrapper {
            --panel-bg: #1f2940;
            --panel-text: #e0e5f0;
            --panel-border: #4a5578;
            --accent-color: #d9534f;
            --disabled-color: #555c6f;
        }
        #taiko-wrapper #app-container { display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; }
        #taiko-wrapper #controls-panel { width: 95%; max-width: 880px; background-color: var(--panel-bg); border: 1px solid var(--panel-border); padding: 14px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); color: var(--panel-text); display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px 12px; align-items: start; }
        #taiko-wrapper #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; overflow: hidden; display: none; z-index: 10; }
        #taiko-wrapper #background-video { position: absolute; top: -7.2%; left: 50%; transform: translate(-50.01%, -50%); min-width: 213%; min-height: 100%; width: auto; height: auto; object-fit: cover; z-index: 1; opacity: 1; }
        #taiko-wrapper #background-image { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); min-width: 100%; min-height: 100%; width: auto; height: auto; object-fit: cover; z-index: 1; opacity: 1; }
        #taiko-wrapper #playfield { position: absolute; top: 50%; left: 0; right: 0; height: 180px; transform: translateY(calc(-50% - 58px)); background-color: rgba(18, 18, 18, 0.85); z-index: 10; box-shadow: 0 5px 25px rgba(0,0,0,0.3); border-radius: 0; }
        #taiko-wrapper #game-canvas { display: block; width: 100%; height: 100%; }
        #taiko-wrapper .grid-item-full { grid-column: 1 / -1; }
        #taiko-wrapper #controls-panel h2 { grid-column: 1 / -1; text-align: center; margin: 0 0 10px 0; font-size: 1.6em; font-weight: 600; color: var(--accent-color); }
        #taiko-wrapper #controls-panel label { font-size: 0.9em; font-weight: 500; color: #a0a8c0; margin-bottom: 8px; display: block; }
        #taiko-wrapper #controls-panel p { grid-column: 1 / -1; font-size: 0.8em; color: #828aa1; text-align: center; margin: 0; }
        #taiko-wrapper input[type="file"] { width: 0.1px; height: 0.1px; opacity: 0; overflow: hidden; position: absolute; z-index: -1; }
        #taiko-wrapper .file-input-label { display: inline-block; padding: 8px 15px; font-size: 0.9em; font-weight: 500; color: var(--panel-text); background-color: #394362; border: 1px solid var(--panel-border); border-radius: 6px; cursor: pointer; transition: background-color 0.2s; text-align: center;}
        #taiko-wrapper .file-input-label:hover { background-color: #4a5578; }
        #taiko-wrapper .file-input-label.is-loading { background-color: var(--disabled-color); cursor: not-allowed; }
        #taiko-wrapper #file-name { margin-left: 10px; font-size: 0.9em; color: #a0a8c0; }
        #taiko-wrapper input[type="range"] { -webkit-appearance: none; width: 100%; height: 6px; background: #2a344d; border-radius: 3px; outline: none; cursor: pointer; }
        #taiko-wrapper input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--accent-color); border-radius: 50%; cursor: pointer; }
        #taiko-wrapper input[type="number"], #taiko-wrapper #song-search-input { width: 100%; background-color: #2a344d; color: var(--panel-text); border: 1px solid var(--panel-border); border-radius: 6px; padding: 8px; text-align: center; font-size: 1em; box-sizing: border-box; }
        #taiko-wrapper #song-search-input { text-align: left; padding-left: 12px; margin-bottom: 8px; }
        #taiko-wrapper #key-config-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; }
        #taiko-wrapper .key-config-item { display: flex; flex-direction: column; }
        #taiko-wrapper .key-config-input { flex-grow: 1; height: 45px; background-color: #2a344d; border: 1px solid var(--panel-border); border-radius: 6px; color: var(--panel-text); font-size: 1.3em; font-weight: bold; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; user-select: none; }
        #taiko-wrapper .key-config-input:hover { background-color: #394362; }
        #taiko-wrapper .key-config-input.is-waiting { background-color: var(--accent-color); border-color: var(--accent-color); outline: none; color: white; }
        #taiko-wrapper .checkbox-wrapper { display: flex; align-items: center; cursor: pointer; margin-bottom: 5px; }
        #taiko-wrapper input[type="checkbox"] { display: none; }
        #taiko-wrapper .custom-checkbox { width: 20px; height: 20px; background-color: #2a344d; border: 1px solid var(--panel-border); border-radius: 4px; display: inline-block; position: relative; margin-right: 10px; transition: background-color 0.2s; flex-shrink: 0; }
        #taiko-wrapper input[type="checkbox"]:checked + .custom-checkbox { background-color: var(--accent-color); }
        #taiko-wrapper .custom-checkbox::after { content: ''; position: absolute; left: 6px; top: 2px; width: 5px; height: 10px; border: solid white; border-width: 0 3px 3px 0; transform: rotate(45deg); display: none; }
        #taiko-wrapper input[type="checkbox"]:checked + .custom-checkbox::after { display: block; }
        #taiko-wrapper .control-button, #taiko-wrapper select.control-button { width: 100%; padding: 12px; font-size: 1em; font-weight: 500; color: var(--panel-text); background-color: #394362; border: 1px solid var(--panel-border); border-radius: 8px; cursor: pointer; transition: background-color 0.2s; -webkit-appearance: none; text-align: center; }
        #taiko-wrapper select.control-button { text-align-last: center;}
        #taiko-wrapper .control-button:hover, #taiko-wrapper select.control-button:hover { background-color: #4a5578; }
        #taiko-wrapper #start-button { padding: 15px; font-size: 1.2em; font-weight: 600; color: white; background-color: var(--accent-color); border: none; }
        #taiko-wrapper #start-button:disabled, #taiko-wrapper #save-song-to-pc-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; color: #8c92a3; }
        #taiko-wrapper #saved-songs-group { grid-column: 1 / -1; }
        #taiko-wrapper #file-selection-group { grid-column: 1 / 4; }
        #taiko-wrapper #song-info-wrapper { grid-column: 4 / 7; }
        #taiko-wrapper #timing-settings-group { grid-column: 1 / -1; display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; }
        #taiko-wrapper #misc-settings-group { grid-column: 1 / 4; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        #taiko-wrapper #misc-settings-group .file-input-wrapper > div { display: flex; gap: 10px; }
        #taiko-wrapper #misc-settings-group .file-input-wrapper > div .file-input-label { flex: 1; }
        #taiko-wrapper #key-config-wrapper { grid-column: 4 / 7; }
        #taiko-wrapper #visual-settings-group { grid-column: 1 / -1; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; align-items: end; }
        #taiko-wrapper #buttons-group { grid-column: 1 / -1; display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        #taiko-wrapper #song-info { min-height: 80px; text-align: center; background: rgba(0,0,0,0.2); border-radius: 8px; padding: 10px; display: flex; flex-direction: column; justify-content: center; }
        #taiko-wrapper #ingame-pause-button { display: none; }
        #taiko-wrapper #ui-panel { position: absolute; top: 20px; right: 30px; color: white; z-index: 20; text-shadow: 0 0 8px rgba(0,0,0,0.8); text-align: right; font-weight: 600; }
        #taiko-wrapper #score { font-size: 2.5em; }
        #taiko-wrapper #accuracy { font-size: 1.5em; color: #FFD700; }
        #taiko-wrapper #combo-display { position: absolute; top: 49.3%; left: 180px; width: 120px; height: 120px; z-index: 20; font-weight: bold; color: white; text-shadow: 0 0 8px rgba(0,0,0,0.8); opacity: 0; transform: translate(-50%, calc(-50% - 58px)) scale(0.8); transition: opacity 0.2s, transform 0.2s; display: flex; align-items: center; justify-content: center; pointer-events: none; }
        #taiko-wrapper #combo-display.visible { opacity: 1; transform: translate(-50%, calc(-50% - 58px)) scale(1); }
        #taiko-wrapper #roll-counter-display { position: absolute; top: 50%; left: 390px; transform: translate(-50%, calc(-50% - 58px)); z-index: 21; color: white; font-size: 36px; font-weight: bold; text-shadow: 0 0 5px black, 0 0 5px black; opacity: 0; transition: opacity 0.1s linear; pointer-events: none; }
        #taiko-wrapper #roll-counter-display.visible { opacity: 1; }
        #taiko-wrapper #combo { font-size: 4.5em; line-height: 1; }
        #taiko-wrapper #combo-label { display: none; }
        #taiko-wrapper #judgment-text { position: absolute; top: calc(50% - 180px); left: 390px; transform: translateX(-50%); font-size: 2.5em; font-weight: bold; opacity: 0; z-index: 22; padding: 5px 20px; border-radius: 4px; color: white; text-align: center; text-shadow: 0 0 8px #000, 0 0 8px #000; animation: taiko-judgment-anim-new 0.4s ease-out; pointer-events: none; }
        @keyframes taiko-judgment-anim-new { 0% { transform: translateX(-50%) translateY(10px) scale(0.9); opacity: 0; } 25% { transform: translateX(-50%) translateY(0) scale(1.05); opacity: 1; } 80% { transform: translateX(-50%) translateY(0) scale(1); opacity: 1; } 100% { transform: translateX(-50%) translateY(0) scale(1); opacity: 0; } }
        #taiko-wrapper #progress-container { position: absolute; bottom: 30px; left: 50%; width: 40%; height: 8px; transform: translateX(-50%); background-color: rgba(0,0,0,0.4); border-radius: 4px; z-index: 20; overflow: hidden; }
        #taiko-wrapper #progress-bar { width: 0%; height: 100%; background-color: #4dabf7; border-radius: 4px; transition: width 0.1s linear; }
        #taiko-wrapper .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: white; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 200; }
        #taiko-wrapper .overlay-menu { text-align: center; padding: 30px 40px; background-color: var(--panel-bg); border-radius: 12px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #taiko-wrapper .overlay-menu h2 { font-size: 2.8em; margin-top: 0; margin-bottom: 30px; letter-spacing: 2px;}
        #taiko-wrapper .overlay-button { display: block; width: 220px; padding: 15px; margin: 12px auto; font-size: 1.2em; color: white; border: 2px solid var(--panel-border); background-color: #394362; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, transform 0.1s; }
        #taiko-wrapper .overlay-button:hover, #taiko-wrapper .overlay-button.selected { background-color: #4a5578; }
        #taiko-wrapper .overlay-button:active { transform: scale(0.98); }
        #taiko-wrapper #results-menu #results-song-title { font-size: 1.2em; color: #a0a8c0; margin-top: -20px; margin-bottom: 25px;}
        #taiko-wrapper #results-menu .results-main-stats { display: flex; justify-content: space-around; gap: 30px; margin-bottom: 30px; }
        #taiko-wrapper #results-menu .results-item { text-align: center; }
        #taiko-wrapper .results-item span:first-child { display: block; font-size: 1em; color: #a0a8c0; margin-bottom: 5px;}
        #taiko-wrapper .results-item span:last-child { font-size: 2em; font-weight: 600;}
        #taiko-wrapper #results-rank-value { font-size: 2.5em; color: #FFD700; }
        #taiko-wrapper #results-menu .results-judgments { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 30px; text-align: center; }
        #taiko-wrapper .judgment-item span:first-child { font-size: 1.2em; font-weight: bold;}
        #taiko-wrapper #results-ryo { color: gold; }
        #taiko-wrapper #results-ka { color: white; }
        #taiko-wrapper #results-fuka { color: #dda0dd; }
        #taiko-wrapper #drum-display { position: absolute; width: 120px; height: 120px; top: 50%; left: 120px; transform: translateY(calc(-50% - 58px)); z-index: 15; pointer-events: none; }
        #taiko-wrapper .drum-body { width: 100%; height: 100%; background-color: #d2b48c; border: 12px solid #a0522d; border-radius: 50%; box-sizing: border-box; position: absolute; }
        #taiko-wrapper .drum-hit-area { position: absolute; width: 100%; height: 100%; top: 0; left: 0; border-radius: 50%; box-sizing: border-box; opacity: 0; transition: opacity 0.1s linear; }
        #taiko-wrapper .drum-hit-area.active { opacity: 1; transition: none; }
        #taiko-wrapper #drum-don-left, #taiko-wrapper #drum-don-right { width: calc(100% - 24px); height: calc(100% - 24px); top: 12px; left: 12px; background-color: rgba(255, 77, 109, 0.8); }
        #taiko-wrapper #drum-don-left { clip-path: polygon(0% 0%, 50% 0%, 50% 100%, 0% 100%); }
        #taiko-wrapper #drum-don-right { clip-path: polygon(50% 0%, 100% 0%, 100% 100%, 50% 100%); }
        #taiko-wrapper #drum-katsu-left { border: 12px solid rgba(77, 171, 247, 0.9); clip-path: polygon(0% 0%, 50% 0%, 50% 100%, 0% 100%); }
        #taiko-wrapper #drum-katsu-right { border: 12px solid rgba(77, 171, 247, 0.9); clip-path: polygon(50% 0%, 100% 0%, 100% 100%, 50% 100%); }
    </style>
</head>
<body>

    <div id="game-selector">
        <h1>Select a Game</h1>
        <div>
            <button id="select-mania" class="game-select-button">Play Mania</button>
            <button id="select-taiko" class="game-select-button">Play Taiko</button>
        </div>
    </div>

    <!-- Container for osu!mania Game -->
    <div id="mania-wrapper" class="game-wrapper">
        <video id="video-background" loop muted playsinline></video>
        <img id="image-background" src="" alt="Background Image">
        <div id="app-container">
            <div id="controls-panel">
                <h2 class="grid-item-full">Mania Player</h2>
                <div class="panel-column">
                    <div>
                        <label for="beatmap-library-selector">1. 譜面ライブラリ (.osz, .mcz, .zip)</label>
                        <select id="beatmap-library-selector" size="8"></select>
                        <input type="file" id="mania-osz-file" accept=".osz,.zip,.mcz" multiple>
                    </div>
                    <div class="library-buttons">
                        <button id="add-beatmaps-button" class="control-button">追加</button>
                        <button id="remove-beatmap-button" class="control-button">削除</button>
                        <button id="save-osz-button" class="control-button">PCへ保存</button>
                    </div>
                    <div id="beatmap-selector-container" style="display: none;">
                        <label for="beatmap-selector">2. 難易度を選択</label>
                        <select id="beatmap-selector" class="styled-select"></select>
                    </div>
                     <div id="background-selector-container" style="display: none;">
                        <label for="background-selector">3. 背景を選択</label>
                        <select id="background-selector" class="styled-select"></select>
                    </div>
                </div>
                <div class="panel-column">
                    <div>
                        <label for="key-count-selector">キー数 (Key Count)</label>
                        <select id="key-count-selector" class="styled-select"></select>
                    </div>
                    <div>
                        <label>MOD</label>
                        <div id="mod-select-container" class="mod-select-container">
                            <div class="mod-button" data-mod="NF">No Fail</div>
                            <div class="mod-button" data-mod="HT">Half Time</div>
                            <div class="mod-button" data-mod="DT">Double Time</div>
                            <div class="mod-button" data-mod="HD">Hidden</div>
                        </div>
                    </div>
                    <div class="speed-control">
                        <label for="speed-slider" id="speed-label">ノーツ速度 (x1.5)</label>
                        <input type="range" id="speed-slider" min="0.5" max="4" value="1.5" step="0.1">
                    </div>
                    <div class="offset-controls-container">
                        <div class="offset-control">
                            <label for="offset-input">共通ノーツオフセット (ms)</label>
                            <input type="number" id="offset-input" value="0" step="5">
                        </div>
                        <div class="offset-control">
                            <label for="audio-offset-input">個別楽曲開始位置 (ms)</label>
                            <input type="number" id="audio-offset-input" value="0" step="5">
                        </div>
                    </div>
                    <div class="key-config-control">
                        <label>キー設定</label>
                        <div id="key-config-inputs"></div>
                    </div>
                     <div id="force-4k-container" style="display: none;">
                        <label for="force-4k-checkbox" class="checkbox-wrapper">
                            <input type="checkbox" id="force-4k-checkbox">
                            <span class="custom-checkbox"></span>
                            <span>中央4レーンのみプレイ</span>
                        </label>
                    </div>
                    <div class="assist-control">
                        <label>プレイアシスト</label>
                        <label for="auto-play-checkbox" class="checkbox-wrapper">
                            <input type="checkbox" id="auto-play-checkbox">
                            <span class="custom-checkbox"></span>
                            <span>オートプレイ</span>
                        </label>
                    </div>
                     <div class="settings-buttons">
                        <button id="open-settings-button" class="control-button">UI設定</button>
                        <button id="fullscreen-button" class="control-button">フルスクリーン</button>
                        <button id="switch-to-taiko-button" class="control-button">Taiko Playerへ</button>
                    </div>
                </div>
                <button id="start-button" class="grid-item-full" disabled>ゲーム開始</button>
                <div id="song-info" class="grid-item-full">
                    <div id="song-title">譜面を選択してください</div>
                    <div id="song-artist" style="font-size: 0.9em; color: #a0a8c0;"></div>
                </div>
                <p class="grid-item-full">※ 最大10K譜面対応 (長押し対応, Malody 4K譜面対応) / ESCキーまたはポーズボタンでポーズ</p>
            </div>
        </div>
        <div id="game-container" class="game-container">
            <div id="countdown-overlay" class="overlay" style="background-color: rgba(0,0,0,0.6);">
                <div id="countdown-text">3</div>
            </div>
            <button id="ingame-pause-button">||</button>
            <div id="ui-panel">
                <div id="score">0</div>
                <div id="accuracy">100.00%</div>
            </div>
            <div id="judgment-timing-text"></div>
            <div id="judgment-text"></div>
            <div id="playfield">
                <div id="playfield-background"></div>
                <div id="combo-container">
                    <div id="combo-count">0</div>
                    <div id="combo-label">COMBO</div>
                </div>
                <div id="lanes-container"></div>
                <div id="judgment-line"></div>
                <div id="error-bar-container"><div id="error-bar"></div></div>
                <div id="key-indicators"></div>
            </div>
        </div>
        <div id="pause-overlay" class="overlay">
            <div id="pause-menu" class="overlay-menu">
                <h2>PAUSED</h2>
                <button id="resume-button" class="overlay-button">再開 (Resume)</button>
                <button id="retry-button" class="overlay-button">やり直し (Retry)</button>
                <button id="back-to-menu-button" class="overlay-button">メニューに戻る (Menu)</button>
            </div>
        </div>
        <div id="results-overlay" class="overlay">
            <div id="results-menu" class="overlay-menu">
                <h2>RESULTS</h2>
                <div class="results-item" style="font-size: 1.8em; margin-bottom: 20px;"><span>SCORE: </span><span id="results-score-value">0</span></div>
                <div id="results-accuracy-container">ACCURACY: <span id="results-accuracy-value">0.00</span>%</div>
                <div class="results-grid">
                    <div class="results-item" style="grid-column: 1 / -1;"><span>MAX COMBO: </span><span id="results-max-combo-value">0</span></div>
                    <div class="results-item"><span>PERFECT: </span><span id="results-perfect-value">0</span></div>
                    <div class="results-item"><span>GREAT: </span><span id="results-great-value">0</span></div>
                    <div class="results-item"><span>GOOD: </span><span id="results-good-value">0</span></div>
                    <div class="results-item"><span>MISS: </span><span id="results-miss-value">0</span></div>
                </div>
                <button id="results-retry-button" class="overlay-button">やり直し (Retry)</button>
                <button id="results-menu-button" class="overlay-button">メニューに戻る (Menu)</button>
            </div>
        </div>
        <div id="settings-overlay" class="overlay">
             <div class="overlay-menu">
                <h2>UI設定</h2>
                <div class="settings-item">
                    <label for="note-style-selector">ノーツのスタイル</label>
                    <select id="note-style-selector" class="styled-select">
                        <option value="bar">バー</option>
                        <option value="circle">サークル</option>
                    </select>
                </div>
                <div class="settings-item">
                    <label for="background-brightness-slider">背景の明るさ: <span id="brightness-value">50</span>%</label>
                    <input type="range" id="background-brightness-slider" min="0" max="100" value="50">
                </div>
                <div class="settings-item">
                    <label for="lane-opacity-slider" id="lane-opacity-label">レーンの不透明度: <span id="lane-opacity-value">50</span>%</label>
                    <input type="range" id="lane-opacity-slider" min="0" max="100" value="50">
                </div>
                <div class="settings-item">
                    <label for="combo-size-slider">コンボの大きさ: <span id="combo-size-value">100</span>%</label>
                    <input type="range" id="combo-size-slider" min="50" max="150" value="100">
                </div>
                <div class="settings-item">
                    <label for="combo-position-slider">コンボのY位置: <span id="combo-position-value">45</span>%</label>
                    <input type="range" id="combo-position-slider" min="20" max="80" value="45">
                </div>
                <div class="settings-item">
                    <label for="judgment-position-slider">判定文字のY位置: <span id="judgment-position-value">65</span>%</label>
                    <input type="range" id="judgment-position-slider" min="20" max="85" value="65">
                </div>
                <button class="overlay-button">閉じる</button>
             </div>
        </div>
    </div>
    
    <!-- Container for osu!taiko Game -->
    <div id="taiko-wrapper" class="game-wrapper">
        <div id="app-container">
            <div id="controls-panel">
                <h2>Taiko Player</h2>
                <div id="saved-songs-group" class="grid-item-full">
                    <label for="saved-songs-list">保存済み譜面</label>
                    <input type="text" id="song-search-input" class="control-button" placeholder="曲を検索...">
                    <div style="display: flex; gap: 10px;">
                        <select id="saved-songs-list" class="control-button" style="flex-grow: 1;"></select>
                        <button id="delete-song-button" class="control-button" style="flex-basis: 120px; background-color: #8c3b38;">削除</button>
                    </div>
                </div>
                <div id="file-selection-group">
                    <label>新規譜面を追加 (.osz)</label>
                    <div style="display: flex; align-items: center;">
                        <label for="taiko-osz-file" id="osz-file-label" class="file-input-label">ファイルを選択</label>
                        <span id="file-name" style="flex-grow: 1; text-align: right;"></span>
                    </div>
                     <div id="beatmap-selector-container" class="grid-item-full" style="display: none; margin-top: 15px;">
                        <label for="beatmap-selector">難易度を選択</label>
                        <select id="beatmap-selector" class="control-button"></select>
                    </div>
                </div>
                <input type="file" id="taiko-osz-file" accept=".osz" multiple>
                <div id="song-info-wrapper">
                     <label>曲情報</label>
                     <div id="song-info">
                        <div id="song-title">譜面を選択してください</div>
                        <div id="song-artist" style="font-size: 0.9em; color: #a0a8c0;"></div>
                    </div>
                </div>
                <div id="timing-settings-group">
                    <div class="speed-control">
                        <label for="speed-slider" id="speed-label">スクロール速度 (x1.0)</label>
                        <input type="range" id="speed-slider" min="-5" max="5" value="0" step="0.1">
                    </div>
                    <div class="offset-control">
                        <label for="offset-input">譜面オフセット (ms)</label>
                        <input type="number" id="offset-input" value="0" step="0.5">
                    </div>
                    <div class="offset-control">
                        <label for="video-offset-input">動画オフセット (ms)</label>
                        <input type="number" id="video-offset-input" value="0" step="5">
                    </div>
                    <div class="offset-control">
                        <label for="se-offset-input">SEオフセット (ms)</label>
                        <input type="number" id="se-offset-input" value="0" step="5" title="音が遅れて聞こえる場合、-50のようにマイナスの値を入力して調整してください。">
                    </div>
                </div>
                <div id="misc-settings-group">
                     <div class="assist-control">
                        <label>プレイアシスト</label>
                        <label for="auto-play-checkbox" class="checkbox-wrapper">
                            <input type="checkbox" id="auto-play-checkbox">
                            <span class="custom-checkbox"></span>
                            <span>オートプレイ</span>
                        </label>
                         <label for="single-hand-big-note-checkbox" class="checkbox-wrapper">
                            <input type="checkbox" id="single-hand-big-note-checkbox" checked>
                            <span class="custom-checkbox"></span>
                            <span>大音符を片手で処理</span>
                        </label>
                        <label for="auto-se-checkbox" class="checkbox-wrapper">
                            <input type="checkbox" id="auto-se-checkbox">
                            <span class="custom-checkbox"></span>
                            <span>自動SE</span>
                        </label>
                    </div>
                    <div class="file-input-wrapper">
                        <label>サウンド設定</label>
                         <div>
                            <label for="don-sound-file" class="file-input-label">ドン(SE)</label>
                            <input type="file" id="don-sound-file" accept="audio/*">
                            <label for="katsu-sound-file" class="file-input-label">カッ(SE)</label>
                            <input type="file" id="katsu-sound-file" accept="audio/*">
                        </div>
                    </div>
                </div>
                <div id="key-config-wrapper">
                    <label>キー設定</label>
                    <div id="key-config-inputs">
                         <div class="key-config-item">
                            <label>ドン (左)</label>
                            <div id="key-don-left" class="key-config-input" data-key-id="don_left" tabindex="0">D</div>
                        </div>
                        <div class="key-config-item">
                            <label>ドン (右)</label>
                            <div id="key-don-right" class="key-config-input" data-key-id="don_right" tabindex="0">K</div>
                        </div>
                        <div class="key-config-item">
                            <label>カッ (左)</label>
                            <div id="key-katsu-left" class="key-config-input" data-key-id="katsu_left" tabindex="0">S</div>
                        </div>
                        <div class="key-config-item">
                            <label>カッ (右)</label>
                            <div id="key-katsu-right" class="key-config-input" data-key-id="katsu_right" tabindex="0">L</div>
                        </div>
                    </div>
                </div>
                <div id="visual-settings-group">
                    <div>
                        <label for="lane-opacity-slider" id="lane-opacity-label">レーン不透明度 (85%)</label>
                        <input type="range" id="lane-opacity-slider" min="0" max="1" value="0.85" step="0.01">
                    </div>
                    <div>
                        <label for="bg-brightness-slider" id="bg-brightness-label">背景の明るさ (100%)</label>
                        <input type="range" id="bg-brightness-slider" min="0.1" max="2.5" value="1" step="0.05">
                    </div>
                    <div id="background-select-wrapper" style="display: none;">
                        <label for="background-select">背景</label>
                        <select id="background-select" class="control-button"></select>
                    </div>
                </div>
                <div id="buttons-group">
                    <button id="save-settings-button" class="control-button">設定を保存</button>
                    <button id="save-song-to-pc-button" class="control-button" disabled>PCへ保存</button>
                    <button id="start-button" disabled>ゲーム開始</button>
                </div>
                <button id="switch-to-mania-button" class="control-button grid-item-full">Mania Playerへ</button>
                <p>※ ESCキーでポーズ</p>
            </div>
        </div>
        <div id="game-container" class="game-container">
            <video id="background-video" muted loop playsinline></video>
            <img id="background-image" />
            <button id="ingame-pause-button">||</button>
            <div id="ui-panel">
                <div id="score">0</div>
                <div id="accuracy">100.00%</div>
            </div>
            <div id="combo-display">
                <span id="combo">0</span><span id="combo-label">x</span>
            </div>
            <div id="roll-counter-display"></div>
            <div id="judgment-text"></div>
            <div id="drum-display">
                <div class="drum-body"></div>
                <div id="drum-don-left" class="drum-hit-area"></div>
                <div id="drum-don-right" class="drum-hit-area"></div>
                <div id="drum-katsu-left" class="drum-hit-area"></div>
                <div id="drum-katsu-right" class="drum-hit-area"></div>
            </div>
            <div id="playfield">
                <canvas id="game-canvas"></canvas>
            </div>
            <div id="progress-container">
                <div id="progress-bar"></div>
            </div>
        </div>
        <div id="pause-overlay" class="overlay">
            <div id="pause-menu" class="overlay-menu">
                <h2>PAUSED</h2>
                <button id="resume-button" class="overlay-button">再開 (Resume)</button>
                <button id="retry-button" class="overlay-button">やり直し (Retry)</button>
                <button id="back-to-title-button-pause" class="overlay-button">タイトルへ戻る</button>
            </div>
        </div>
        <div id="results-overlay" class="overlay">
            <div id="results-menu" class="overlay-menu">
                <h2>RESULTS</h2>
                <div id="results-song-title">Song Title</div>
                 <div class="results-main-stats">
                    <div class="results-item">
                        <span>SCORE</span>
                        <span id="results-score-value">0</span>
                    </div>
                    <div class="results-item">
                        <span>RANK</span>
                        <span id="results-rank-value">S</span>
                    </div>
                    <div class="results-item">
                        <span>MAX COMBO</span>
                        <span id="results-max-combo-value">0</span>
                    </div>
                </div>
                <div class="results-judgments">
                    <div class="judgment-item" id="results-ryo">
                        <span>良 (PERFECT)</span>
                        <span id="results-ryo-value">0</span>
                    </div>
                     <div class="judgment-item" id="results-ka">
                        <span>可 (GREAT)</span>
                        <span id="results-ka-value">0</span>
                    </div>
                     <div class="judgment-item" id="results-fuka">
                        <span>不可 (MISS)</span>
                        <span id="results-fuka-value">0</span>
                    </div>
                </div>
                <button id="results-retry-button" class="overlay-button">やり直し (Retry)</button>
                <button id="back-to-title-button-results" class="overlay-button">タイトルへ戻る</button>
            </div>
        </div>
        <audio id="audio-player"></audio>
    </div>

    <script>
    // --- Global Controller ---
    let activeGame = null;
    let maniaInitialized = false;
    let taikoInitialized = false;

    function switchToMania() {
        document.getElementById('game-selector').style.display = 'none';
        document.getElementById('taiko-wrapper').style.display = 'none';
        document.getElementById('mania-wrapper').style.display = 'block';
        activeGame = 'mania';
        if (!maniaInitialized) {
            ManiaGame.initialize();
            maniaInitialized = true;
        }
    }

    function switchToTaiko() {
        document.getElementById('game-selector').style.display = 'none';
        document.getElementById('mania-wrapper').style.display = 'none';
        document.getElementById('taiko-wrapper').style.display = 'block';
        activeGame = 'taiko';
        if (!taikoInitialized) {
            TaikoGame.initialize();
            taikoInitialized = true;
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const selectManiaBtn = document.getElementById('select-mania');
        const selectTaikoBtn = document.getElementById('select-taiko');

        selectManiaBtn.addEventListener('click', switchToMania);
        selectTaikoBtn.addEventListener('click', switchToTaiko);
    });

    // --- osu!mania Game Logic (Scoped) ---
    const ManiaGame = (() => {
        const root = document.getElementById('mania-wrapper');

        const dom = {
            appContainer: root.querySelector('#app-container'),
            gameContainer: root.querySelector('#game-container'),
            controlsPanel: root.querySelector('#controls-panel'),
            playfield: root.querySelector('#playfield'),
            playfieldBackground: root.querySelector('#playfield-background'),
            lanesContainer: root.querySelector('#lanes-container'),
            keyIndicatorsContainer: root.querySelector('#key-indicators'),
            scoreElement: root.querySelector('#score'),
            accuracyElement: root.querySelector('#accuracy'),
            judgmentTextElement: root.querySelector('#judgment-text'),
            judgmentTimingTextElement: root.querySelector('#judgment-timing-text'),
            startButton: root.querySelector('#start-button'),
            oszFileInput: root.querySelector('#mania-osz-file'),
            beatmapSelectorContainer: root.querySelector('#beatmap-selector-container'),
            beatmapSelector: root.querySelector('#beatmap-selector'),
            songTitleElement: root.querySelector('#song-title'),
            songArtistElement: root.querySelector('#song-artist'),
            offsetInput: root.querySelector('#offset-input'),
            audioOffsetInput: root.querySelector('#audio-offset-input'),
            speedSlider: root.querySelector('#speed-slider'),
            speedLabel: root.querySelector('#speed-label'),
            keyConfigInputsContainer: root.querySelector('#key-config-inputs'),
            autoPlayCheckbox: root.querySelector('#auto-play-checkbox'),
            force4kContainer: root.querySelector('#force-4k-container'),
            force4kCheckbox: root.querySelector('#force-4k-checkbox'),
            pauseOverlay: root.querySelector('#pause-overlay'),
            resumeButton: root.querySelector('#resume-button'),
            retryButton: root.querySelector('#retry-button'),
            ingamePauseButton: root.querySelector('#ingame-pause-button'),
            resultsOverlay: root.querySelector('#results-overlay'),
            resultsScore: root.querySelector('#results-score-value'),
            resultsAccuracy: root.querySelector('#results-accuracy-value'),
            resultsMaxCombo: root.querySelector('#results-max-combo-value'),
            resultsPerfect: root.querySelector('#results-perfect-value'),
            resultsGreat: root.querySelector('#results-great-value'),
            resultsGood: root.querySelector('#results-good-value'),
            resultsMiss: root.querySelector('#results-miss-value'),
            resultsRetryButton: root.querySelector('#results-retry-button'),
            resultsMenuButton: root.querySelector('#results-menu-button'),
            openSettingsButton: root.querySelector('#open-settings-button'),
            settingsOverlay: root.querySelector('#settings-overlay'),
            fullscreenButton: root.querySelector('#fullscreen-button'),
            beatmapLibrarySelector: root.querySelector('#beatmap-library-selector'),
            addBeatmapsButton: root.querySelector('#add-beatmaps-button'),
            removeBeatmapButton: root.querySelector('#remove-beatmap-button'),
            saveOszButton: root.querySelector('#save-osz-button'),
            countdownOverlay: root.querySelector('#countdown-overlay'),
            countdownText: root.querySelector('#countdown-text'),
            videoBackground: root.querySelector('#video-background'),
            imageBackground: root.querySelector('#image-background'),
            backgroundSelectorContainer: root.querySelector('#background-selector-container'),
            backgroundSelector: root.querySelector('#background-selector'),
            comboContainer: root.querySelector('#combo-container'),
            comboCount: root.querySelector('#combo-count'),
            noteStyleSelector: root.querySelector('#note-style-selector'),
            backgroundBrightnessSlider: root.querySelector('#background-brightness-slider'),
            brightnessValue: root.querySelector('#brightness-value'),
            laneOpacitySlider: root.querySelector('#lane-opacity-slider'),
            laneOpacityLabel: root.querySelector('#lane-opacity-label'),
            laneOpacityValue: root.querySelector('#lane-opacity-value'),
            comboSizeSlider: root.querySelector('#combo-size-slider'),
            comboSizeValue: root.querySelector('#combo-size-value'),
            comboPositionSlider: root.querySelector('#combo-position-slider'),
            comboPositionValue: root.querySelector('#combo-position-value'),
            judgmentPositionSlider: root.querySelector('#judgment-position-slider'),
            judgmentPositionValue: root.querySelector('#judgment-position-value'),
            backToMenuButton: root.querySelector('#back-to-menu-button'),
            switchToTaikoButton: root.querySelector('#switch-to-taiko-button'),
            modSelectContainer: root.querySelector('#mod-select-container'),
            errorBar: root.querySelector('#error-bar'),
            keyCountSelector: root.querySelector('#key-count-selector'),
        };
        if (dom.settingsOverlay) { const closeBtn = dom.settingsOverlay.querySelector('.overlay-button'); if (closeBtn) closeBtn.addEventListener('click', () => dom.settingsOverlay.style.display = 'none'); }
        if (dom.openSettingsButton) { dom.openSettingsButton.addEventListener('click', () => dom.settingsOverlay.style.display = 'flex'); }
        const NOTE_SPAWN_OFFSET_Y = 100;
        const AUDIO_START_DELAY_MS = 200;
        let keyConfigs = {};
        let activeKeys = [];
        let numLanes = 4;
        const getGameHeight = () => dom.gameContainer.clientHeight;
        const JUDGMENT_LINE_POS_VH = 15;
        const NOTE_HEIGHT = 22;
        const BASE_FALL_MS = 1200;
        const PERFECT_WINDOW = 40;
        const GREAT_WINDOW = 80;
        const GOOD_WINDOW = 120;
        const EARLY_LATE_THRESHOLD = 5;
        const TICK_SCORE_INTERVAL = 100;
        const TICK_SCORE_AMOUNT = 10;
        const LN_EARLY_RELEASE_PERFECT_WINDOW = 120;
        let score = 0, combo = 0, maxCombo = 0, accuracy = 100, totalJudgments = 0, weightedAccuracy = 0, gameEndTime = 0;
        let judgmentCounts = { PERFECT: 0, GREAT: 0, GOOD: 0, MISS: 0 };
        let isGameRunning = false, isPaused = false, isAutoPlay = false;
        let selectedPauseIndex = 0;
        let allNotes = [];
        let activeHolds = [];
        let beatmap = null;
        let audioLoaded = false;
        let animationFrameId = null;
        let currentOszFiles = { beatmaps: [], audio: {}, video: {}, image: {} };
        let db;
        let gameContext = { visualStartTime: 0, rate: 1.0 };
        let activeMods = { NF: false, HT: false, DT: false, HD: false };
        let currentBeatmapSetId = null;
        let currentBeatmapVersion = null;
        let audioContext;
        let audioBuffer;
        let audioSourceNode;
        let audioContextState = { startedAt: 0, pausedAt: 0, isReady: false };
        function generateDefaultKeyConfigs() { return { 4: ['D', 'F', 'J', 'K'], 5: ['D', 'F', ' ', 'J', 'K'], 6: ['S', 'D', 'F', 'J', 'K', 'L'], 7: ['S', 'D', 'F', ' ', 'J', 'K', 'L'], 8: ['A', 'S', 'D', 'F', 'J', 'K', 'L', ';'], 9: ['A', 'S', 'D', 'F', ' ', 'J', 'K', 'L', ';'], 10: ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';'] }; }
        function initDB() { return new Promise((resolve, reject) => { const request = indexedDB.open('maniaPlayerDB', 1); request.onerror = event => reject('Database error: ' + event.target.errorCode); request.onsuccess = event => { db = event.target.result; resolve(db); }; request.onupgradeneeded = event => { const db = event.target.result; db.createObjectStore('beatmaps', { keyPath: 'id', autoIncrement: true }); }; }); }
        async function addBeatmapsToDB(files) { if (!db) return; const transaction = db.transaction(['beatmaps'], 'readwrite'); const store = transaction.objectStore('beatmaps'); for (const file of files) { store.add({ name: file.name, file: file }); } transaction.oncomplete = () => loadBeatmapsFromDB(); transaction.onerror = (event) => console.error('Error adding beatmaps:', event.target.error); }
        async function loadBeatmapsFromDB() { if (!db) return; const transaction = db.transaction(['beatmaps'], 'readonly'); const store = transaction.objectStore('beatmaps'); const request = store.getAll(); request.onsuccess = () => { dom.beatmapLibrarySelector.innerHTML = ''; request.result.forEach(beatmapFile => { const option = new Option(beatmapFile.name, beatmapFile.id); dom.beatmapLibrarySelector.add(option); }); }; }
        async function removeBeatmapFromDB() { if (!db) return; const selectedId = parseInt(dom.beatmapLibrarySelector.value, 10); if (isNaN(selectedId)) { alert('削除する譜面を選択してください。'); return; } const transaction = db.transaction(['beatmaps'], 'readwrite'); const store = transaction.objectStore('beatmaps'); const request = store.delete(selectedId); request.onsuccess = () => { resetBeatmapSelection(); loadBeatmapsFromDB(); }; }
        async function getBeatmapFileFromDB(id) { return new Promise((resolve, reject) => { if (!db) return reject('DB not initialized'); const transaction = db.transaction(['beatmaps'], 'readonly'); const store = transaction.objectStore('beatmaps'); const request = store.get(id); request.onsuccess = () => resolve(request.result ? request.result.file : null); request.onerror = (event) => reject(event.target.error); }); }
        function parseBeatmap(text) { const lines = text.split('\n').map(l => l.trim()); const result = { title: '', artist: '', keyCount: 0, hitObjects: [], audioFilename: '', version: '', audioLeadIn: 0, videoFilename: '', videoOffset: 0 }; let currentSection = ''; for (const line of lines) { if (line.startsWith('[')) { currentSection = line; continue; } if (currentSection === '[General]') { if (line.startsWith('AudioFilename:')) result.audioFilename = line.substring(14).trim(); if (line.startsWith('AudioLeadIn:')) result.audioLeadIn = parseInt(line.substring(12).trim(), 10) || 0; } else if (currentSection === '[Events]') { if (line.startsWith('Video,')) { const parts = line.split(','); if (parts.length >= 3) { result.videoOffset = parseInt(parts[1], 10) || 0; result.videoFilename = parts[2].replace(/"/g, ''); } } } else if (currentSection === '[Metadata]') { if (line.startsWith('Title:')) result.title = line.substring(6).trim(); else if (line.startsWith('Artist:')) result.artist = line.substring(7).trim(); else if (line.startsWith('Version:')) result.version = line.substring(8).trim(); } else if (currentSection === '[Difficulty]' && line.startsWith('CircleSize:')) result.keyCount = parseInt(line.substring(11).trim(), 10); else if (currentSection === '[HitObjects]') { const parts = line.split(','); if (parts.length < 6) continue; const x = parseInt(parts[0], 10); const time = parseInt(parts[2], 10); const type = parseInt(parts[3], 10); const lane = Math.floor(x * result.keyCount / 512); if (lane < 0 || lane >= result.keyCount) continue; if (type & 128) { const endTime = parseInt(parts[5].split(':')[0], 10); result.hitObjects.push({ time, lane, type: 'long', endTime }); } else { result.hitObjects.push({ time, lane, type: 'note' }); } } } result.hitObjects.sort((a, b) => a.time - b.time); return result; }
        
        function parseMalodyBeatmap(text) {
            try {
                const data = JSON.parse(text);
                const mode_ext = data.meta.mode_ext || data.meta.meta_ext;
                if (!data.meta || data.meta.mode !== 0 || !mode_ext || mode_ext.column !== 4) {
                    alert('Malody譜面の読み込みに失敗しました。4キー(Key)モードの譜面のみ対応しています。');
                    return null;
                }
                const result = {
                    title: data.meta.title || 'Unknown Title',
                    artist: data.meta.artist || 'Unknown Artist',
                    version: data.meta.version || 'Unknown Difficulty',
                    keyCount: mode_ext.column,
                    hitObjects: [],
                    audioFilename: (data.meta.audio || '').trim(),
                    audioLeadIn: 0,
                    videoFilename: '',
                    videoOffset: 0,
                };
                const offset = data.meta.offset || 0;
                const BEATS_PER_MEASURE = 4;
                const timingPoints = (data.time || []).sort((a, b) => a.beat[0] - b.beat[0] || a.beat[1] - b.beat[1] || a.beat[2] - b.beat[2]);
                if (timingPoints.length === 0 || (timingPoints[0].beat[0] !== 0 || timingPoints[0].beat[1] !== 0)) {
                    timingPoints.unshift({ beat: [0, 0, 4], bpm: 120 });
                }
                let currentTimeMs = 0;
                let lastBeatPosition = 0;
                let lastBpm = timingPoints[0].bpm;
                for (const tp of timingPoints) {
                    const currentBeatPosition = tp.beat[0] + tp.beat[1] / tp.beat[2];
                    const beatDelta = (currentBeatPosition - lastBeatPosition) * BEATS_PER_MEASURE;
                    currentTimeMs += beatDelta * (60000 / lastBpm);
                    tp.timeMs = currentTimeMs;
                    lastBeatPosition = currentBeatPosition;
                    lastBpm = tp.bpm;
                }
                const beatToMs = (beatArray) => {
                    const [measure, numerator, denominator] = beatArray;
                    const noteBeatPosition = measure + numerator / denominator;
                    let targetTp = timingPoints[0];
                    for (let i = timingPoints.length - 1; i >= 0; i--) {
                        const tp = timingPoints[i];
                        const tpBeatPosition = tp.beat[0] + tp.beat[1] / tp.beat[2];
                        if (noteBeatPosition >= tpBeatPosition) {
                            targetTp = tp;
                            break;
                        }
                    }
                    const targetTpBeatPosition = targetTp.beat[0] + targetTp.beat[1] / targetTp.beat[2];
                    const beatDelta = (noteBeatPosition - targetTpBeatPosition) * BEATS_PER_MEASURE;
                    const msSinceTp = beatDelta * (60000 / targetTp.bpm);
                    return Math.round(targetTp.timeMs + msSinceTp + offset);
                };
                for (const note of (data.note || [])) {
                    if (note.column === undefined) continue;
                    const time = beatToMs(note.beat);
                    const lane = note.column;
                    if (note.endbeat) {
                        const endTime = beatToMs(note.endbeat);
                        result.hitObjects.push({ time, lane, type: 'long', endTime });
                    } else {
                        result.hitObjects.push({ time, lane, type: 'note' });
                    }
                }
                result.hitObjects.sort((a, b) => a.time - b.time);
                return result;
            } catch (e) {
                console.error("Malody beatmap parsing failed:", e);
                alert(`Malody譜面の解析に失敗しました: ${e.message}`);
                return null;
            }
        }

        function getBeatmapSettingsKey() { if (currentBeatmapSetId && currentBeatmapVersion) return `${currentBeatmapSetId}_${currentBeatmapVersion}`; return null; }
        function saveBeatmapSpecificSettings() { const key = getBeatmapSettingsKey(); if (!key) return; let settings = JSON.parse(localStorage.getItem('maniaPlayerBeatmapSettings')) || {}; settings[key] = { audioOffset: dom.audioOffsetInput.value, backgroundChoice: dom.backgroundSelector.value }; localStorage.setItem('maniaPlayerBeatmapSettings', JSON.stringify(settings)); }
        function loadBeatmapSpecificSettings() { const key = getBeatmapSettingsKey(); let audioOffset = 0; let backgroundChoice = 'auto'; if (key) { const settings = JSON.parse(localStorage.getItem('maniaPlayerBeatmapSettings')) || {}; const saved = settings[key]; if (typeof saved === 'object' && saved !== null) { audioOffset = saved.audioOffset || 0; backgroundChoice = saved.backgroundChoice || 'auto'; } } dom.audioOffsetInput.value = audioOffset; dom.backgroundSelector.value = backgroundChoice; }
        async function loadAudioWithWebAudioAPI(blobUrl) { audioLoaded = false; audioContextState.isReady = false; checkReadyState(); try { if (!audioContext) { audioContext = new (window.AudioContext || window.webkitAudioContext)(); } const response = await fetch(blobUrl); const arrayBuffer = await response.arrayBuffer(); audioBuffer = await audioContext.decodeAudioData(arrayBuffer); audioLoaded = true; audioContextState.isReady = true; } catch (e) { console.error("Web Audio APIでの音声デコードに失敗:", e); alert("音声ファイルの読み込みに失敗しました。Web Audio APIがサポートされていないか、ファイルが破損している可能性があります。"); audioLoaded = false; } finally { checkReadyState(); } }
        function setupFileListeners() { dom.addBeatmapsButton.addEventListener('click', () => dom.oszFileInput.click()); dom.oszFileInput.addEventListener('change', (e) => addBeatmapsToDB(e.target.files)); dom.removeBeatmapButton.addEventListener('click', removeBeatmapFromDB); dom.beatmapLibrarySelector.addEventListener('change', handleLibrarySelection); dom.beatmapSelector.addEventListener('change', handleDifficultySelection); }
        async function handleLibrarySelection() { const selectedId = parseInt(dom.beatmapLibrarySelector.value, 10); resetBeatmapSelection(); if (isNaN(selectedId)) return; currentBeatmapSetId = selectedId; try { const file = await getBeatmapFileFromDB(selectedId); if (!file) throw new Error('File not found in DB.'); dom.songTitleElement.textContent = '読み込み中...'; const jszip = new JSZip(); const zip = await jszip.loadAsync(file); currentOszFiles = { beatmaps: [], audio: {}, video: {}, image: {} }; const filePromises = []; zip.forEach((relativePath, zipEntry) => { const lowerCasePath = relativePath.toLowerCase(); if (lowerCasePath.endsWith('.osu')) { filePromises.push(zipEntry.async('string').then(content => currentOszFiles.beatmaps.push({ name: relativePath, content, type: 'osu' }))); } else if (lowerCasePath.endsWith('.mc')) { filePromises.push(zipEntry.async('string').then(content => currentOszFiles.beatmaps.push({ name: relativePath, content, type: 'malody' }))); } else if (lowerCasePath.endsWith('.mp3') || lowerCasePath.endsWith('.ogg')) { filePromises.push(zipEntry.async('blob').then(blob => currentOszFiles.audio[zipEntry.name] = URL.createObjectURL(blob))); } else if (lowerCasePath.endsWith('.mp4') || lowerCasePath.endsWith('.webm')) { filePromises.push(zipEntry.async('blob').then(blob => currentOszFiles.video[Object.keys(currentOszFiles.video).length] = URL.createObjectURL(blob))); } else if (lowerCasePath.endsWith('.jpg') || lowerCasePath.endsWith('.jpeg') || lowerCasePath.endsWith('.png')) { filePromises.push(zipEntry.async('blob').then(blob => currentOszFiles.image[Object.keys(currentOszFiles.image).length] = URL.createObjectURL(blob))); } }); await Promise.all(filePromises); if (currentOszFiles.beatmaps.length === 0) throw new Error('譜面ファイル (.osu or .mc) が見つかりません。'); dom.beatmapSelector.innerHTML = '<option value="">-- 難易度を選択 --</option>'; currentOszFiles.beatmaps.forEach((beatmapFile, index) => { let optionText = beatmapFile.name; try { if (beatmapFile.type === 'osu') { const tempBeatmap = parseBeatmap(beatmapFile.content); optionText = `${tempBeatmap.version || beatmapFile.name} [${tempBeatmap.keyCount}K]`; } else if (beatmapFile.type === 'malody') { const data = JSON.parse(beatmapFile.content); const mode_ext = data.meta.mode_ext || data.meta.meta_ext; if (data.meta && data.meta.mode === 0 && mode_ext) { const keyCount = mode_ext.column || '?'; const version = data.meta.version || beatmapFile.name; optionText = `${version} [${keyCount}K Malody]`; } } } catch(e) { /* ignore parse errors for preview */ } const option = new Option(optionText, index); dom.beatmapSelector.appendChild(option); }); dom.beatmapSelectorContainer.style.display = 'block'; const firstBeatmapFile = currentOszFiles.beatmaps[0]; let firstBeatmap; if (firstBeatmapFile.type === 'malody') { try { const data = JSON.parse(firstBeatmapFile.content); firstBeatmap = { title: data.meta.title, artist: data.meta.artist }; } catch(e) { firstBeatmap = { title: 'Invalid Malody Chart', artist: '' }; } } else { firstBeatmap = parseBeatmap(firstBeatmapFile.content); } dom.songTitleElement.textContent = firstBeatmap.title || '難易度を選択してください'; dom.songArtistElement.textContent = firstBeatmap.artist || ''; dom.saveOszButton.disabled = false; } catch (err) { alert('譜面の読み込みに失敗しました: ' + err.message); resetBeatmapSelection(); } }
        function handleDifficultySelection() {
            const selectedIndex = dom.beatmapSelector.value;
            beatmap = null;
            audioLoaded = false;
            currentBeatmapVersion = null;
            checkReadyState();
            dom.backgroundSelectorContainer.style.display = 'none';
            dom.force4kContainer.style.display = 'none';
            dom.force4kCheckbox.checked = false;
            applyBackgroundChoice();
            if (selectedIndex === "") { return; }
            const selectedBeatmapFile = currentOszFiles.beatmaps[parseInt(selectedIndex, 10)];
            if (!selectedBeatmapFile) return;

            try {
                if (selectedBeatmapFile.type === 'malody') {
                    beatmap = parseMalodyBeatmap(selectedBeatmapFile.content);
                } else {
                    beatmap = parseBeatmap(selectedBeatmapFile.content);
                }
                if (!beatmap) { return; }
                if (beatmap.keyCount > 4) {
                    dom.force4kContainer.style.display = 'block';
                }
                setKeyCount(beatmap.keyCount);
                dom.keyCountSelector.value = beatmap.keyCount;
                dom.keyCountSelector.disabled = true;
                currentBeatmapVersion = beatmap.version;
                updateBackgroundSelector();
                loadBeatmapSpecificSettings();
                applyBackgroundChoice();
                dom.songTitleElement.textContent = beatmap.title || '（タイトル不明）';
                dom.songArtistElement.textContent = beatmap.artist || '（アーティスト不明）';

                let audioSrc = null;
                const audioFiles = Object.keys(currentOszFiles.audio);
                
                if (beatmap.audioFilename) {
                    const targetAudioPath = beatmap.audioFilename.replace(/\\/g, '/').toLowerCase();
                    
                    // Tier 1: Exact Match
                    for (const fullPath of audioFiles) {
                        if (fullPath.replace(/\\/g, '/').toLowerCase() === targetAudioPath) {
                            audioSrc = currentOszFiles.audio[fullPath];
                            break;
                        }
                    }

                    // Tier 2: Suffix Match
                    if (!audioSrc) {
                        for (const fullPath of audioFiles) {
                            if (fullPath.replace(/\\/g, '/').toLowerCase().endsWith(targetAudioPath)) {
                                audioSrc = currentOszFiles.audio[fullPath];
                                break;
                            }
                        }
                    }

                    // Tier 3: Filename Match (fallback)
                    if (!audioSrc) {
                        const targetBaseName = targetAudioPath.split('/').pop();
                        for (const fullPath of audioFiles) {
                            const zipBaseName = fullPath.replace(/\\/g, '/').toLowerCase().split('/').pop();
                            if (zipBaseName === targetBaseName) {
                                audioSrc = currentOszFiles.audio[fullPath];
                                break;
                            }
                        }
                    }
                }
                
                // Tier 4: The "Last Resort" Heuristic
                if (!audioSrc && audioFiles.length === 1) {
                    audioSrc = currentOszFiles.audio[audioFiles[0]];
                }

                if (audioSrc) {
                    loadAudioWithWebAudioAPI(audioSrc);
                } else {
                    alert(`音声ファイル "${beatmap.audioFilename || '指定なし'}" が見つかりません。`);
                }
            } catch (err) {
                alert('譜面ファイルの解析に失敗しました。');
                console.error(err);
            } finally {
                checkReadyState();
            }
        }
        function resetBeatmapSelection() { beatmap = null; audioLoaded = false; audioBuffer = null; currentOszFiles = { beatmaps: [], audio: {}, video: {}, image: {} }; dom.beatmapSelectorContainer.style.display = 'none'; dom.beatmapSelector.innerHTML = ''; dom.backgroundSelectorContainer.style.display = 'none'; dom.force4kContainer.style.display = 'none'; dom.force4kCheckbox.checked = false; applyBackgroundChoice(); dom.songTitleElement.textContent = '譜面を選択してください'; dom.songArtistElement.textContent = ''; dom.saveOszButton.disabled = true; currentBeatmapSetId = null; currentBeatmapVersion = null; dom.keyCountSelector.disabled = false; loadBeatmapSpecificSettings(); checkReadyState(); }
        function updateBackgroundSelector() { const hasVideo = Object.keys(currentOszFiles.video).length > 0; const hasImage = Object.keys(currentOszFiles.image).length > 0; dom.backgroundSelector.innerHTML = ''; if(hasVideo || hasImage) { dom.backgroundSelector.add(new Option('自動', 'auto')); if(hasVideo) dom.backgroundSelector.add(new Option('動画', 'video')); if(hasImage) dom.backgroundSelector.add(new Option('画像', 'image')); dom.backgroundSelector.add(new Option('なし', 'none')); dom.backgroundSelectorContainer.style.display = 'block'; } else { dom.backgroundSelectorContainer.style.display = 'none'; } }
        function applyBackgroundChoice() { const choice = dom.backgroundSelector.value; const videoURL = Object.values(currentOszFiles.video)[0]; const imageURL = Object.values(currentOszFiles.image)[0]; dom.videoBackground.style.display = 'none'; dom.imageBackground.style.display = 'none'; let show = choice; if (choice === 'auto') { if (videoURL) show = 'video'; else if (imageURL) show = 'image'; else show = 'none'; } if (show === 'video' && videoURL) { dom.videoBackground.src = videoURL; dom.videoBackground.style.display = 'block'; } else if (show === 'image' && imageURL) { dom.imageBackground.src = imageURL; dom.imageBackground.style.display = 'block'; } }
        function checkReadyState() { dom.startButton.disabled = !(beatmap && audioLoaded); }
        function updateSpeed() { dom.speedLabel.textContent = `ノーツ速度 (x${parseFloat(dom.speedSlider.value).toFixed(1)})`; }
        function getFallMs() { return BASE_FALL_MS / parseFloat(dom.speedSlider.value); }
        function setKeyCount(count) { numLanes = parseInt(count, 10); root.style.setProperty('--num-lanes', numLanes); activeKeys = keyConfigs[numLanes]; initKeyConfig(); initGameUI(); }
        function initKeyConfig() { dom.keyConfigInputsContainer.innerHTML = ''; const currentKeys = keyConfigs[numLanes] || []; for (let i = 0; i < numLanes; i++) { const keyInput = document.createElement('div'); keyInput.className = 'key-config-input'; keyInput.textContent = currentKeys[i] || '...'; keyInput.dataset.laneIndex = i; keyInput.tabIndex = 0; keyInput.addEventListener('click', e => { if (isGameRunning) return; root.querySelectorAll('.key-config-input.is-waiting').forEach(el => el.blur()); e.currentTarget.textContent = '...'; e.currentTarget.classList.add('is-waiting'); }); keyInput.addEventListener('blur', e => { e.currentTarget.classList.remove('is-waiting'); e.currentTarget.textContent = keyConfigs[numLanes][e.currentTarget.dataset.laneIndex]; }); keyInput.addEventListener('keydown', e => { e.preventDefault(); if (!e.currentTarget.classList.contains('is-waiting')) return; if (e.key === 'Escape') { e.currentTarget.blur(); return; } const newKey = e.key.toUpperCase(); if (newKey.length !== 1 && newKey !== ' ') return; const index = parseInt(e.currentTarget.dataset.laneIndex, 10); if (keyConfigs[numLanes].some((key, k_idx) => key === newKey && k_idx !== index)) { alert('そのキーは他のレーンで既に使用されています。'); return; } keyConfigs[numLanes][index] = newKey; e.currentTarget.blur(); updateKeyIndicators(); saveSettings(); }); dom.keyConfigInputsContainer.appendChild(keyInput); } }
        function initGameUI() { dom.lanesContainer.innerHTML = ''; dom.keyIndicatorsContainer.innerHTML = ''; for (let i = 0; i < numLanes; i++) { const laneElement = document.createElement('div'); laneElement.classList.add('lane'); laneElement.dataset.laneIndex = i; dom.lanesContainer.appendChild(laneElement); laneElement.addEventListener('touchstart', e => { e.preventDefault(); if (!isGameRunning || isPaused || isAutoPlay) return; processHit(parseInt(e.currentTarget.dataset.laneIndex, 10)); }, { passive: false }); laneElement.addEventListener('touchend', e => { e.preventDefault(); if (!isGameRunning || isPaused || isAutoPlay) return; processRelease(parseInt(e.currentTarget.dataset.laneIndex, 10)); }); laneElement.addEventListener('touchcancel', e => { e.preventDefault(); if (!isGameRunning || isPaused || isAutoPlay) return; processRelease(parseInt(e.currentTarget.dataset.laneIndex, 10)); }); const keyIndicator = document.createElement('div'); keyIndicator.classList.add('key'); dom.keyIndicatorsContainer.appendChild(keyIndicator); } updateKeyIndicators(); }
        function updateKeyIndicators() { const currentKeys = keyConfigs[numLanes] || []; dom.keyConfigInputsContainer.childNodes.forEach((input, i) => { if (currentKeys[i]) input.textContent = currentKeys[i]; }); if(dom.keyIndicatorsContainer) { dom.keyIndicatorsContainer.childNodes.forEach((indicator, i) => { if (currentKeys[i]) indicator.textContent = currentKeys[i]; }); } }
        function resetGame() { score = 0; combo = 0; maxCombo = 0; accuracy = 100; totalJudgments = 0; weightedAccuracy = 0; judgmentCounts = { PERFECT: 0, GREAT: 0, GOOD: 0, MISS: 0 }; dom.scoreElement.textContent = score; dom.accuracyElement.textContent = '100.00%'; if(dom.errorBar) dom.errorBar.innerHTML = ''; if (animationFrameId) cancelAnimationFrame(animationFrameId); allNotes.forEach(note => { if (note.tickInterval) clearInterval(note.tickInterval); }); allNotes = []; activeHolds = Array(numLanes).fill(null); dom.lanesContainer.querySelectorAll('.note-wrapper').forEach(n => n.remove()); dom.keyIndicatorsContainer.childNodes.forEach(key => key.classList.remove('active')); dom.resultsOverlay.style.display = 'none'; isGameRunning = false; isPaused = false; dom.comboContainer.classList.remove('visible'); dom.comboCount.textContent = '0'; if (audioSourceNode) { audioSourceNode.stop(); audioSourceNode = null; } audioContextState.pausedAt = 0; audioContextState.startedAt = 0; }
        function createNoteElement(note) { const wrapper = document.createElement('div'); wrapper.className = 'note-wrapper'; const noteHead = document.createElement('div'); noteHead.className = 'note'; if (note.type === 'long') { const body = document.createElement('div'); body.className = 'long-note-body'; wrapper.appendChild(body); } wrapper.appendChild(noteHead); note.element = wrapper; }
        async function startGame() {
            if (isGameRunning || !beatmap || !audioLoaded) return;
            const originalKeyCount = beatmap.keyCount;
            const is4kConversion = dom.force4kCheckbox.checked && originalKeyCount > 4;

            resetGame();

            gameContext.rate = 1.0;
            if (activeMods.DT) gameContext.rate = 1.5;
            if (activeMods.HT) gameContext.rate = 0.75;
            const applyRate = (time) => Math.round(time / gameContext.rate);

            let notesToPlay = beatmap.hitObjects.map(obj => ({
                ...obj,
                time: applyRate(obj.time),
                endTime: obj.endTime ? applyRate(obj.endTime) : undefined,
                element: null, spawned: false, judged: false, hit: false, released: false
            }));

            if (is4kConversion) {
                const startLane = Math.floor((originalKeyCount - 4) / 2);
                const endLane = startLane + 4;
                notesToPlay = notesToPlay
                    .filter(note => note.lane >= startLane && note.lane < endLane)
                    .map(note => ({ ...note, lane: note.lane - startLane }));
                setKeyCount(4);
            } else {
                setKeyCount(originalKeyCount);
            }
            allNotes = notesToPlay;
            activeKeys = keyConfigs[numLanes];

            allNotes.forEach(note => {
                createNoteElement(note);
                note.element.classList.add('hidden');
                if (dom.lanesContainer.children[note.lane]) {
                    dom.lanesContainer.children[note.lane].appendChild(note.element);
                }
            });

            dom.appContainer.style.display = 'none';
            dom.gameContainer.style.display = 'block';
            
            // --- Warm-up phase to prevent initial stutter ---
            await new Promise(resolve => {
                let warmUpFrames = 30; // Number of frames to warm up
                const warmUpLoop = () => {
                    if (warmUpFrames <= 0) {
                        resolve();
                        return;
                    }
                    const fallMs = getFallMs();
                    const gameHeight = getGameHeight();
                    const judgmentLinePx = gameHeight * (JUDGMENT_LINE_POS_VH / 100);
                    const totalFallDistance = (gameHeight - judgmentLinePx) + NOTE_SPAWN_OFFSET_Y;
                    const pixelsPerMs = totalFallDistance / fallMs;
                    // Render notes at a position far before the start time
                    updateNotePositions(-5000, 0, pixelsPerMs, gameHeight, judgmentLinePx);
                    
                    warmUpFrames--;
                    requestAnimationFrame(warmUpLoop);
                };
                warmUpLoop();
            });
            // --- End of warm-up phase ---

            dom.countdownOverlay.style.display = 'flex'; 
            dom.gameContainer.classList.add('playing');
            for (let i = 3; i > 0; i--) {
                dom.countdownText.textContent = i;
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            dom.countdownText.textContent = 'START!';
            await new Promise(resolve => setTimeout(resolve, 500));
            dom.countdownOverlay.style.display = 'none';
            
            isGameRunning = true;
            isPaused = false;
            isAutoPlay = dom.autoPlayCheckbox.checked;
            const lastNote = allNotes.length > 0 ? allNotes[allNotes.length - 1] : { endTime: 0, time: 0 };
            gameEndTime = (lastNote.endTime || lastNote.time) + 3000;
            const visualPreRollMs = getFallMs();
            const totalDelayMs = visualPreRollMs + AUDIO_START_DELAY_MS;
            gameContext.visualStartTime = performance.now();
            const scheduledAudioStartTime = audioContext.currentTime + (totalDelayMs / 1000.0);
            playAudio(0, scheduledAudioStartTime);
            if (dom.videoBackground.style.display !== 'none') {
                setTimeout(() => { if (isGameRunning) dom.videoBackground.play(); }, totalDelayMs);
                dom.videoBackground.currentTime = 0;
                dom.videoBackground.playbackRate = gameContext.rate;
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        function playAudio(offsetSeconds = 0, startTime = 0) { if (!audioContextState.isReady || !audioBuffer) return; if (audioSourceNode) { audioSourceNode.stop(); } audioSourceNode = audioContext.createBufferSource(); audioSourceNode.buffer = audioBuffer; audioSourceNode.connect(audioContext.destination); audioSourceNode.playbackRate.value = gameContext.rate; const startOffset = Math.max(0, offsetSeconds); const scheduledStart = Math.max(audioContext.currentTime, startTime); audioContextState.startedAt = scheduledStart - startOffset; audioSourceNode.start(scheduledStart, startOffset); }
        function getCurrentBeatmapTime() { if (!isGameRunning) return -Infinity; if (isPaused) { return (audioContextState.pausedAt * 1000) - (applyRateToTime(beatmap.audioLeadIn) || 0) + (parseInt(dom.audioOffsetInput.value, 10) || 0); } if (audioContextState.startedAt > 0) { const elapsed = (audioContext.currentTime - audioContextState.startedAt) * 1000 * gameContext.rate; return elapsed - (beatmap.audioLeadIn || 0) + (parseInt(dom.audioOffsetInput.value, 10) || 0); } const visualElapsed = performance.now() - gameContext.visualStartTime; return (visualElapsed - (getFallMs() + AUDIO_START_DELAY_MS)) * gameContext.rate; }
        function applyRateToTime(time) { return time / gameContext.rate; }
        function gameLoop() { if (!isGameRunning) return; if (!isPaused) { const now = getCurrentBeatmapTime() / gameContext.rate; const noteUserOffset = parseInt(dom.offsetInput.value, 10) || 0; const fallMs = getFallMs(); const gameHeight = getGameHeight(); const judgmentLinePx = gameHeight * (JUDGMENT_LINE_POS_VH / 100); const totalFallDistance = (gameHeight - judgmentLinePx) + NOTE_SPAWN_OFFSET_Y; const pixelsPerMs = totalFallDistance / fallMs; updateNotePositions(now, noteUserOffset, pixelsPerMs, gameHeight, judgmentLinePx); if (isAutoPlay) autoPlayHandler(now, noteUserOffset); else checkMisses(now, noteUserOffset); if (now > gameEndTime) { isGameRunning = false; showResults(); } } animationFrameId = requestAnimationFrame(gameLoop); }
        function updateNotePositions(now, userOffset, pixelsPerMs, gameHeight, judgmentLinePx) { const isCircleStyle = dom.playfield.classList.contains('note-style-circle'); const noteHeightForOffset = isCircleStyle ? 70 : 22; const yOffset = noteHeightForOffset / 2; for (const note of allNotes) { if ((note.judged && note.type === 'note') || note.released) continue; const timeToHit = (note.time + userOffset) - now; let headY = (gameHeight - judgmentLinePx) - (timeToHit * pixelsPerMs); if (!note.spawned && headY > -noteHeightForOffset) { note.spawned = true; note.element.classList.remove('hidden'); } if (note.element) { if (activeMods.HD) { const fadeInEndPos = gameHeight * 0.40; const fadeOutStartPos = gameHeight * 0.75; if (headY > fadeInEndPos) { const fadeProgress = Math.max(0, Math.min(1, (headY - fadeInEndPos) / (fadeOutStartPos - fadeInEndPos))); note.element.style.opacity = 1 - fadeProgress; } else { note.element.style.opacity = 1; } } if (note.type === 'long' && note.hit) { headY = gameHeight - judgmentLinePx; if (note.element.querySelector('.note')) note.element.querySelector('.note').style.display = 'none'; } note.element.style.transform = `translateY(${headY - yOffset}px)`; if (note.type === 'long') { const body = note.element.querySelector('.long-note-body'); if (body) { const timeToRelease = (note.endTime + userOffset) - now; const tailY = (gameHeight - judgmentLinePx) - (timeToRelease * pixelsPerMs); const headHeight = noteHeightForOffset; const bodyTopOffset = headHeight / 2; body.style.top = `${tailY - headY}px`; body.style.height = `${Math.max(0, (headY + bodyTopOffset) - tailY)}px`; } } } if (headY > gameHeight + 50) { if (note.element) note.element.classList.add('hidden'); note.judged = true; note.released = true; } } }
        function autoPlayHandler(now, userOffset) { for (const note of allNotes) { if (!note.judged && now >= (note.time + userOffset)) handleHit('PERFECT', note, 0); if (note.type === 'long' && note.hit && !note.released && now >= (note.endTime + userOffset)) judgeRelease(note.lane, { isAutoCompletion: true }); } }
        function checkMisses(now, userOffset) { for (const note of allNotes) { if (!note.judged && now > (note.time + userOffset) + GOOD_WINDOW) handleHit('MISS', note, GOOD_WINDOW + 1); } for (let i = 0; i < activeHolds.length; i++) { const holdNote = activeHolds[i]; if (holdNote && now > (holdNote.endTime + userOffset)) judgeRelease(i, { isAutoCompletion: true }); } }
        function processHit(laneIndex) {
            if (laneIndex === -1 || laneIndex >= numLanes) return;
            dom.keyIndicatorsContainer.children[laneIndex].classList.add('active');

            const userOffset = parseInt(dom.offsetInput.value, 10) || 0;
            const now = getCurrentBeatmapTime() / gameContext.rate;
            
            let bestNote = null;
            let minDiff = Infinity;

            // allNotesは時間順にソートされている前提
            for (const note of allNotes) {
                if (note.lane === laneIndex && !note.judged) {
                    const diff = Math.abs(now - (note.time + userOffset));
                    
                    if (diff <= GOOD_WINDOW) {
                        if (diff < minDiff) {
                            bestNote = note;
                            minDiff = diff;
                        }
                    }
                    // 既に判定ウィンドウを過ぎた未来のノートに到達したら、それ以降を探す必要はない
                    if (note.time + userOffset > now + GOOD_WINDOW) {
                        break;
                    }
                }
            }

            if (bestNote) {
                const actualDiff = now - (bestNote.time + userOffset);
                let judgment;
                if (minDiff <= PERFECT_WINDOW) {
                    judgment = 'PERFECT';
                } else if (minDiff <= GREAT_WINDOW) {
                    judgment = 'GREAT';
                } else {
                    judgment = 'GOOD';
                }
                handleHit(judgment, bestNote, actualDiff);
            }
        }
        function processRelease(laneIndex) { if (laneIndex === -1 || laneIndex >= numLanes) return; dom.keyIndicatorsContainer.children[laneIndex].classList.remove('active'); judgeRelease(laneIndex); }
        document.addEventListener('keydown', e => { if(activeGame !== 'mania') return; if (e.repeat || e.key === 'Escape') return; if (!isGameRunning || isPaused || isAutoPlay) return; processHit(activeKeys.indexOf(e.key.toUpperCase())); });
        document.addEventListener('keyup', e => { if(activeGame !== 'mania') return; if (!isGameRunning || isPaused || isAutoPlay) return; processRelease(activeKeys.indexOf(e.key.toUpperCase())); });
        function judgeRelease(laneIndex, { isAutoCompletion = false } = {}) { const holdNote = activeHolds[laneIndex]; if (!holdNote) return; const cleanup = () => { clearInterval(holdNote.tickInterval); holdNote.tickInterval = null; activeHolds[laneIndex] = null; holdNote.released = true; if (holdNote.element) holdNote.element.classList.add('hidden'); dom.scoreElement.textContent = score; }; if (isAutoCompletion) { showJudgment('PERFECT'); updateAccuracy('PERFECT'); score += 300; judgmentCounts.PERFECT++; cleanup(); return; } const userOffset = parseInt(dom.offsetInput.value, 10) || 0; const now = getCurrentBeatmapTime() / gameContext.rate; const diff = now - (holdNote.endTime + userOffset); if (diff >= -LN_EARLY_RELEASE_PERFECT_WINDOW) { showJudgment('PERFECT'); updateAccuracy('PERFECT'); score += 300; judgmentCounts.PERFECT++; } else { combo = 0; dom.comboContainer.classList.remove('visible'); showJudgment('MISS'); updateAccuracy('MISS'); judgmentCounts.MISS++; } cleanup(); }
        function handleHit(judgment, note, diff) { if (note.judged) return; note.judged = true; judgmentCounts[judgment]++; updateAccuracy(judgment); if (judgment === 'MISS') { combo = 0; dom.comboContainer.classList.remove('visible'); } else { if (judgment === 'PERFECT') score += 300; else if (judgment === 'GREAT') score += 100; else if (judgment === 'GOOD') score += 50; combo++; note.hit = true; showHitError(diff); showJudgmentTiming(diff); } if (combo > maxCombo) maxCombo = combo; if (combo > 2) { dom.comboContainer.classList.add('visible'); dom.comboCount.textContent = combo; dom.comboCount.classList.remove('combo-anim'); void dom.comboCount.offsetWidth; dom.comboCount.classList.add('combo-anim'); } showJudgment(judgment); if (note.type === 'note') { if(note.element) note.element.classList.add('hidden'); } else if (note.type === 'long') { if (judgment !== 'MISS') { activeHolds[note.lane] = note; note.tickInterval = setInterval(() => { score += TICK_SCORE_AMOUNT; dom.scoreElement.textContent = score; }, TICK_SCORE_INTERVAL); } else { if(note.element) note.element.classList.add('hidden'); } } dom.scoreElement.textContent = score; }
        function updateAccuracy(judgment) { totalJudgments++; if (judgment === 'PERFECT') weightedAccuracy += 300; else if (judgment === 'GREAT') weightedAccuracy += 100; else if (judgment === 'GOOD') weightedAccuracy += 50; accuracy = (weightedAccuracy / (totalJudgments * 300)) * 100; dom.accuracyElement.textContent = accuracy.toFixed(2) + '%'; }
        function showHitError(diff) { if (!dom.errorBar) return; const tick = document.createElement('div'); tick.className = 'error-tick'; const percentage = (diff + GOOD_WINDOW) / (GOOD_WINDOW * 2) * 100; tick.style.left = `${Math.max(0, Math.min(100, percentage))}%`; if (Math.abs(diff) <= PERFECT_WINDOW) { tick.style.backgroundColor = '#4CAF50'; } else if (Math.abs(diff) <= GREAT_WINDOW) { tick.style.backgroundColor = '#FFC107'; } else { tick.style.backgroundColor = '#2196F3'; } dom.errorBar.appendChild(tick); setTimeout(() => tick.remove(), 1000); }
        function showJudgment(text) { const el = dom.judgmentTextElement; const judgmentStyles = { PERFECT: { bg: 'transparent', color: '#4CAF50' }, GREAT: { bg: 'transparent', color: '#FFC107' }, GOOD: { bg: 'transparent', color: '#2196F3' }, MISS: { bg: 'transparent', color: '#F44336' } }; const style = judgmentStyles[text] || { bg: 'transparent', color: 'white' }; el.textContent = text; el.style.backgroundColor = style.bg; el.style.color = style.color; el.style.animation = 'none'; el.offsetHeight; el.style.animation = null; }
        function showJudgmentTiming(diff) { const el = dom.judgmentTimingTextElement; let text = ''; if (diff < -EARLY_LATE_THRESHOLD) text = 'Early'; else if (diff > EARLY_LATE_THRESHOLD) text = 'Late'; el.textContent = text; el.style.animation = 'none'; el.offsetHeight; el.style.animation = null; }
        function updatePauseSelection() { const buttons = dom.pauseOverlay.querySelectorAll('.overlay-button'); buttons.forEach((btn, index) => { btn.classList.toggle('selected', index === selectedPauseIndex); }); }
        document.addEventListener('keydown', e => {
            if (activeGame !== 'mania') return;
            if (e.key === 'Escape') {
                togglePause();
                return;
            }
            if (isPaused) {
                const buttons = dom.pauseOverlay.querySelectorAll('.overlay-button');
                if (buttons.length === 0) return;
                
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedPauseIndex = (selectedPauseIndex - 1 + buttons.length) % buttons.length;
                    updatePauseSelection();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedPauseIndex = (selectedPauseIndex + 1) % buttons.length;
                    updatePauseSelection();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    buttons[selectedPauseIndex].click();
                }
            }
        });
        function togglePause() { if (!isGameRunning) return; isPaused = !isPaused; if (isPaused) { if (audioSourceNode) { audioSourceNode.stop(); audioSourceNode = null; } audioContextState.pausedAt = (audioContext.currentTime - audioContextState.startedAt); if(dom.videoBackground.style.display !== 'none') dom.videoBackground.pause(); dom.gameContainer.classList.remove('playing'); dom.pauseOverlay.style.display = 'flex'; selectedPauseIndex = 0; updatePauseSelection(); } else { playAudio(audioContextState.pausedAt, 0); if(dom.videoBackground.style.display !== 'none') dom.videoBackground.play(); dom.gameContainer.classList.add('playing'); dom.pauseOverlay.style.display = 'none'; } }
        function retryGame() { if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; isGameRunning = false; isPaused = false; if(dom.videoBackground.src) { dom.videoBackground.pause(); dom.videoBackground.currentTime = 0; } dom.pauseOverlay.style.display = 'none'; dom.resultsOverlay.style.display = 'none'; startGame(); }
        function returnToControls() {
            isGameRunning = false;
            isPaused = false;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            if(dom.videoBackground.src) {
                dom.videoBackground.pause();
                dom.videoBackground.currentTime = 0;
            }
            dom.pauseOverlay.style.display = 'none';
            dom.resultsOverlay.style.display = 'none';
            dom.gameContainer.classList.remove('playing');
            dom.gameContainer.style.display = 'none';
            dom.appContainer.style.display = 'flex';
            resetGame();
        }
        function showResults() { dom.resultsScore.textContent = score; dom.resultsAccuracy.textContent = accuracy.toFixed(2); dom.resultsMaxCombo.textContent = maxCombo; dom.resultsPerfect.textContent = judgmentCounts.PERFECT; dom.resultsGreat.textContent = judgmentCounts.GREAT; dom.resultsGood.textContent = judgmentCounts.GOOD; dom.resultsMiss.textContent = judgmentCounts.MISS; dom.resultsOverlay.style.display = 'flex'; dom.gameContainer.classList.remove('playing'); }
        function toggleFullscreen() { const docEl = document.documentElement; const requestFullscreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullscreen || docEl.msRequestFullscreen; const exitFullscreen = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen; const isFullscreen = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement; if (!isFullscreen) { if (requestFullscreen) requestFullscreen.call(document.body); } else { if (exitFullscreen) exitFullscreen.call(document); } }
        async function saveOszFileToPC() { const selectedId = parseInt(dom.beatmapLibrarySelector.value, 10); if (isNaN(selectedId)) { alert('保存する譜面をライブラリから選択してください。'); return; } try { const file = await getBeatmapFileFromDB(selectedId); if (!file) throw new Error('File not found in DB.'); const url = URL.createObjectURL(file); const a = document.createElement('a'); a.style.display = 'none'; a.href = url; a.download = file.name; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); } catch (err) { alert('ファイルの保存に失敗しました。'); console.error('Failed to save .osz file:', err); } }
        function setupMods() { dom.modSelectContainer.addEventListener('click', (e) => { const button = e.target.closest('.mod-button'); if (!button) return; const mod = button.dataset.mod; activeMods[mod] = !activeMods[mod]; button.classList.toggle('active', activeMods[mod]); if (mod === 'HT' && activeMods.HT) { activeMods.DT = false; dom.modSelectContainer.querySelector('[data-mod="DT"]').classList.remove('active'); } if (mod === 'DT' && activeMods.DT) { activeMods.HT = false; dom.modSelectContainer.querySelector('[data-mod="HT"]').classList.remove('active'); } saveSettings(); }); }
        function applyBrightness(value) { root.style.setProperty('--background-brightness', value / 100); if (dom.brightnessValue) dom.brightnessValue.textContent = value; }
        function applyLaneOpacity(value) { if (dom.noteStyleSelector.value === 'circle') { root.style.setProperty('--playfield-bg-opacity', value / 100); } else { root.style.setProperty('--lane-opacity', value / 100); } if (dom.laneOpacityValue) dom.laneOpacityValue.textContent = value; }
        function updateOpacitySliderLabel() { const labelText = (dom.noteStyleSelector.value === 'circle') ? 'プレイエリアの不透明度: ' : 'レーンの不透明度: '; dom.laneOpacityLabel.firstChild.textContent = labelText; }
        function applyComboSize(value) { root.style.setProperty('--combo-size-scale', value / 100); if (dom.comboSizeValue) dom.comboSizeValue.textContent = value; }
        function applyComboPositionY(value) { root.style.setProperty('--combo-position-y', value + '%'); if (dom.comboPositionValue) dom.comboPositionValue.textContent = value; }
        function applyJudgmentPositionY(value) { root.style.setProperty('--judgment-text-top', value + 'vh'); if (dom.judgmentPositionValue) dom.judgmentPositionValue.textContent = value; }
        function applyNoteStyle(style) { dom.playfield.classList.toggle('note-style-circle', style === 'circle'); updateOpacitySliderLabel(); applyLaneOpacity(dom.laneOpacitySlider.value); }
        function saveSettings() { const settings = { speed: dom.speedSlider.value, offset: dom.offsetInput.value, autoPlay: dom.autoPlayCheckbox.checked, force4k: dom.force4kCheckbox.checked, keyConfigs: keyConfigs, mods: activeMods, noteStyle: dom.noteStyleSelector.value, brightness: dom.backgroundBrightnessSlider.value, laneOpacity: dom.laneOpacitySlider.value, comboSize: dom.comboSizeSlider.value, comboPosition: dom.comboPositionSlider.value, judgmentPosition: dom.judgmentPositionSlider.value, keyCount: numLanes }; localStorage.setItem('maniaPlayerSettings', JSON.stringify(settings)); }
        function loadSettings() { const savedSettings = localStorage.getItem('maniaPlayerSettings'); const defaultConfigs = generateDefaultKeyConfigs(); if (savedSettings) { const settings = JSON.parse(savedSettings); dom.speedSlider.value = settings.speed || 1.5; dom.offsetInput.value = settings.offset || 0; dom.autoPlayCheckbox.checked = settings.autoPlay || false; dom.force4kCheckbox.checked = settings.force4k || false; keyConfigs = { ...defaultConfigs, ...settings.keyConfigs }; if(settings.mods) { activeMods = settings.mods; Object.keys(activeMods).forEach(modKey => { const button = dom.modSelectContainer.querySelector(`[data-mod="${modKey}"]`); if (button) button.classList.toggle('active', activeMods[modKey]); }); } const noteStyle = settings.noteStyle || 'bar'; dom.noteStyleSelector.value = noteStyle; dom.backgroundBrightnessSlider.value = settings.brightness || 50; dom.laneOpacitySlider.value = settings.laneOpacity || 50; dom.comboSizeSlider.value = settings.comboSize || 100; dom.comboPositionSlider.value = settings.comboPosition || 45; dom.judgmentPositionSlider.value = settings.judgmentPosition || 65; dom.keyCountSelector.value = settings.keyCount || 4; } else { keyConfigs = defaultConfigs; } setKeyCount(dom.keyCountSelector.value); updateSpeed(); applyBrightness(dom.backgroundBrightnessSlider.value); applyComboSize(dom.comboSizeSlider.value); applyComboPositionY(dom.comboPositionSlider.value); applyJudgmentPositionY(dom.judgmentPositionSlider.value); applyNoteStyle(dom.noteStyleSelector.value); }
        
        return {
            initialize: async function() {
                for (let i = 4; i <= 10; i++) { dom.keyCountSelector.add(new Option(`${i}K`, i)); }
                loadSettings();
                setupMods();
                try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { alert("Web Audio APIがこのブラウザではサポートされていません。"); }
                try { await initDB(); await loadBeatmapsFromDB(); } catch (error) { console.error("Failed to initialize DB:", error); alert("データベースの初期化に失敗しました。譜面ライブラリ機能は使用できません。"); }
                setupFileListeners();
                dom.startButton.addEventListener('click', startGame);
                dom.resumeButton.addEventListener('click', togglePause);
                dom.retryButton.addEventListener('click', retryGame);
                dom.backToMenuButton.addEventListener('click', returnToControls);
                dom.resultsRetryButton.addEventListener('click', retryGame);
                dom.resultsMenuButton.addEventListener('click', returnToControls);
                dom.switchToTaikoButton.addEventListener('click', switchToTaiko);
                dom.ingamePauseButton.addEventListener('click', togglePause);
                dom.fullscreenButton.addEventListener('click', toggleFullscreen);
                dom.saveOszButton.addEventListener('click', saveOszFileToPC);
                dom.speedSlider.addEventListener('input', () => { updateSpeed(); saveSettings(); });
                dom.offsetInput.addEventListener('change', saveSettings);
                dom.audioOffsetInput.addEventListener('change', saveBeatmapSpecificSettings);
                dom.backgroundSelector.addEventListener('change', () => { applyBackgroundChoice(); saveBeatmapSpecificSettings(); });
                dom.autoPlayCheckbox.addEventListener('change', saveSettings);
                dom.force4kCheckbox.addEventListener('change', saveSettings);
                dom.noteStyleSelector.addEventListener('input', (e) => { applyNoteStyle(e.target.value); saveSettings(); });
                dom.backgroundBrightnessSlider.addEventListener('input', (e) => { applyBrightness(e.target.value); saveSettings(); });
                dom.laneOpacitySlider.addEventListener('input', (e) => { applyLaneOpacity(e.target.value); saveSettings(); });
                dom.comboSizeSlider.addEventListener('input', (e) => { applyComboSize(e.target.value); saveSettings(); });
                dom.comboPositionSlider.addEventListener('input', (e) => { applyComboPositionY(e.target.value); saveSettings(); });
                dom.judgmentPositionSlider.addEventListener('input', (e) => { applyJudgmentPositionY(e.target.value); saveSettings(); });
                dom.keyCountSelector.addEventListener('change', (e) => { setKeyCount(e.target.value); saveSettings(); });
            }
        };
    })();

    // --- osu!taiko Game Logic (Scoped) ---
    const TaikoGame = (() => {
        const root = document.getElementById('taiko-wrapper');

        const dom = {
            appContainer: root.querySelector('#app-container'),
            gameContainer: root.querySelector('#game-container'),
            oszFileInput: root.querySelector('#taiko-osz-file'),
            oszFileLabel: root.querySelector('#osz-file-label'),
            fileName: root.querySelector('#file-name'),
            beatmapSelectorContainer: root.querySelector('#beatmap-selector-container'),
            beatmapSelector: root.querySelector('#beatmap-selector'),
            songTitleElement: root.querySelector('#song-title'),
            songArtistElement: root.querySelector('#song-artist'),
            donSoundFileInput: root.querySelector('#don-sound-file'),
            katsuSoundFileInput: root.querySelector('#katsu-sound-file'),
            speedSlider: root.querySelector('#speed-slider'),
            speedLabel: root.querySelector('#speed-label'),
            offsetInput: root.querySelector('#offset-input'),
            videoOffsetInput: root.querySelector('#video-offset-input'),
            seOffsetInput: root.querySelector('#se-offset-input'),
            autoPlayCheckbox: root.querySelector('#auto-play-checkbox'),
            singleHandBigNoteCheckbox: root.querySelector('#single-hand-big-note-checkbox'),
            autoSeCheckbox: root.querySelector('#auto-se-checkbox'),
            keyConfigInputs: root.querySelector('#key-config-inputs'),
            startButton: root.querySelector('#start-button'),
            saveSettingsButton: root.querySelector('#save-settings-button'),
            saveSongToPcButton: root.querySelector('#save-song-to-pc-button'),
            backgroundVideo: root.querySelector('#background-video'),
            backgroundImage: root.querySelector('#background-image'),
            playfield: root.querySelector('#playfield'),
            canvas: root.querySelector('#game-canvas'),
            ctx: root.querySelector('#game-canvas').getContext('2d'),
            scoreElement: root.querySelector('#score'),
            accuracyElement: root.querySelector('#accuracy'),
            comboElement: root.querySelector('#combo'),
            comboDisplay: root.querySelector('#combo-display'),
            rollCounterDisplay: root.querySelector('#roll-counter-display'),
            judgmentTextElement: root.querySelector('#judgment-text'),
            progressBar: root.querySelector('#progress-bar'),
            pauseOverlay: root.querySelector('#pause-overlay'),
            resumeButton: root.querySelector('#resume-button'),
            retryButton: root.querySelector('#retry-button'),
            backToTitlePause: root.querySelector('#back-to-title-button-pause'),
            backToTitleResults: root.querySelector('#back-to-title-button-results'),
            switchToManiaButton: root.querySelector('#switch-to-mania-button'),
            resultsOverlay: root.querySelector('#results-overlay'),
            resultsSongTitle: root.querySelector('#results-song-title'),
            resultsScoreValue: root.querySelector('#results-score-value'),
            resultsRankValue: root.querySelector('#results-rank-value'),
            resultsMaxComboValue: root.querySelector('#results-max-combo-value'),
            resultsRyoValue: root.querySelector('#results-ryo-value'),
            resultsKaValue: root.querySelector('#results-ka-value'),
            resultsFukaValue: root.querySelector('#results-fuka-value'),
            resultsRetryButton: root.querySelector('#results-retry-button'),
            audioPlayer: root.querySelector('#audio-player'),
            drumDonLeft: root.querySelector('#drum-don-left'),
            drumDonRight: root.querySelector('#drum-don-right'),
            drumKatsuLeft: root.querySelector('#drum-katsu-left'),
            drumKatsuRight: root.querySelector('#drum-katsu-right'),
            laneOpacitySlider: root.querySelector('#lane-opacity-slider'),
            laneOpacityLabel: root.querySelector('#lane-opacity-label'),
            bgBrightnessSlider: root.querySelector('#bg-brightness-slider'),
            bgBrightnessLabel: root.querySelector('#bg-brightness-label'),
            backgroundSelectWrapper: root.querySelector('#background-select-wrapper'),
            backgroundSelect: root.querySelector('#background-select'),
            savedSongsList: root.querySelector('#saved-songs-list'),
            deleteSongButton: root.querySelector('#delete-song-button'),
            songSearchInput: root.querySelector('#song-search-input'),
        };
        const db = { _db: null, DB_NAME: 'TaikoPlayerDB', STORE_NAME: 'songs', init() { return new Promise((resolve, reject) => { const request = indexedDB.open(this.DB_NAME, 1); request.onupgradeneeded = (event) => { const db = event.target.result; if (!db.objectStoreNames.contains(this.STORE_NAME)) { db.createObjectStore(this.STORE_NAME, { keyPath: 'id' }); } }; request.onsuccess = (event) => { this._db = event.target.result; resolve(); }; request.onerror = (event) => { console.error('Database error:', event.target.errorCode); reject(event.target.errorCode); }; }); }, addSong(songData) { return new Promise((resolve, reject) => { const transaction = this._db.transaction([this.STORE_NAME], 'readwrite'); const store = transaction.objectStore(this.STORE_NAME); const request = store.add(songData); request.onsuccess = () => resolve(); request.onerror = (event) => reject(event.target.error); }); }, getSongsMeta() { return new Promise((resolve, reject) => { const transaction = this._db.transaction([this.STORE_NAME], 'readonly'); const store = transaction.objectStore(this.STORE_NAME); const request = store.getAll(); request.onsuccess = (event) => { const songs = event.target.result.map(({ id, title, artist }) => ({ id, title, artist })); resolve(songs); }; request.onerror = (event) => reject(event.target.error); }); }, getSongBlob(id) { return new Promise((resolve, reject) => { const transaction = this._db.transaction([this.STORE_NAME], 'readonly'); const store = transaction.objectStore(this.STORE_NAME); const request = store.get(id); request.onsuccess = (event) => { if (event.target.result) { resolve(event.target.result.blob); } else { reject('Song not found'); } }; request.onerror = (event) => reject(event.target.error); }); }, deleteSong(id) { return new Promise((resolve, reject) => { const transaction = this._db.transaction([this.STORE_NAME], 'readwrite'); const store = transaction.objectStore(this.STORE_NAME); const request = store.delete(id); request.onsuccess = () => resolve(); request.onerror = (event) => reject(event.target.error); }); } };
        let KEYS = { don_left: 'D', don_right: 'K', katsu_left: 'S', katsu_right: 'L' };
        const BASE_SCROLL_SPEED = 6;
        let uiScrollSpeed = BASE_SCROLL_SPEED;
        const HIT_WINDOW_PERFECT = 25, HIT_WINDOW_GOOD = 70, HIT_WINDOW_BAD = 100;
        const EARLY_MISS_WINDOW = 100; // 早すぎミスを判定する猶予時間(ms)
        const JUDGE_POINT_X = 390;
        let audioContext;
        let donSoundBuffer = null, katsuSoundBuffer = null;
        let fileContent = null, audioSrc = null;
        let songInfo = { title: '', artist: '', version: '', audioFilename: '' };
        let hitObjects = [], barLines = [], goGoSections = [];
        let audioLoaded = false, beatmapLoaded = false;
        let isGameRunning = false, isPaused = false, isAutoPlay = false, isAutoSE = false;
        let isSingleHandBigNoteEnabled = true;
        let score = 0, combo = 0, offset = 0, maxCombo = 0, accuracy = 100;
        let judgmentCounts = { ryo: 0, ka: 0, fuka: 0 };
        let animationFrameId = null;
        let lastNoteTime = 0;
        let gameStartTime = 0;
        let pauseStartTime = 0;
        let totalPauseDuration = 0;
        let selectedPauseIndex = 0;
        let pressedKeys = new Set();
        let osz_zip = null;
        let osz_beatmaps = [];
        let availableBackgrounds = { video: null, image: null };
        let selectedBackgroundType = 'none';
        let lastCheckedNoteIndex = 0;
        let lastAutoSEIndex = 0;
        let activeRollHits = 0;
        let rollCounterClearTime = 0;
        let isGoGoNow = false;
        let drumHitTimeouts = {};
        const SETTINGS_KEY = 'taikoPlayerSettings';
        let isPauseButtonCoolingDown = false;
        let isInitialCooldown = false;
        let autoPlayHitCounter = 0;
        function initAudioContext() { if (!audioContext) { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); if (audioContext.state === 'suspended') { audioContext.resume(); } } catch (e) { console.error("Web Audio API is not supported in this browser"); } } document.body.removeEventListener('click', initAudioContext, true); document.body.removeEventListener('keydown', initAudioContext, true); }
        document.body.addEventListener('click', initAudioContext, true);
        document.body.addEventListener('keydown', initAudioContext, true);
        function saveSettings() { try { const settings = { speed: dom.speedSlider.value, offset: dom.offsetInput.value, videoOffset: dom.videoOffsetInput.value, seOffset: dom.seOffsetInput.value, keys: KEYS, autoPlay: dom.autoPlayCheckbox.checked, singleHandBigNote: dom.singleHandBigNoteCheckbox.checked, autoSE: dom.autoSeCheckbox.checked, laneOpacity: dom.laneOpacitySlider.value, bgBrightness: dom.bgBrightnessSlider.value, }; localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); } catch (e) { console.error("Failed to save settings:", e); } }
        function saveAndNotify() { saveSettings(); const originalText = dom.saveSettingsButton.textContent; dom.saveSettingsButton.textContent = '保存しました！'; dom.saveSettingsButton.disabled = true; setTimeout(() => { dom.saveSettingsButton.textContent = originalText; dom.saveSettingsButton.disabled = false; }, 1500); }
        function loadSettings() { const savedSettings = localStorage.getItem(SETTINGS_KEY); if (savedSettings) { try { const settings = JSON.parse(savedSettings); if (settings.speed !== undefined) dom.speedSlider.value = settings.speed; if (settings.offset !== undefined) dom.offsetInput.value = settings.offset; if (settings.videoOffset !== undefined) dom.videoOffsetInput.value = settings.videoOffset; if (settings.seOffset !== undefined) dom.seOffsetInput.value = settings.seOffset; if (settings.keys) { KEYS = settings.keys; for (const keyId in KEYS) { const elId = `key-${keyId.replace('_', '-')}`; const el = root.querySelector(`#${elId}`); if (el) el.textContent = KEYS[keyId]; } } if (settings.autoPlay !== undefined) dom.autoPlayCheckbox.checked = settings.autoPlay; if (settings.singleHandBigNote !== undefined) dom.singleHandBigNoteCheckbox.checked = settings.singleHandBigNote; if (settings.autoSE !== undefined) dom.autoSeCheckbox.checked = settings.autoSE; if (settings.laneOpacity !== undefined) dom.laneOpacitySlider.value = settings.laneOpacity; if (settings.bgBrightness !== undefined) dom.bgBrightnessSlider.value = settings.bgBrightness; } catch (e) { console.error("Failed to load settings:", e); localStorage.removeItem(SETTINGS_KEY); } } }
        function parseOsuFile(content) { try { hitObjects = []; barLines = []; goGoSections = []; songInfo = { title: '', artist: '', version: '', audioFilename: '' }; let uninheritedTimingPoints = []; let velocityChanges = []; const allTimingPoints = []; const lines = content.split('\n').map(l => l.trim()); let section = ''; let sliderMultiplier = 1.4; let gameMode = -1; for (const line of lines) { if (line.startsWith('[')) { section = line.toLowerCase(); continue; } if (!section) continue; const lowerLine = line.toLowerCase(); if (section === '[general]' && lowerLine.startsWith('mode:')) { gameMode = parseInt(line.split(':')[1].trim(), 10); } else if (section === '[general]' && lowerLine.startsWith('audiofilename:')) songInfo.audioFilename = line.substring(line.indexOf(':') + 1).trim(); else if (section === '[metadata]') { if (lowerLine.startsWith('title:')) songInfo.title = line.substring(line.indexOf(':') + 1).trim(); else if (lowerLine.startsWith('artist:')) songInfo.artist = line.substring(line.indexOf(':') + 1).trim(); else if (lowerLine.startsWith('version:')) songInfo.version = line.substring(line.indexOf(':') + 1).trim(); } else if (section === '[difficulty]') { if (lowerLine.startsWith('slidermultiplier:')) sliderMultiplier = parseFloat(line.split(':')[1]); } else if (section === '[timingpoints]') { const parts = line.split(','); if (parts.length < 2) continue; const time = parseFloat(parts[0]); const val = parseFloat(parts[1]); const meter = parts.length > 2 ? parseInt(parts[2], 10) : 4; const kiai = parts.length > 7 ? (parseInt(parts[7], 10) & 1) !== 0 : false; allTimingPoints.push({ time, kiai }); if (val > 0) { uninheritedTimingPoints.push({ time, beatLength: val, meter }); } else if (val < 0) { velocityChanges.push({ time, multiplier: -100 / val }); } } } if (gameMode !== 1) { console.warn(`Unsupported game mode detected: ${gameMode}. Only Taiko (mode 1) is supported.`); return false; } if (uninheritedTimingPoints.length === 0) uninheritedTimingPoints.push({time: 0, beatLength: 500, meter: 4}); velocityChanges.sort((a,b) => a.time - b.time); const getScrollMultiplier = (time) => { for (let i = velocityChanges.length - 1; i >= 0; i--) { if (velocityChanges[i].time <= time) return velocityChanges[i].multiplier; } return 1.0; }; section = ''; for (const line of lines) { if (line.startsWith('[')) { section = line.toLowerCase(); continue; } if (section !== '[hitobjects]') continue; const parts = line.split(','); if (parts.length < 5) continue; const time = parseInt(parts[2], 10), type = parseInt(parts[3], 10), hitSound = parseInt(parts[4], 10); const isBig = (hitSound & 4) !== 0; const scrollMultiplier = getScrollMultiplier(time); const noteProps = { time, judged: false, scrollSpeed: scrollMultiplier, sePlayed: false }; if (type & 2) { const parentTimingPoint = uninheritedTimingPoints.findLast(p => p.time <= time) || uninheritedTimingPoints[0]; const pixelLength = parseFloat(parts[7]); const duration = pixelLength / (sliderMultiplier * scrollMultiplier * 100) * parentTimingPoint.beatLength; hitObjects.push({ ...noteProps, type: 'roll', isBig, endTime: time + duration, lastAutoHitTime: 0, hitsMade: 0 }); } else if (type & 8) { const endTime = parseInt(parts[5], 10); const duration = endTime - time; const hitsRequired = Math.max(3, Math.ceil(duration / 200)); hitObjects.push({ ...noteProps, type: 'balloon', endTime, hitsRequired, hitsMade: 0, lastAutoHitTime: 0 }); } else if (type & 1) { let noteType = 'don'; if ((hitSound & 2) || (hitSound & 8)) noteType = 'katsu'; hitObjects.push({ ...noteProps, type: noteType, isBig }); } } allTimingPoints.sort((a,b) => a.time - b.time); let kiaiActive = false, kiaiStartTime = 0; const currentLastNoteTime = hitObjects.reduce((max, note) => Math.max(max, note.endTime || note.time), 0); for(const point of allTimingPoints) { if(point.kiai && !kiaiActive) { kiaiActive = true; kiaiStartTime = point.time; } else if (!point.kiai && kiaiActive) { kiaiActive = false; goGoSections.push({start: kiaiStartTime, end: point.time}); } } if(kiaiActive) goGoSections.push({start: kiaiStartTime, end: currentLastNoteTime + 5000}); if (uninheritedTimingPoints.length > 0 && hitObjects.length > 0) { for (let i = 0; i < uninheritedTimingPoints.length; i++) { const currentPoint = uninheritedTimingPoints[i]; const measureLength = currentPoint.beatLength * currentPoint.meter; if(measureLength <= 0) continue; const barEndTime = (i + 1 < uninheritedTimingPoints.length) ? uninheritedTimingPoints[i+1].time : currentLastNoteTime + 2000; for(let t = currentPoint.time; t < barEndTime; t += measureLength) { barLines.push({time: t, scrollSpeed: getScrollMultiplier(t)}); } } } hitObjects.sort((a, b) => a.time - b.time); lastNoteTime = hitObjects.length > 0 ? (hitObjects[hitObjects.length - 1].endTime || hitObjects[hitObjects.length - 1].time) : 1; return hitObjects.length > 0; } catch (error) { console.error("Error during .osu parsing:", error); alert("譜面の解析に失敗しました。"); return false; } }
        function setupFileListeners() { dom.oszFileInput.addEventListener('change', handleNewFiles); dom.beatmapSelector.addEventListener('change', handleBeatmapSelection); dom.donSoundFileInput.addEventListener('change', e => loadAndDecodeSound(e.target.files[0], true)); dom.katsuSoundFileInput.addEventListener('change', e => loadAndDecodeSound(e.target.files[0], false)); dom.savedSongsList.addEventListener('change', handleSavedSongSelect); dom.deleteSongButton.addEventListener('click', handleDeleteSong); dom.songSearchInput.addEventListener('input', handleSongSearch); }
        async function loadSavedSongsList() { try { const songsMeta = await db.getSongsMeta(); dom.savedSongsList.innerHTML = '<option value="">-- 保存済み譜面を選択 --</option>'; songsMeta.sort((a,b) => `${a.artist} - ${a.title}`.localeCompare(`${b.artist} - ${b.title}`)).forEach(meta => { const option = document.createElement('option'); option.value = meta.id; option.textContent = `${meta.artist} - ${meta.title}`; dom.savedSongsList.appendChild(option); }); handleSongSearch(); } catch (e) { console.error('Failed to load saved songs list:', e); } }
        function handleSongSearch() { const searchTerm = dom.songSearchInput.value.toLowerCase(); for (const option of dom.savedSongsList.options) { if (option.value === "") continue; const songTitle = option.textContent.toLowerCase(); option.style.display = songTitle.includes(searchTerm) ? '' : 'none'; } }
        async function handleSavedSongSelect(e) { const songId = e.target.value; dom.saveSongToPcButton.disabled = !songId; if (!songId) { resetGameAndFiles(false); return; } try { dom.beatmapSelectorContainer.style.display = 'none'; dom.songTitleElement.textContent = '読み込み中...'; const blob = await db.getSongBlob(songId); await processOszBlob(blob); } catch(e) { alert('保存済み譜面の読み込みに失敗しました。'); console.error(e); } }
        async function handleDeleteSong() { const songId = dom.savedSongsList.value; if (!songId) { alert('削除する譜面を選択してください。'); return; } if (confirm(`「${dom.savedSongsList.options[dom.savedSongsList.selectedIndex].text}」を削除しますか？`)) { try { await db.deleteSong(songId); await loadSavedSongsList(); resetGameAndFiles(true); alert('譜面を削除しました。'); } catch (e) { alert('譜面の削除に失敗しました。'); console.error(e); } } }
        function loadAndDecodeSound(file, isDon) { if (!file || !audioContext) return; const reader = new FileReader(); reader.onload = (e) => { const arrayBuffer = e.target.result; audioContext.decodeAudioData(arrayBuffer, (buffer) => { if (isDon) { donSoundBuffer = buffer; } else { katsuSoundBuffer = buffer; } }, (error) => { console.error(`Error decoding audio data for ${isDon ? 'Don' : 'Katsu'}:`, error); alert("サウンドファイルのデコードに失敗しました。"); }); }; reader.onerror = () => { alert("サウンドファイルの読み込みに失敗しました。"); }; reader.readAsArrayBuffer(file); }
        async function handleNewFiles(e) { const files = e.target.files; if (!files || files.length === 0) return; dom.oszFileLabel.classList.add('is-loading'); dom.oszFileInput.disabled = true; let successCount = 0; let errorCount = 0; for (let i = 0; i < files.length; i++) { const file = files[i]; dom.fileName.textContent = `処理中 (${i + 1}/${files.length}): ${file.name}`; if (!file.name.toLowerCase().endsWith('.osz')) { console.warn(`Skipping non-osz file: ${file.name}`); errorCount++; continue; } try { const tempZip = new JSZip(); const loadedZip = await tempZip.loadAsync(file); const firstOsuEntry = Object.values(loadedZip.files).find(f => f.name.toLowerCase().endsWith('.osu')); if (!firstOsuEntry) { console.warn(`Skipping osz without .osu file: ${file.name}`); errorCount++; continue; } const osuContent = await firstOsuEntry.async('string'); const tempInfo = { title: 'Unknown', artist: 'Unknown' }; const lines = osuContent.split('\n'); for (const line of lines) { const trimmedLine = line.trim().toLowerCase(); if (trimmedLine.startsWith('title:')) tempInfo.title = line.substring(6).trim(); else if (trimmedLine.startsWith('artist:')) tempInfo.artist = line.substring(7).trim(); } const songData = { id: `${Date.now()}-${file.name}`, title: tempInfo.title, artist: tempInfo.artist, blob: file }; await db.addSong(songData); successCount++; } catch (err) { console.error(`Failed to process file ${file.name}:`, err); errorCount++; } } dom.fileName.textContent = ''; dom.oszFileLabel.classList.remove('is-loading'); dom.oszFileInput.disabled = false; e.target.value = ''; let message = `${successCount}個の譜面を保存しました。`; if (errorCount > 0) { message += `\n${errorCount}個の譜面は失敗しました。`; } alert(message); if (successCount > 0) { await loadSavedSongsList(); resetGameAndFiles(true); } }
        async function processOszBlob(blob) { resetGameAndFiles(false); dom.songTitleElement.textContent = '読み込み中...'; dom.songArtistElement.textContent = ''; try { osz_zip = new JSZip(); const zip = await osz_zip.loadAsync(blob); const filePromises = []; osz_beatmaps = []; const imageExtensions = ['.jpg', '.jpeg', '.png']; const videoExtensions = ['.mp4', '.avi', '.webm']; zip.forEach((relativePath, zipEntry) => { const lowerCasePath = relativePath.toLowerCase(); if (lowerCasePath.endsWith('.osu')) { filePromises.push(zipEntry.async('string').then(content => { const tempInfo = { title: '', artist: '', version: '', difficulty: 0 }; const lines = content.split('\n'); let currentSection = ''; for(const line of lines) { const trimmedLine = line.trim(); if (trimmedLine.startsWith('[')) { currentSection = trimmedLine.toLowerCase(); continue; } if (currentSection === '[metadata]') { if (trimmedLine.toLowerCase().startsWith('title:')) tempInfo.title = trimmedLine.substring(6).trim(); else if (trimmedLine.toLowerCase().startsWith('artist:')) tempInfo.artist = trimmedLine.substring(7).trim(); else if (trimmedLine.toLowerCase().startsWith('version:')) tempInfo.version = trimmedLine.substring(8).trim(); } else if (currentSection === '[difficulty]') { if (trimmedLine.toLowerCase().startsWith('overalldifficulty:')) { tempInfo.difficulty = parseFloat(trimmedLine.split(':')[1].trim()); } } } osz_beatmaps.push({ name: relativePath, content: content, info: tempInfo }); })); } else if (videoExtensions.some(ext => lowerCasePath.endsWith(ext))) { if (!availableBackgrounds.video) { filePromises.push(zipEntry.async('blob').then(blob => { availableBackgrounds.video = URL.createObjectURL(blob); })); } } else if (imageExtensions.some(ext => lowerCasePath.endsWith(ext))) { if (!availableBackgrounds.image) { filePromises.push(zipEntry.async('blob').then(blob => { availableBackgrounds.image = URL.createObjectURL(blob); })); } } }); await Promise.all(filePromises); updateBackgroundSelector(); if (osz_beatmaps.length === 0) { throw new Error('.osuファイルが見つかりませんでした。'); } dom.beatmapSelector.innerHTML = '<option value="">-- 難易度を選択 --</option>'; osz_beatmaps.sort((a, b) => a.info.difficulty - b.info.difficulty); osz_beatmaps.forEach((osuFile, index) => { const difficultyText = osuFile.info.difficulty ? ` (Lv.${osuFile.info.difficulty})` : ''; const optionText = `${osuFile.info.version || osuFile.name}${difficultyText}`; const option = new Option(optionText, index); dom.beatmapSelector.appendChild(option); }); dom.beatmapSelectorContainer.style.display = 'block'; dom.beatmapSelector.selectedIndex = 1; handleBeatmapSelection(); } catch (err) { alert('譜面の処理に失敗しました。'); console.error(err); resetGameAndFiles(false); } }
        async function handleBeatmapSelection() { const selectedIndex = dom.beatmapSelector.value; beatmapLoaded = false; audioLoaded = false; checkReadyState(); if (selectedIndex === "") { dom.songTitleElement.textContent = '難易度を選択してください'; dom.songArtistElement.textContent = ''; return; }; const selectedOsu = osz_beatmaps[parseInt(selectedIndex, 10)]; if (!selectedOsu) return; fileContent = selectedOsu.content; if (parseOsuFile(fileContent)) { beatmapLoaded = true; dom.songTitleElement.textContent = songInfo.title || '（タイトル不明）'; dom.songArtistElement.textContent = songInfo.artist || '（アーティスト不明）'; if (osz_zip && songInfo.audioFilename) { const targetAudioName = songInfo.audioFilename.replace(/\\/g, '/').toLowerCase(); const audioFileEntry = Object.values(osz_zip.files).find(file => !file.dir && file.name.replace(/\\/g, '/').toLowerCase().endsWith(targetAudioName) ); if(audioFileEntry) { try { const audioBlob = await audioFileEntry.async('blob'); if (audioSrc) URL.revokeObjectURL(audioSrc); audioSrc = URL.createObjectURL(audioBlob); dom.audioPlayer.src = audioSrc; audioLoaded = true; } catch(e) { alert(`音声ファイル "${songInfo.audioFilename}" の読み込みに失敗しました。`); } } else { alert(`音声ファイル "${songInfo.audioFilename}" が見つかりません。`); } } } else { beatmapLoaded = false; audioLoaded = false; dom.songTitleElement.textContent = '非対応の譜面です'; dom.songArtistElement.textContent = '太鼓モードの難易度を選択してください'; alert('この譜面は太鼓モードではありません。'); } checkReadyState(); }
        function resetGameAndFiles(fullReset = true) { resetGame(); if (availableBackgrounds.video) URL.revokeObjectURL(availableBackgrounds.video); if (availableBackgrounds.image) URL.revokeObjectURL(availableBackgrounds.image); availableBackgrounds = { video: null, image: null }; updateBackgroundSelector(); dom.saveSongToPcButton.disabled = true; if (fullReset) { fileContent = null; osz_zip = null; osz_beatmaps = []; beatmapLoaded = false; audioLoaded = false; dom.beatmapSelectorContainer.style.display = 'none'; dom.beatmapSelector.innerHTML = ''; dom.songTitleElement.textContent = '譜面を選択してください'; dom.songArtistElement.textContent = ''; dom.savedSongsList.value = ''; } checkReadyState(); }
        function checkReadyState() { dom.startButton.disabled = !(beatmapLoaded && audioLoaded); }
        function updateBackgroundSelector() { const selector = dom.backgroundSelect; const wrapper = dom.backgroundSelectWrapper; selector.innerHTML = ''; const addOption = (value, text) => { const option = document.createElement('option'); option.value = value; option.textContent = text; selector.appendChild(option); }; let hasOptions = false; if (availableBackgrounds.video || availableBackgrounds.image) { addOption('none', '背景なし'); if (availableBackgrounds.video) addOption('video', '動画'); if (availableBackgrounds.image) addOption('image', '画像'); hasOptions = true; } if (hasOptions) { wrapper.style.display = 'block'; if (availableBackgrounds.video) { selector.value = 'video'; selectedBackgroundType = 'video'; } else if (availableBackgrounds.image) { selector.value = 'image'; selectedBackgroundType = 'image'; } } else { wrapper.style.display = 'none'; selectedBackgroundType = 'none'; } }
        function updateSpeed() { const val = parseFloat(dom.speedSlider.value); const displayVal = (1.0 + val / 6.0).toFixed(1); dom.speedLabel.textContent = `スクロール速度 (x${displayVal})`; uiScrollSpeed = BASE_SCROLL_SPEED + val; if (uiScrollSpeed < 1) uiScrollSpeed = 1; }
        function updateLaneOpacity() { const opacity = dom.laneOpacitySlider.value; dom.laneOpacityLabel.textContent = `レーン不透明度 (${Math.round(opacity * 100)}%)`; dom.playfield.style.backgroundColor = `rgba(18, 18, 18, ${opacity})`; }
        function updateBgBrightness() { const brightness = dom.bgBrightnessSlider.value; dom.bgBrightnessLabel.textContent = `背景の明るさ (${Math.round(brightness * 100)}%)`; const filterValue = `brightness(${brightness})`; dom.backgroundVideo.style.filter = filterValue; dom.backgroundImage.style.filter = filterValue; }
        function initKeyConfig() { dom.keyConfigInputs.querySelectorAll('.key-config-input').forEach(keyInput => { keyInput.addEventListener('click', e => { if (isGameRunning) return; root.querySelectorAll('.key-config-input.is-waiting').forEach(el => el.blur()); e.currentTarget.textContent = '...'; e.currentTarget.classList.add('is-waiting'); }); keyInput.addEventListener('blur', e => { const keyId = e.currentTarget.dataset.keyId; e.currentTarget.classList.remove('is-waiting'); e.currentTarget.textContent = KEYS[keyId]; }); keyInput.addEventListener('keydown', e => { e.preventDefault(); const keyDiv = e.currentTarget; if (!keyDiv.classList.contains('is-waiting')) return; if (e.key === 'Escape') { keyDiv.blur(); return; } const newKey = e.key.toUpperCase(); if (newKey.length > 1 && !['SPACE', 'BACKSPACE', 'ENTER'].includes(newKey) ) return; const keyId = keyDiv.dataset.keyId; if (Object.values(KEYS).some((key, k_idx) => key === newKey && Object.keys(KEYS)[k_idx] !== keyId)) { alert('そのキーは他のアクションで既に使用されています。'); return; } KEYS[keyId] = newKey; keyDiv.blur(); }); }); }
        function initGameUI() { const rect = dom.playfield.getBoundingClientRect(); dom.canvas.width = rect.width; dom.canvas.height = rect.height; }
        function resetGame() {
            score = 0;
            combo = 0;
            maxCombo = 0;
            totalPauseDuration = 0;
            judgmentCounts = { ryo: 0, ka: 0, fuka: 0 };
            accuracy = 100;
            dom.scoreElement.textContent = score;
            dom.accuracyElement.textContent = `S 100.00%`;
            updateComboDisplay();
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            if (hitObjects && hitObjects.length > 0) {
                hitObjects.forEach(note => {
                    note.judged = false;
                    note.sePlayed = false;
                    if ('hitsMade' in note) {
                        note.hitsMade = 0;
                    }
                });
            }
            lastCheckedNoteIndex = 0;
            lastAutoSEIndex = 0;
            activeRollHits = 0;
            rollCounterClearTime = 0;
            isGoGoNow = false;
            pressedKeys.clear();
            autoPlayHitCounter = 0;
            dom.resultsOverlay.style.display = 'none';
            isGameRunning = false;
            isPaused = false;
        }
        async function startGame() {
            if (isGameRunning || !beatmapLoaded || !audioLoaded) return;
            if (audioSrc && dom.audioPlayer.currentSrc !== audioSrc) {
                dom.audioPlayer.src = audioSrc;
            }
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            resetGame();
            dom.appContainer.style.display = 'none';
            dom.gameContainer.style.display = 'block';
            dom.gameContainer.classList.add('playing');
            initGameUI();
            dom.backgroundVideo.style.display = 'none';
            dom.backgroundImage.style.display = 'none';

            isAutoPlay = dom.autoPlayCheckbox.checked;
            isAutoSE = dom.autoSeCheckbox.checked;
            isSingleHandBigNoteEnabled = dom.singleHandBigNoteCheckbox.checked;
            offset = parseInt(dom.offsetInput.value, 10) || 0;

            const audioReadyPromise = new Promise(resolve => {
                if (dom.audioPlayer.readyState >= 4) {
                    resolve();
                } else {
                    dom.audioPlayer.addEventListener('canplaythrough', resolve, { once: true });
                }
            });
            
            let videoReadyPromise = Promise.resolve();
            if (selectedBackgroundType === 'video' && availableBackgrounds.video) {
                videoReadyPromise = new Promise((resolve) => {
                    const videoEl = dom.backgroundVideo;
                    
                    const onSuccess = () => {
                        videoEl.removeEventListener('error', onError);
                        resolve();
                    };
                    const onError = () => {
                        videoEl.removeEventListener('loadeddata', onSuccess);
                        console.error("Video loading failed.");
                        resolve('video_error'); // Resolve with an error indicator instead of rejecting
                    };
                    
                    videoEl.addEventListener('loadeddata', onSuccess, { once: true });
                    videoEl.addEventListener('error', onError, { once: true });

                    videoEl.src = availableBackgrounds.video;
                    videoEl.load(); // Explicitly load the video
                    videoEl.style.display = 'block';

                    if (videoEl.readyState >= 2) { // Already loaded (e.g., from cache)
                        onSuccess();
                    }
                });
            } else if (selectedBackgroundType === 'image' && availableBackgrounds.image) {
                dom.backgroundImage.src = availableBackgrounds.image;
                dom.backgroundImage.style.display = 'block';
            }

            const loadResults = await Promise.all([audioReadyPromise, videoReadyPromise]);
            const videoResult = loadResults[1];

            if (videoResult === 'video_error') {
                alert("動画の読み込みに失敗しました。背景を画像（あれば）に切り替えます。");
                dom.backgroundVideo.style.display = 'none';
                if (availableBackgrounds.image) {
                    dom.backgroundImage.src = availableBackgrounds.image;
                    dom.backgroundImage.style.display = 'block';
                    selectedBackgroundType = 'image';
                    if (dom.backgroundSelect) dom.backgroundSelect.value = 'image';
                } else {
                    selectedBackgroundType = 'none';
                    if (dom.backgroundSelect) dom.backgroundSelect.value = 'none';
                }
            }

            isGameRunning = true;
            isPaused = false;
            
            const initialDelay = 3000;
            const videoOffsetMs = parseInt(dom.videoOffsetInput.value, 10) || 0;
            gameStartTime = performance.now() + initialDelay;
            totalPauseDuration = 0;
            dom.audioPlayer.currentTime = 0;
            let videoPlayDelay = 0;
            let audioPlayDelay = 0;
            if (selectedBackgroundType === 'video' && availableBackgrounds.video) {
                dom.backgroundVideo.currentTime = 0;
                if (videoOffsetMs > 0) {
                    videoPlayDelay = videoOffsetMs;
                } else {
                    audioPlayDelay = Math.abs(videoOffsetMs);
                    dom.backgroundVideo.currentTime = Math.abs(videoOffsetMs) / 1000;
                }
            }
            isInitialCooldown = true;
            setTimeout(() => {
                if (!isGameRunning || isPaused) return;
                setTimeout(() => {
                    if (isGameRunning && !isPaused) dom.audioPlayer.play();
                }, audioPlayDelay);
                if (selectedBackgroundType === 'video' && availableBackgrounds.video && videoResult !== 'video_error') {
                    setTimeout(() => {
                        if (isGameRunning && !isPaused) dom.backgroundVideo.play();
                    }, videoPlayDelay);
                }
                setTimeout(() => { isInitialCooldown = false; }, 500);
            }, initialDelay);
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        function getGameTime() { if(isPaused) return pauseStartTime - gameStartTime - totalPauseDuration; return performance.now() - gameStartTime - totalPauseDuration; }
        function updateLastCheckedNoteIndex() { while(hitObjects[lastCheckedNoteIndex] && hitObjects[lastCheckedNoteIndex].judged) { lastCheckedNoteIndex++; } }
        function gameLoop() { if (!isGameRunning) return; animationFrameId = requestAnimationFrame(gameLoop); if (isPaused) return; const elapsedTime = getGameTime() - offset; isGoGoNow = false; for (const section of goGoSections) { if (elapsedTime >= section.start && elapsedTime < section.end) { isGoGoNow = true; break; } } dom.ctx.clearRect(0, 0, dom.canvas.width, dom.canvas.height); drawGameArea(isGoGoNow); drawBarLines(elapsedTime); drawNotes(elapsedTime); drawRollCounter(elapsedTime); if (isAutoPlay) { autoPlayHandler(elapsedTime); } else { checkMisses(elapsedTime); if (isAutoSE) { autoSEHandler(elapsedTime); } } updateLastCheckedNoteIndex(); const progress = Math.min(1, elapsedTime / lastNoteTime); dom.progressBar.style.width = (progress * 100) + '%'; if (progress >= 1 && elapsedTime > lastNoteTime + 3000) { showResults(); } }
        function drawGameArea(isGoGo) { const y = dom.canvas.height / 2; if (isGoGo) { const fireGradient = dom.ctx.createLinearGradient(0, 0, 0, dom.canvas.height); fireGradient.addColorStop(0, "rgba(255, 100, 0, 0.3)"); fireGradient.addColorStop(0.5, "rgba(255, 69, 0, 0.2)"); fireGradient.addColorStop(1, "rgba(255, 100, 0, 0.3)"); dom.ctx.fillStyle = fireGradient; dom.ctx.fillRect(0, 0, dom.canvas.width, dom.canvas.height); } const judgeCircleRadius = dom.canvas.height * 0.4; dom.ctx.fillStyle = '#ffc0cb'; dom.ctx.beginPath(); dom.ctx.arc(JUDGE_POINT_X, y, judgeCircleRadius, 0, Math.PI * 2); dom.ctx.fill(); dom.ctx.fillStyle = '#d2b48c'; dom.ctx.beginPath(); dom.ctx.arc(JUDGE_POINT_X, y, judgeCircleRadius * 0.8, 0, Math.PI * 2); dom.ctx.fill(); dom.ctx.strokeStyle = '#a0522d'; dom.ctx.lineWidth = judgeCircleRadius * 0.15; dom.ctx.beginPath(); dom.ctx.arc(JUDGE_POINT_X, y, judgeCircleRadius * 0.9, 0, Math.PI * 2); dom.ctx.stroke(); dom.ctx.strokeStyle = '#fff'; dom.ctx.lineWidth = 3; dom.ctx.beginPath(); dom.ctx.arc(JUDGE_POINT_X, y, judgeCircleRadius * 0.5, 0, Math.PI * 2); dom.ctx.stroke(); }
        function drawBarLines(elapsedTime) { const pixelMultiplier = uiScrollSpeed * 0.1; dom.ctx.strokeStyle = '#FFFFFF'; dom.ctx.lineWidth = 2; dom.ctx.globalAlpha = 0.5; barLines.forEach(line => { const timeToJudge = line.time - elapsedTime; const x = JUDGE_POINT_X + timeToJudge * line.scrollSpeed * pixelMultiplier; if (x > dom.canvas.width + 50 || x < JUDGE_POINT_X - 50) return; dom.ctx.beginPath(); dom.ctx.moveTo(x, 0); dom.ctx.lineTo(x, dom.canvas.height); dom.ctx.stroke(); }); dom.ctx.globalAlpha = 1.0; }
        function drawNotes(elapsedTime) { const y = dom.canvas.height / 2; const pixelMultiplier = uiScrollSpeed * 0.1; for (const note of hitObjects) { if (note.judged) continue; const timeToJudge = note.time - elapsedTime; const startX = JUDGE_POINT_X + timeToJudge * note.scrollSpeed * pixelMultiplier; if (note.type === 'roll' || note.type === 'balloon') { const timeToEnd = note.endTime - elapsedTime; const endX = JUDGE_POINT_X + timeToEnd * note.scrollSpeed * pixelMultiplier; if (endX < JUDGE_POINT_X - 50 || startX > dom.canvas.width + 50) continue; if (note.type === 'roll') { const barHeight = note.isBig ? y * 1.1 : y * 0.8; const radius = barHeight / 2; dom.ctx.fillStyle = "gold"; dom.ctx.lineWidth = 2; dom.ctx.strokeStyle = '#fff'; dom.ctx.beginPath(); dom.ctx.rect(startX, y - radius, endX - startX, barHeight); dom.ctx.fill(); dom.ctx.stroke(); dom.ctx.beginPath(); dom.ctx.arc(startX, y, radius, 0, Math.PI * 2); dom.ctx.fill(); dom.ctx.stroke(); dom.ctx.strokeStyle = 'gold'; dom.ctx.beginPath(); dom.ctx.arc(endX, y, radius, 0, Math.PI * 2); dom.ctx.fill(); dom.ctx.stroke(); } else { const radius = y * 0.5; let currentX = startX; if (startX < JUDGE_POINT_X && endX > JUDGE_POINT_X) currentX = JUDGE_POINT_X; if (currentX < -radius || currentX > dom.canvas.width + radius) continue; dom.ctx.beginPath(); dom.ctx.fillStyle = "orange"; dom.ctx.strokeStyle = '#fff'; dom.ctx.lineWidth = 3; dom.ctx.arc(currentX, y, radius, 0, Math.PI * 2); dom.ctx.fill(); dom.ctx.stroke(); const remainingHits = note.hitsRequired - note.hitsMade; if (remainingHits > 0) { dom.ctx.fillStyle = '#fff'; dom.ctx.font = `bold ${radius}px sans-serif`; dom.ctx.textAlign = 'center'; dom.ctx.textBaseline = 'middle'; dom.ctx.fillText(remainingHits, currentX, y); } } } else { if (startX > dom.canvas.width + 50 || startX < JUDGE_POINT_X - 50) continue; const radius = note.isBig ? y * 0.6 : y * 0.4; dom.ctx.beginPath(); dom.ctx.fillStyle = note.type === 'don' ? '#ff4d6d' : '#4dabf7'; dom.ctx.strokeStyle = '#fff'; dom.ctx.lineWidth = 3; dom.ctx.arc(startX, y, radius, 0, Math.PI * 2); dom.ctx.fill(); dom.ctx.stroke(); } } }
        function drawRollCounter(elapsedTime) { if (rollCounterClearTime > 0 && elapsedTime >= rollCounterClearTime) { activeRollHits = 0; rollCounterClearTime = 0; } if (activeRollHits > 0) { dom.rollCounterDisplay.textContent = activeRollHits; dom.rollCounterDisplay.classList.add('visible'); } else { dom.rollCounterDisplay.classList.remove('visible'); } }
        function playHitSound(type, offset = 0) { if (!audioContext) return; const buffer = (type === 'don') ? donSoundBuffer : katsuSoundBuffer; if (!buffer) return; const source = audioContext.createBufferSource(); source.buffer = buffer; source.connect(audioContext.destination); const offsetInSeconds = offset / 1000; let playTime = audioContext.currentTime; let playOffset = 0; if (offsetInSeconds >= 0) { playTime += offsetInSeconds; } else { playOffset = -offsetInSeconds; } if (playOffset < buffer.duration) { source.start(playTime, playOffset); } }
        function autoSEHandler(elapsedTime) { for (let i = lastAutoSEIndex; i < hitObjects.length; i++) { const note = hitObjects[i]; if (note.sePlayed) continue; if (elapsedTime >= note.time) { if (note.type === 'don' || note.type === 'katsu') { playHitSound(note.type); note.sePlayed = true; } } else { break; } } while(hitObjects[lastAutoSEIndex] && hitObjects[lastAutoSEIndex].sePlayed) { lastAutoSEIndex++; } }
        function autoPlayHandler(elapsedTime) { const AUTO_HIT_INTERVAL = 25; for (const note of hitObjects) { if (note.judged) continue; if (note.type === 'balloon' || note.type === 'roll') { if (elapsedTime >= note.time && elapsedTime <= note.endTime) { if (elapsedTime - (note.lastAutoHitTime || 0) > AUTO_HIT_INTERVAL) { playHitSound('don'); const hitSide = autoPlayHitCounter % 2 === 0 ? 'don_right' : 'don_left'; showDrumHit(hitSide); autoPlayHitCounter++; let hitScore = 100; if (isGoGoNow) hitScore *= 1.2; score += hitScore; note.hitsMade++; if (note.type === 'roll') { activeRollHits = note.hitsMade; rollCounterClearTime = 0; } else if (note.type === 'balloon' && note.hitsMade >= note.hitsRequired) { let burstBonus = 5000; if (isGoGoNow) burstBonus *= 1.2; score += burstBonus; note.judged = true; } dom.scoreElement.textContent = Math.floor(score); note.lastAutoHitTime = elapsedTime; } } if (elapsedTime > note.endTime && !note.judged) { if (note.type === 'roll' && note.hitsMade > 0) rollCounterClearTime = elapsedTime + 2000; note.judged = true; } } else if (elapsedTime >= note.time) { playHitSound(note.type); const isBigNoteTwoHands = note.isBig && !isSingleHandBigNoteEnabled; if (note.type === 'don') { if (isBigNoteTwoHands) { showDrumHit('don_left'); showDrumHit('don_right'); } else { const hitSide = autoPlayHitCounter % 2 === 0 ? 'don_right' : 'don_left'; showDrumHit(hitSide); } } else if (note.type === 'katsu') { if (isBigNoteTwoHands) { showDrumHit('katsu_left'); showDrumHit('katsu_right'); } else { const hitSide = autoPlayHitCounter % 2 === 0 ? 'katsu_right' : 'katsu_left'; showDrumHit(hitSide); } } autoPlayHitCounter++; handleJudgment('ryo', note); } } }
        function showDrumHit(keyId) { const hitMap = { don_left: dom.drumDonLeft, don_right: dom.drumDonRight, katsu_left: dom.drumKatsuLeft, katsu_right: dom.drumKatsuRight, }; const element = hitMap[keyId]; if (!element) return; if (drumHitTimeouts[keyId]) { clearTimeout(drumHitTimeouts[keyId]); } element.classList.add('active'); drumHitTimeouts[keyId] = setTimeout(() => { element.classList.remove('active'); }, 50); }
        document.addEventListener('keydown', e => {
            if (activeGame !== 'taiko' || e.repeat || !isGameRunning || isPaused || isAutoPlay) return;
            const key = e.key.toUpperCase();
            let hitKeyId = null;
            for (const id in KEYS) {
                if (KEYS[id] === key) {
                    hitKeyId = id;
                    break;
                }
            }
            if (!hitKeyId) return;

            pressedKeys.add(key);
            const keyType = hitKeyId.startsWith('don') ? 'don' : 'katsu';
            showDrumHit(hitKeyId);
            const seOffset = parseInt(dom.seOffsetInput.value, 10) || 0;
            const elapsedTime = (getGameTime() - offset) + seOffset;
            if (elapsedTime < -500) return;

            // 1. アクティブな連打ノートを探す
            let activeLongNote = null;
            for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) {
                const note = hitObjects[i];
                if (note.judged) continue;
                if (elapsedTime >= note.time && elapsedTime <= note.endTime + HIT_WINDOW_BAD) {
                    if (note.type === 'roll' || note.type === 'balloon') {
                        activeLongNote = note;
                        break;
                    }
                }
                if (note.time > elapsedTime + 200) break;
            }

            // 2. アクティブな連打ノートがある場合の処理
            if (activeLongNote) {
                if (activeLongNote.type === 'roll') {
                    playHitSound(keyType);
                    let scoreToAdd = activeLongNote.isBig ? 200 : 100;
                    if (isGoGoNow) scoreToAdd *= 1.2;
                    score += scoreToAdd;
                    activeLongNote.hitsMade++;
                    activeRollHits = activeLongNote.hitsMade;
                    rollCounterClearTime = 0;
                    dom.scoreElement.textContent = Math.floor(score);
                } else if (activeLongNote.type === 'balloon') {
                    if (keyType === 'don') {
                        playHitSound('don');
                        let scoreToAdd = 300;
                        if (isGoGoNow) scoreToAdd *= 1.2;
                        score += scoreToAdd;
                        activeLongNote.hitsMade++;
                        if (activeLongNote.hitsMade >= activeLongNote.hitsRequired) {
                            let balloonBurstBonus = 5000;
                            if (isGoGoNow) balloonBurstBonus *= 1.2;
                            score += balloonBurstBonus;
                            activeLongNote.judged = true;
                        }
                        dom.scoreElement.textContent = Math.floor(score);
                    } else {
                        if (!isAutoSE) playHitSound('katsu');
                    }
                }
                return; // 連打処理後は通常ノート判定を行わない
            }
            
            // 3. 通常ノートの判定
            let potentialNote = null;
            let minTimeDiff = Infinity;

            // まず、押されたキーと同じ種類の、一番近い未来のノートを探す
            for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) {
                const note = hitObjects[i];
                if (note.judged || note.type === 'balloon' || note.type === 'roll') continue;
                
                // 自分の種類と違うノートは完全に無視 (アレンジプレイのため)
                if (note.type !== keyType) continue;

                const timeDiff = Math.abs(note.time - elapsedTime);
                
                // 早すぎミスを許容する広いウィンドウで最も近いノートを探す
                if (timeDiff < EARLY_MISS_WINDOW) {
                    if (timeDiff < minTimeDiff) {
                        minTimeDiff = timeDiff;
                        potentialNote = note;
                    }
                }
                
                // 探す範囲を限定してパフォーマンスを上げる
                if (note.time > elapsedTime + EARLY_MISS_WINDOW + 100) break;
            }

            // 候補ノートが見つかった場合
            if (potentialNote) {
                const actualTimeDiff = elapsedTime - potentialNote.time; // 正なら遅い、負なら早い

                if (!potentialNote.sePlayed) {
                    playHitSound(keyType);
                }

                if (Math.abs(actualTimeDiff) <= HIT_WINDOW_PERFECT) {
                    handleJudgment('ryo', potentialNote);
                } else if (Math.abs(actualTimeDiff) <= HIT_WINDOW_GOOD) {
                    handleJudgment('ka', potentialNote);
                } else if (actualTimeDiff < 0) { // GOODの範囲外で早かった場合
                    handleJudgment('fuka', potentialNote);
                }
                // 遅すぎの場合は checkMisses に任せるのでここでは何もしない
            
            } else {
                // 叩いたキーの種類のノートが近くにない場合 (完全な空打ち or アレンジ)
                if (!isAutoSE) {
                    playHitSound(keyType);
                }
            }
        });
        document.addEventListener('keyup', e => { if (activeGame !== 'taiko') return; pressedKeys.delete(e.key.toUpperCase()); });
        function checkMisses(elapsedTime) { for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) { const note = hitObjects[i]; if (note.judged) { continue; } if (note.time > elapsedTime + HIT_WINDOW_BAD) break; if (note.type !== 'balloon' && note.type !== 'roll') { if (elapsedTime > note.time + HIT_WINDOW_BAD) { handleJudgment('fuka', note); } } else { if (elapsedTime > note.endTime) { if (note.type === 'roll' && note.hitsMade > 0) rollCounterClearTime = elapsedTime + 2000; note.judged = true; } } } }
        function handleJudgment(judgement, note) { if(note.judged) return; note.judged = true; note.sePlayed = true; const judgmentMap = { ryo: '良', ka: '可', fuka: '不可'}; showJudgment(judgmentMap[judgement]); judgmentCounts[judgement]++; if(judgement === 'ryo' || judgement === 'ka') { const basePoints = judgement === 'ryo' ? 300 : 100; let scoreMultiplier = 1; if(note.isBig) { if (isSingleHandBigNoteEnabled) { scoreMultiplier = 2; } else { const isDonHit = note.type === 'don' && pressedKeys.has(KEYS.don_left) && pressedKeys.has(KEYS.don_right); const isKatsuHit = note.type === 'katsu' && pressedKeys.has(KEYS.katsu_left) && pressedKeys.has(KEYS.katsu_right); if (isDonHit || isKatsuHit) scoreMultiplier = 2; } } updateScore(basePoints * scoreMultiplier); updateCombo(true); } else { updateCombo(false); } updateAccuracy(); }
        function updateScore(points) { let currentPoints = points + (points * Math.floor(combo / 10) * 0.1); if(isGoGoNow) { currentPoints *= 1.2; } score += currentPoints; dom.scoreElement.textContent = Math.floor(score); }
        function updateCombo(hit) { if (hit) { combo++; if (combo > maxCombo) maxCombo = combo; } else { combo = 0; } updateComboDisplay(); }
        function updateAccuracy() { const totalHits = judgmentCounts.ryo + judgmentCounts.ka + judgmentCounts.fuka; if (totalHits === 0) { accuracy = 100; } else { const accVal = (judgmentCounts.ryo * 300 + judgmentCounts.ka * 150) / (totalHits * 300); accuracy = accVal * 100; } let rank = 'S'; if (accuracy < 100) rank = 'S'; if (accuracy < 95) rank = 'A'; if (accuracy < 90) rank = 'B'; if (accuracy < 80) rank = 'C'; if (accuracy < 70) rank = 'D'; dom.accuracyElement.textContent = `${rank} ${accuracy.toFixed(2)}%`; }
        function showJudgment(text) { const el = dom.judgmentTextElement; const judgmentStyles = { "良": 'gold', "可": 'white', "不可": '#dda0dd' }; el.textContent = text; el.style.color = judgmentStyles[text] || 'white'; el.style.animation = 'none'; void el.offsetHeight; el.style.animation = null; }
        function updateComboDisplay() { if (combo > 0) { dom.comboElement.textContent = combo; dom.comboDisplay.classList.add('visible'); } else { dom.comboDisplay.classList.remove('visible'); } }
        function updatePauseSelection() { const buttons = dom.pauseOverlay.querySelectorAll('.overlay-button'); buttons.forEach((btn, index) => { btn.classList.toggle('selected', index === selectedPauseIndex); }); }
        document.addEventListener('keydown', e => {
            if (activeGame !== 'taiko') return;
            if (e.key === 'Escape') {
                e.preventDefault();
                togglePause();
                return;
            }
             if (isPaused) {
                const buttons = dom.pauseOverlay.querySelectorAll('.overlay-button');
                if (buttons.length === 0) return;
                
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedPauseIndex = (selectedPauseIndex - 1 + buttons.length) % buttons.length;
                    updatePauseSelection();
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedPauseIndex = (selectedPauseIndex + 1) % buttons.length;
                    updatePauseSelection();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    buttons[selectedPauseIndex].click();
                }
            }
        });
        function togglePause() { if (isInitialCooldown || !isGameRunning || isPauseButtonCoolingDown) return; isPauseButtonCoolingDown = true; setTimeout(() => { isPauseButtonCoolingDown = false; }, 500); isPaused = !isPaused; if (isPaused) { pauseStartTime = performance.now(); dom.audioPlayer.pause(); if (selectedBackgroundType === 'video' && availableBackgrounds.video) dom.backgroundVideo.pause(); dom.gameContainer.classList.remove('playing'); cancelAnimationFrame(animationFrameId); dom.pauseOverlay.style.display = 'flex'; selectedPauseIndex = 0; updatePauseSelection(); } else { totalPauseDuration += performance.now() - pauseStartTime; dom.audioPlayer.play(); if (selectedBackgroundType === 'video' && availableBackgrounds.video) dom.backgroundVideo.play(); dom.gameContainer.classList.add('playing'); animationFrameId = requestAnimationFrame(gameLoop); dom.pauseOverlay.style.display = 'none'; } }
        function retryGame() { isGameRunning = false; if(animationFrameId) cancelAnimationFrame(animationFrameId); dom.audioPlayer.pause(); if (selectedBackgroundType === 'video' && dom.backgroundVideo) dom.backgroundVideo.pause(); dom.pauseOverlay.style.display = 'none'; dom.resultsOverlay.style.display = 'none'; if (beatmapLoaded && audioLoaded) { startGame(); } else { returnToControls(); } }
        function returnToControls() {
            isGameRunning = false;
            isPaused = false;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            if (dom.audioPlayer) {
                dom.audioPlayer.pause();
                dom.audioPlayer.currentTime = 0;
            }
            if (selectedBackgroundType === 'video' && dom.backgroundVideo) {
                dom.backgroundVideo.pause();
                dom.backgroundVideo.currentTime = 0;
            }
            dom.pauseOverlay.style.display = 'none';
            dom.resultsOverlay.style.display = 'none';
            dom.gameContainer.classList.remove('playing');
            dom.gameContainer.style.display = 'none';
            dom.appContainer.style.display = 'flex';
            resetGame();
        }
        function showResults() { if(!isGameRunning && dom.resultsOverlay.style.display === 'flex') return; isGameRunning = false; cancelAnimationFrame(animationFrameId); dom.gameContainer.classList.remove('playing'); const totalHits = judgmentCounts.ryo + judgmentCounts.ka + judgmentCounts.fuka; let finalAccuracy = 100; if (totalHits > 0) { const accVal = (judgmentCounts.ryo * 300 + judgmentCounts.ka * 150) / (totalHits * 300); finalAccuracy = accVal * 100; } let rank = 'S'; if (finalAccuracy < 95) rank = 'A'; if (finalAccuracy < 90) rank = 'B'; if (finalAccuracy < 80) rank = 'C'; if (finalAccuracy < 70) rank = 'D'; dom.resultsSongTitle.textContent = `${songInfo.title} - ${songInfo.version}`; dom.resultsScoreValue.textContent = Math.floor(score); dom.resultsRankValue.textContent = rank; dom.resultsMaxComboValue.textContent = maxCombo; dom.resultsRyoValue.textContent = judgmentCounts.ryo; dom.resultsKaValue.textContent = judgmentCounts.ka; dom.resultsFukaValue.textContent = judgmentCounts.fuka; dom.resultsOverlay.style.display = 'flex'; if (selectedBackgroundType === 'video') dom.backgroundVideo.pause(); }
        async function saveSongToPc() {
            const songId = dom.savedSongsList.value;
            if (!songId) {
                alert('PCに保存する譜面を「保存済み譜面」から選択してください。');
                return;
            }
            dom.saveSongToPcButton.textContent = '準備中...';
            dom.saveSongToPcButton.disabled = true;
            try {
                const blob = await db.getSongBlob(songId);
                if (!blob) throw new Error('Blob data not found in DB.');

                // IDからファイル名を復元 (IDは 'timestamp-filename.osz' という形式)
                const fileName = songId.substring(songId.indexOf('-') + 1);

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (err) {
                alert('ファイルの保存に失敗しました。');
                console.error('Failed to save .osz file from Taiko player:', err);
            } finally {
                dom.saveSongToPcButton.textContent = 'PCへ保存';
                // Re-enable button only if a song is still selected
                dom.saveSongToPcButton.disabled = !dom.savedSongsList.value;
            }
        }

        return {
            initialize: async function() {
                initKeyConfig();
                setupFileListeners();
                loadSettings();
                updateSpeed();
                updateLaneOpacity();
                updateBgBrightness();
                dom.startButton.addEventListener('click', startGame);
                dom.speedSlider.addEventListener('input', updateSpeed);
                dom.saveSettingsButton.addEventListener('click', saveAndNotify);
                dom.saveSongToPcButton.addEventListener('click', saveSongToPc);
                dom.resumeButton.addEventListener('click', togglePause);
                dom.retryButton.addEventListener('click', retryGame);
                dom.backToTitlePause.addEventListener('click', returnToControls);
                dom.resultsRetryButton.addEventListener('click', retryGame);
                dom.backToTitleResults.addEventListener('click', returnToControls);
                dom.switchToManiaButton.addEventListener('click', switchToMania);
                dom.laneOpacitySlider.addEventListener('input', updateLaneOpacity);
                dom.bgBrightnessSlider.addEventListener('input', updateBgBrightness);
                dom.backgroundSelect.addEventListener('change', e => { selectedBackgroundType = e.target.value; });
                window.addEventListener('resize', initGameUI);
                try {
                    await db.init();
                    await loadSavedSongsList();
                } catch (e) {
                    console.error('Application initialization failed:', e);
                    alert('データベースの初期化に失敗しました。保存機能は利用できません。');
                }
            }
        };
    })();

    </script>
</body>
</html>
