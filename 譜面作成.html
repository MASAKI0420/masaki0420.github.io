<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TJA Maker Pro: Import & Safe Grid ğŸ›¡ï¸</title>
    <!-- JSZipãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- æ–‡å­—ã‚³ãƒ¼ãƒ‰å¤‰æ›ãƒ©ã‚¤ãƒ–ãƒ©ãƒª (Encoding.js) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/encoding-japanese/2.0.0/encoding.min.js"></script>
    <!-- æš—å·åŒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒª (CryptoJS) ã‚’è¿½åŠ  -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        :root {
            --primary: #ff4757;
            --bg: #f1f2f6;
            --text: #333;
            --lane-bg: #333;
            --cmd-color: #8e44ad;
        }

        body { font-family: "Helvetica Neue", Arial, sans-serif; background-color: var(--bg); color: var(--text); margin: 0; padding: 20px; }
        
        /* åˆæœŸçŠ¶æ…‹ã§ã¯ãƒ¡ã‚¤ãƒ³ç”»é¢ã‚’éè¡¨ç¤ºã«ã™ã‚‹ */
        .main-container { display: none; flex-direction: column; gap: 20px; max-width: 1400px; margin: 0 auto; }
        
        h1 { margin: 0 0 10px 0; color: var(--primary); text-align: center; }
        .top-section { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        
        .preview-container { grid-column: 1 / -1; background: #222; border-radius: 8px; padding: 15px; text-align: center; position: sticky; top: 10px; z-index: 1000; box-shadow: 0 4px 10px rgba(0,0,0,0.3); border: 2px solid #555; }
        .player-controls { margin-top: 10px; display: flex; justify-content: center; align-items: center; gap: 15px; flex-wrap: wrap; }
        .volume-controls { display: flex; gap: 15px; background: #333; padding: 5px 15px; border-radius: 50px; }
        .vol-group { display: flex; align-items: center; gap: 5px; color: #ddd; font-size: 0.8em; }
        input[type=range] { width: 80px; }
        .status-text { color: #bdc3c7; font-size: 0.9em; }

        .panel { background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        label { display: block; font-weight: bold; font-size: 0.8em; margin-bottom: 4px; }
        input[type="text"], input[type="number"], select { width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }

        .editor-container { grid-column: 1 / -1; }
        .editor-toolbar { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 2px solid #eee; }
        .tool-group { display: flex; gap: 5px; padding: 5px; border: 1px solid #ddd; border-radius: 6px; }
        .tool-group button { font-size: 0.9em; padding: 8px; min-width: 40px; }
        .tool-group button.active { box-shadow: 0 0 0 3px var(--primary); transform: translateY(-2px); }
        
        .canvas-wrapper { width: 100%; overflow-x: auto; border: 1px solid #ccc; position: relative; }
        #editorCanvas { background-color: #fdfdfd; cursor: pointer; }

        button { border: none; border-radius: 4px; color: white; cursor: pointer; padding: 5px 10px; font-weight: bold; transition: 0.2s; }
        .btn-play { background-color: #2ed573; } .btn-stop { background-color: #ff6b81; } .btn-metro { background-color: #57606f; }
        .btn-metro.active { background-color: #ffa502; color: black; }
        .btn-don { background: #ff4757; } .btn-kat { background: #3742fa; }
        .btn-don-big { background: #ff4757; border: 2px solid #7c1e27; } .btn-kat-big { background: #3742fa; border: 2px solid #192085; }
        .btn-roll { background-color: #f1c40f; color: black; } .btn-eraser { background: #7f8c8d; }
        .btn-balloon { background-color: #e67e22; color: white; }
        .btn-control { background: #34495e; font-size: 0.9em; }
        .btn-file { background: #3498db; position: relative; overflow: hidden; }
        .btn-file input[type=file] { position: absolute; top: 0; right: 0; min-width: 100%; min-height: 100%; font-size: 100px; text-align: right; filter: alpha(opacity=0); opacity: 0; outline: none; background: white; cursor: inherit; display: block; }

        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: none; justify-content: center; align-items: center; }
        .modal-content { background: white; padding: 20px; border-radius: 8px; width: 300px; }
        .modal-content h3 { margin-top: 0; }
        .modal-content .form-group { margin-bottom: 10px; }

        #chartTjaOutput { display: none; }

        /* ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #login-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #f1f2f6; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .login-box {
            background: white; padding: 30px; border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            text-align: center; width: 300px;
        }
        .login-box h2 { color: var(--primary); margin-top: 0; }
        .login-box input[type="password"] {
            width: 100%; padding: 10px; margin: 10px 0;
            border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;
        }
        .login-box button {
            width: 100%; padding: 10px; background: var(--primary); font-size: 1.1em; margin-top: 10px;
        }
        .login-error { color: #e74c3c; font-size: 0.9em; margin-top: 10px; display: none; }
        .login-options { margin-top: 10px; font-size: 0.9em; text-align: left; }
    </style>
</head>
<body>

    <!-- ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ -->
    <div id="login-screen">
        <div class="login-box">
            <h2>ğŸ”’ Restricted Access</h2>
            <p>ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>
            <input type="password" id="passwordInput" placeholder="Password">
            <div class="login-options">
                <label><input type="checkbox" id="rememberMe"> æ¬¡å›ã‹ã‚‰è‡ªå‹•ã§ãƒ­ã‚°ã‚¤ãƒ³ã™ã‚‹</label>
            </div>
            <button onclick="attemptLogin()">ãƒ­ã‚°ã‚¤ãƒ³</button>
            <p id="loginError" class="login-error">ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé–“é•ã£ã¦ã„ã¾ã™</p>
        </div>
    </div>

    <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
    <div class="main-container" id="mainApp">
        <h1>TJA Maker Pro (Graphical Editor)</h1>

        <div class="preview-container">
             <canvas id="previewCanvas" width="800" height="160"></canvas>
            <div class="player-controls">
                <button id="btnPlay" class="btn-play" onclick="togglePlayback()" disabled>â–¶ å†ç”Ÿ</button>
                <button id="btnStop" class="btn-stop" onclick="stopPreview()">â–  åœæ­¢</button>
                <button id="btnMetro" class="btn-metro" onclick="toggleMetro()">â° OFF</button>
                <div class="volume-controls">
                    <div class="vol-group">ğŸ¥<input type="range" id="volSeSlider" min="0" max="500" value="150"></div>
                    <div class="vol-group">â°<input type="range" id="volMetroSlider" min="0" max="1000" value="300"></div>
                </div>
                <span id="musicStatus" class="status-text">ğŸµ éŸ³æ¥½ãƒ•ã‚¡ã‚¤ãƒ«å¾…ã¡...</span>
            </div>
        </div>

        <div class="top-section">
            <div class="panel">
                <h2>1. åŸºæœ¬è¨­å®šãƒ»èª­è¾¼</h2>
                <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px;">
                    <div style="display:flex; gap:10px; align-items: center;">
                        <span style="font-size:0.9em; font-weight:bold;">â‘  éŸ³æ¥½:</span>
                        <input type="file" id="audioFileInput">
                    </div>
                    <div style="display:flex; gap:10px; align-items: center;">
                        <span style="font-size:0.9em; font-weight:bold;">â‘¡ è­œé¢ (ç¶šãã‹ã‚‰):</span>
                        <input type="file" id="tjaFileInput" accept=".tja,.txt">
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <div style="flex: 1;"><label>TITLE</label><input type="text" id="title" value="New Song" oninput="updateTjaText()"></div>
                    <div style="flex: 1;"><label>SUBTITLE</label><input type="text" id="subtitle" placeholder="çœç•¥å¯" oninput="updateTjaText()"></div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <div style="flex: 1;"><label>BPM</label><input type="number" id="bpm" value="120" step="any" oninput="updateTjaText()"></div>
                    <div style="flex: 1;"><label>OFFSET</label><input type="number" id="offset" value="-0.05" step="0.01" oninput="updateTjaText()"></div>
                    <div style="width: 80px;"><label>LEVEL (â˜…)</label><input type="number" id="level" value="8" min="1" max="10" oninput="updateTjaText()"></div>
                </div>

                 <div style="margin-top: 10px;">
                    <button id="btnAutoBpm" class="btn-control" onclick="runAdvancedBpmAnalysis()" disabled style="width:100%;">âš¡ é«˜ç²¾åº¦BPMè§£æ</button>
                </div>
            </div>
            <div class="panel">
                <h2>3. ä¿å­˜ãƒ»å‡ºåŠ›</h2>
                <label>TJAãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ (è‡ªå‹•ç”Ÿæˆ)</label>
                <textarea id="outputPreview" readonly style="height: 120px; width: 100%; font-family: monospace;"></textarea>
                <button class="btn-control" onclick="downloadZip()" style="width: 100%; margin-top: 10px; padding: 10px; background-color: #e67e22;">ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ (.zip / ANSI)</button>
            </div>
        </div>

        <div class="panel editor-container">
            <h2>2. è­œé¢å…¥åŠ› (ã‚¨ãƒ‡ã‚£ã‚¿)</h2>
            <div class="editor-toolbar">
                <div class="tool-group" id="note-tools">
                    <button class="btn-don active" data-note="1">ãƒ‰ãƒ³(1)</button>
                    <button class="btn-kat" data-note="2">ã‚«ãƒƒ(2)</button>
                    <button class="btn-don-big" data-note="3">å¤§ãƒ‰ãƒ³(3)</button>
                    <button class="btn-kat-big" data-note="4">å¤§ã‚«ãƒƒ(4)</button>
                    <button class="btn-roll" data-note="5">é€£æ‰“(5)</button>
                    <button class="btn-roll" data-note="6">å¤§é€£æ‰“(6)</button>
                    <button class="btn-balloon" data-note="7">é¢¨èˆ¹(7)</button>
                    <button class="btn-roll" data-note="8">é€£æ‰“çµ‚(8)</button>
                    <button class="btn-eraser" data-note="0">æ¶ˆã—ã‚´ãƒ </button>
                </div>
                 <div class="tool-group">
                    <label style="margin: auto 5px;">åˆ†å‰²:</label>
                    <select id="grid-select" onchange="changeGrid()">
                        <option value="4">4åˆ†</option> <option value="8">8åˆ†</option> <option value="12">12åˆ†</option>
                        <option value="16" selected>16åˆ†</option> <option value="24">24åˆ†</option> <option value="32">32åˆ†</option>
                        <option value="48">48åˆ†</option>
                    </select>
                </div>
                 <div class="tool-group">
                    <button class="btn-control" onclick="addMeasure()">å°ç¯€ã‚’è¿½åŠ </button>
                    <button class="btn-control" onclick="removeMeasure()">æœ€å¾Œã®å°ç¯€ã‚’å‰Šé™¤</button>
                </div>
            </div>
             <p style="font-size:0.8em; color:#555; margin:-10px 0 10px 0;">ãƒ’ãƒ³ãƒˆ: â†â†’, Shift(ã‚³ãƒãƒ³ãƒ‰), 9(GOGO), Del(æ¶ˆå») / Ctrl(ã‚³ãƒ”ãƒ¼é–‹å§‹), Alt(ã‚³ãƒ”ãƒ¼çµ‚äº†), Ctrl+V(è²¼ä»˜), Ctrl+Z(æˆ»ã™)</p>
            <div class="canvas-wrapper" tabindex="0">
                <canvas id="editorCanvas" width="1200" height="100"></canvas>
            </div>
        </div>
        
        <textarea id="chartTjaOutput" style="display: none;"></textarea>
    </div>

    <div class="modal-backdrop" id="command-modal">
        <div class="modal-content">
            <h3 id="modal-title">å°ç¯€ 1 ã®ã‚³ãƒãƒ³ãƒ‰</h3>
            <div class="form-group"><label><input type="checkbox" id="modal-gogo"> GOGOSTART</label></div>
            <div class="form-group"><label>BPMå¤‰æ›´</label><input type="number" id="modal-bpm" placeholder="ä¾‹: 180"></div>
            <div class="form-group"><label>æ‹å­å¤‰æ›´</label><input type="text" id="modal-measure" placeholder="ä¾‹: 3/4"></div>
            <div class="form-group"><label>ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦</label><input type="number" id="modal-scroll" placeholder="ä¾‹: 1.5" step="0.1"></div>
            <div style="text-align: right; margin-top: 20px;">
                <button class="btn-control" onclick="saveCommands()">é©ç”¨</button>
                <button class="btn-eraser" onclick="closeModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
        </div>
    </div>

    <script>
        // â–¼â–¼â–¼ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰è¨­å®š (SHA-256ãƒãƒƒã‚·ãƒ¥å€¤) â–¼â–¼â–¼
    
        const CORRECT_HASH = "d1f82b92179567a9a86ba7d4b15d83c2b18c53166fc4506af028dff11763f312";
        const LOGIN_KEY = "tja_maker_auth_hash";

        // ãƒãƒƒã‚·ãƒ¥è¨ˆç®— (CryptoJSãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã€ã‚ˆã‚Šç¢ºå®Ÿã«å‹•ä½œã™ã‚‹ã‚ˆã†ã«å¤‰æ›´)
        function calculateHash(message) {
            return CryptoJS.SHA256(message).toString(CryptoJS.enc.Hex);
        }

        window.addEventListener('DOMContentLoaded', () => {
            const savedHash = localStorage.getItem(LOGIN_KEY);
            if (savedHash === CORRECT_HASH) {
                grantAccess();
            } else {
                document.getElementById('login-screen').style.display = 'flex';
            }
        });

        function attemptLogin() {
            const input = document.getElementById('passwordInput').value;
            const remember = document.getElementById('rememberMe').checked;
            const errorMsg = document.getElementById('loginError');

            // å…¥åŠ›å€¤ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–
            const inputHash = calculateHash(input);

            if (inputHash === CORRECT_HASH) {
                if (remember) {
                    localStorage.setItem(LOGIN_KEY, CORRECT_HASH);
                }
                grantAccess();
            } else {
                errorMsg.style.display = 'block';
                const box = document.querySelector('.login-box');
                box.style.transform = "translateX(5px)";
                setTimeout(() => box.style.transform = "translateX(-5px)", 50);
                setTimeout(() => box.style.transform = "translateX(0)", 100);
            }
        }
        
        document.getElementById('passwordInput').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                attemptLogin();
            }
        });

        function grantAccess() {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('mainApp').style.display = 'flex';
            window.dispatchEvent(new Event('resize'));
        }

        // --- ä»¥ä¸‹ã€æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ ---

        // --- UI & Globals ---
        const inputs = { 
            title: document.getElementById('title'), 
            subtitle: document.getElementById('subtitle'), 
            bpm: document.getElementById('bpm'), 
            offset: document.getElementById('offset'), 
            level: document.getElementById('level'), 
            chart: document.getElementById('chartTjaOutput'), 
            out: document.getElementById('outputPreview') 
        };
        const fileInput = document.getElementById('audioFileInput'), tjaInput = document.getElementById('tjaFileInput'), statusText = document.getElementById('musicStatus');
        const btnPlay = document.getElementById('btnPlay'), btnMetro = document.getElementById('btnMetro'), btnAutoBpm = document.getElementById('btnAutoBpm'), volSeSlider = document.getElementById('volSeSlider'), volMetroSlider = document.getElementById('volMetroSlider');
        let audioCtx, musicBuffer = null, musicSource = null, isMetroOn = false, volSe = 1.5, volMetro = 3.0; 

        // --- Editor Globals ---
        const editorCanvas = document.getElementById('editorCanvas'), canvasWrapper = editorCanvas.parentElement, editorCtx = editorCanvas.getContext('2d'), gridSelect = document.getElementById('grid-select'), noteTools = document.getElementById('note-tools');
        let chartData = []; let activeNote = '1'; let currentGrid = 16;
        let cursor = { measure: 0, pos: 0 };
        const MEASURE_WIDTH = 480, LANE_Y = 50, NOTE_RADIUS = 15;

        // â–¼â–¼â–¼ã€æ–°è¦ã€‘Undo(å…ƒã«æˆ»ã™)ã¨ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° â–¼â–¼â–¼
        let history = [];
        const MAX_HISTORY = 50; // å…ƒã«æˆ»ã›ã‚‹å›æ•°ã®ä¸Šé™
        let clipboard = null;
        let selectionStart = null; // ã‚³ãƒ”ãƒ¼é–‹å§‹ä½ç½®ã‚’ä¿å­˜ã™ã‚‹å¤‰æ•°
        // â–²â–²â–²ã“ã“ã¾ã§â–²â–²â–²

        // --- Editor Drawing & Init ---
        function initEditor() {
            if(chartData.length === 0) for (let i = 0; i < 4; i++) addMeasure(false, false);
            drawEditor();
            updateAllTja();
        }

        function drawEditor() {
            const totalWidth = chartData.length * MEASURE_WIDTH;
            editorCanvas.width = totalWidth;
            editorCtx.clearRect(0, 0, totalWidth, editorCanvas.height);
            editorCtx.fillStyle = '#f9f9f9';
            editorCtx.fillRect(0, LANE_Y - NOTE_RADIUS - 15, totalWidth, (NOTE_RADIUS + 15) * 2);

            for (let i = 0; i < chartData.length; i++) {
                const measureX = i * MEASURE_WIDTH;
                const measure = chartData[i];
                const gridSize = measure.notes.length;
                const stepX = MEASURE_WIDTH / gridSize;

                for (let j = 0; j < gridSize; j++) {
                    const x = measureX + j * stepX;
                    if (j % (gridSize / 4) === 0) { editorCtx.strokeStyle = '#bbb'; } else if (j % (gridSize / 8) === 0) { editorCtx.strokeStyle = '#ccc'; } else { editorCtx.strokeStyle = '#eee'; }
                    editorCtx.lineWidth = 1;
                    editorCtx.beginPath(); editorCtx.moveTo(x, LANE_Y - 25); editorCtx.lineTo(x, LANE_Y + 25); editorCtx.stroke();
                }

                editorCtx.strokeStyle = measure.commands.length > 0 ? 'var(--cmd-color)' : '#333';
                editorCtx.lineWidth = measure.commands.length > 0 ? 3 : 2;
                editorCtx.beginPath(); editorCtx.moveTo(measureX, LANE_Y - 35); editorCtx.lineTo(measureX, LANE_Y + 35); editorCtx.stroke();
                
                drawRollBars(i, measureX, stepX);
                for (let j = 0; j < gridSize; j++) { if (measure.notes[j].type !== '0') drawNote(editorCtx, measureX + j * stepX, LANE_Y, measure.notes[j]); }
            }

            // â–¼â–¼â–¼ã€æ–°è¦ã€‘ã‚³ãƒ”ãƒ¼é–‹å§‹ä½ç½®ã®ãƒãƒ¼ã‚«ãƒ¼ã‚’æç”» â–¼â–¼â–¼
            if (selectionStart && chartData[selectionStart.measure]) {
                const startGrid = chartData[selectionStart.measure].notes.length;
                const startX = selectionStart.measure * MEASURE_WIDTH + selectionStart.pos * (MEASURE_WIDTH / startGrid);
                editorCtx.fillStyle = 'rgba(26, 188, 156, 0.6)'; // ãƒãƒ¼ã‚«ãƒ¼ã®è‰²
                editorCtx.fillRect(startX - 2, LANE_Y - 35, 4, 70);
            }

            if (cursor.measure >= chartData.length) cursor.measure = chartData.length - 1;
            const currentMeasureNotes = chartData[cursor.measure].notes;
            if (cursor.pos >= currentMeasureNotes.length) cursor.pos = currentMeasureNotes.length - 1;

            const cursorX = cursor.measure * MEASURE_WIDTH + cursor.pos * (MEASURE_WIDTH / currentMeasureNotes.length);
            editorCtx.fillStyle = 'rgba(255, 235, 59, 0.5)';
            editorCtx.fillRect(cursorX - 5, LANE_Y - 35, 10, 70);
        }
        
        function drawRollBars(measureIndex, measureX, stepX) {
            const notes = chartData[measureIndex].notes;
            let rollStart = -1, rollType = '0';
            for (let i = 0; i < notes.length; i++) {
                const note = notes[i].type;
                if ((note === '5' || note === '6' || note === '7') && rollStart === -1) { rollStart = i; rollType = note; }
                else if (note === '8' && rollStart !== -1) {
                    const startX = measureX + rollStart * stepX;
                    const endX = measureX + i * stepX;
                    const isBig = rollType === '6';
                    const isBalloon = rollType === '7';
                    
                    if (isBalloon) {
                        editorCtx.fillStyle = 'rgba(230, 126, 34, 0.6)';
                    } else {
                        editorCtx.fillStyle = isBig ? 'rgba(241, 196, 15, 0.6)' : 'rgba(241, 196, 15, 0.4)';
                    }
                    
                    editorCtx.fillRect(startX, LANE_Y - (isBig ? 22 : 15), endX - startX, isBig ? 44 : 30);
                    rollStart = -1;
                }
            }
        }
        
        drawNote = function(ctx, x, y, noteObj) {
            const type = noteObj.type;
            let color = "#ccc", isBig = false;
            if (type === "1") color = "#ff4757";
            else if (type === "2") color = "#3742fa";
            else if (type === "3") { color = "#ff4757"; isBig = true; }
            else if (type === "4") { color = "#3742fa"; isBig = true; }
            else if (type === "5" || type === "6" || type === "8") color = "#f1c40f";
            else if (type === "7") color = "#e67e22";

            const radius = (type === "6" || type === "4" || type === "3") ? 1.3 * NOTE_RADIUS : NOTE_RADIUS;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = (type === "3" || type === "4" || type === "6") ? "#333" : "#fff";
            ctx.lineWidth = 2;
            ctx.stroke();

            if (type === "7" && noteObj.hits) {
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${radius * 0.9}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(noteObj.hits, x, y);
            }
        };

        // --- Editor Interactions ---
        noteTools.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') setActiveNote(e.target.dataset.note); });

        function handleEditorClick(event) {
            const rect = editorCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left + canvasWrapper.scrollLeft;
            const measureIndex = Math.floor(x / MEASURE_WIDTH);
            if (measureIndex >= chartData.length) return;

            const xInMeasure = x % MEASURE_WIDTH;
            const gridSize = chartData[measureIndex].notes.length;
            const closestIndex = Math.round(xInMeasure / (MEASURE_WIDTH / gridSize));
            if(closestIndex >= gridSize) return;

            cursor = { measure: measureIndex, pos: closestIndex };
            drawEditor();
        }
        editorCanvas.addEventListener('mousedown', handleEditorClick);
        editorCanvas.addEventListener('contextmenu', e => e.preventDefault());

        canvasWrapper.addEventListener('keydown', (e) => {
            if (document.activeElement === canvasWrapper) e.preventDefault();
            
            // â–¼â–¼â–¼ã€æ–°è¦ã€‘Undoã¨Copy/Pasteã®ã‚­ãƒ¼æ“ä½œã‚’ãƒãƒ³ãƒ‰ãƒ« â–¼â–¼â–¼
            // Ctrlã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹å ´åˆã®çµ„ã¿åˆã‚ã›ã‚­ãƒ¼ã‚’å…ˆã«å‡¦ç†
            if (e.ctrlKey) {
                if (e.key.toLowerCase() === 'z') { undo(); return; }
                if (e.key.toLowerCase() === 'v') { pasteFromClipboard(); return; }
            }
            // å˜ç‹¬ã®Ctrl, Altã‚­ãƒ¼ã®å‡¦ç†
            if (e.key === 'Control' && !e.repeat) { setCopyStart(); return; }
            if (e.key === 'Alt' && !e.repeat) { setCopyEndAndCopy(); return; }
            // â–²â–²â–²ã“ã“ã¾ã§â–²â–²â–²

            const validToolKeys = ['1', '2', '3', '4', '5', '6', '7', '8'];
            const measure = chartData[cursor.measure];
            const gridSize = measure.notes.length;

            if (e.key === 'ArrowRight') cursor.pos++; 
            else if (e.key === 'ArrowLeft') cursor.pos--;
            else if (e.key === 'Shift') openCommandModal(cursor.measure);
            else if (e.key === '9') { 
                saveStateForUndo();
                if (measure.commands.includes('#GOGOSTART')) {
                    measure.commands = measure.commands.filter(cmd => cmd !== '#GOGOSTART');
                } else {
                    measure.commands.push('#GOGOSTART');
                }
            } else if (e.key === '0') {
                if (cursor.pos === 0) {
                    saveStateForUndo();
                    if (measure.commands.includes('#GOGOEND')) {
                        measure.commands = measure.commands.filter(cmd => cmd !== '#GOGOEND');
                    } else {
                        measure.commands.push('#GOGOEND');
                    }
                } else { 
                    setActiveNote('0');
                }
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                saveStateForUndo();
                chartData[cursor.measure].notes[cursor.pos] = { type: '0' };
            } else if (validToolKeys.includes(e.key)) {
                setActiveNote(e.key);
                placeNote();
            }
            
            if (cursor.pos < 0) {
                if (cursor.measure > 0) {
                    cursor.measure--;
                    cursor.pos = chartData[cursor.measure].notes.length - 1;
                } else {
                    cursor.pos = 0;
                }
            } else if (cursor.pos >= gridSize) {
                if (cursor.measure < chartData.length - 1) {
                    cursor.measure++;
                    cursor.pos = 0;
                } else {
                    cursor.pos = gridSize - 1;
                }
            }
            
            const newGridSize = chartData[cursor.measure].notes.length;
            const cursorX = cursor.measure * MEASURE_WIDTH + cursor.pos * (MEASURE_WIDTH / newGridSize);
            canvasWrapper.scrollLeft = cursorX - canvasWrapper.clientWidth / 2;
            
            drawEditor();
            updateAllTja();
        });
        
        function placeNote() {
            saveStateForUndo();
            const { measure, pos } = cursor;
            const currentNote = chartData[measure].notes[pos];

            if (currentNote.type === activeNote) {
                chartData[measure].notes[pos] = { type: '0' };
                return;
            }

            if (activeNote === '7') {
                const hits = prompt("é¢¨èˆ¹ã®æ‰“æ•°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:", currentNote.hits || "5");
                if (hits === null) return; // Cancelled
                const numHits = parseInt(hits, 10);
                if (isNaN(numHits) || numHits <= 0) {
                    alert("ç„¡åŠ¹ãªæ•°å€¤ã§ã™ã€‚");
                    return;
                }
                chartData[measure].notes[pos] = { type: '7', hits: numHits };
            } else {
                chartData[measure].notes[pos] = { type: activeNote };
            }
        }

        function setActiveNote(note) {
            noteTools.querySelector('.active').classList.remove('active');
            const newTool = noteTools.querySelector(`[data-note="${note}"]`);
            if(newTool) newTool.classList.add('active');
            activeNote = note;
            drawEditor();
        }

        function addMeasure(redraw = true, save = true) { 
            if(save) saveStateForUndo();
            const newMeasure = { notes: Array(currentGrid).fill(0).map(() => ({ type: '0' })), commands: [] };
            chartData.push(newMeasure); 
            if(redraw) { drawEditor(); updateAllTja(); } 
        }
        function removeMeasure() { 
            if (chartData.length > 1) { 
                saveStateForUndo();
                chartData.pop(); 
                drawEditor(); 
                updateAllTja(); 
            } else { 
                alert("æœ€å¾Œã®1å°ç¯€ã¯å‰Šé™¤ã§ãã¾ã›ã‚“ã€‚"); 
            } 
        }
        function findLCM(a, b) { const gcd = (x, y) => (!y ? x : gcd(y, x % y)); return (a * b) / gcd(a, b); }

        function changeGrid() { 
            saveStateForUndo();
            const targetGrid = parseInt(gridSelect.value, 10);
            
            chartData.forEach(measure => {
                const oldGrid = measure.notes.length;
                if (oldGrid === targetGrid) return;

                const oldNotes = measure.notes;
                let wouldLoseData = false;
                for(let i=0; i<oldGrid; i++) {
                    if (oldNotes[i].type !== '0') {
                        if ( (i * targetGrid) % oldGrid !== 0 ) {
                            wouldLoseData = true;
                            break;
                        }
                    }
                }

                let newGridSize = wouldLoseData ? findLCM(oldGrid, targetGrid) : targetGrid;
                if (newGridSize === oldGrid) return; 

                const newNotes = Array(newGridSize).fill(0).map(() => ({ type: '0' }));
                for (let j = 0; j < oldGrid; j++) {
                    if (oldNotes[j].type !== '0') {
                        const newIndex = Math.round(j * (newGridSize / oldGrid));
                        newNotes[newIndex] = oldNotes[j];
                    }
                }
                measure.notes = newNotes;
            });
            
            currentGrid = targetGrid; 
            drawEditor(); 
            updateAllTja(); 
        }
        
        const commandModal = document.getElementById('command-modal');
        let currentEditingMeasure = 0;
        
        function openCommandModal(measureIndex) {
            currentEditingMeasure = measureIndex;
            const measure = chartData[measureIndex];

            document.getElementById('modal-title').innerText = `å°ç¯€ ${measureIndex + 1} ã®ã‚³ãƒãƒ³ãƒ‰`;
            document.getElementById('modal-gogo').checked = false;
            document.getElementById('modal-bpm').value = "";
            document.getElementById('modal-measure').value = "";
            document.getElementById('modal-scroll').value = "";

            measure.commands.forEach(cmd => {
                if (cmd === "#GOGOSTART") document.getElementById('modal-gogo').checked = true;
                else if (cmd.startsWith("#BPMCHANGE")) document.getElementById('modal-bpm').value = cmd.split(" ")[1];
                else if (cmd.startsWith("#MEASURE")) document.getElementById('modal-measure').value = cmd.split(" ")[1];
                else if (cmd.startsWith("#SCROLL")) document.getElementById('modal-scroll').value = cmd.split(" ")[1];
            });
            
            commandModal.style.display = "flex";
        }
        
        function closeModal() { commandModal.style.display = 'none'; }
        
        function saveCommands() {
            saveStateForUndo();
            const measure = chartData[currentEditingMeasure];
            measure.commands = [];

            if (document.getElementById('modal-gogo').checked) measure.commands.push("#GOGOSTART");
            const bpm = document.getElementById('modal-bpm').value;
            if (bpm) measure.commands.push(`#BPMCHANGE ${bpm}`);
            const measureVal = document.getElementById('modal-measure').value;
            if (measureVal) measure.commands.push(`#MEASURE ${measureVal}`);
            const scroll = document.getElementById('modal-scroll').value;
            if (scroll) measure.commands.push(`#SCROLL ${scroll}`);

            closeModal();
            drawEditor();
            updateAllTja();
        }

        // â–¼â–¼â–¼ã€æ–°è¦ã€‘Undoã¨Copy/Pasteã®é–¢é€£é–¢æ•° â–¼â–¼â–¼

        /**
         * ç¾åœ¨ã®è­œé¢çŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜ã—ã¾ã™ï¼ˆUndoç”¨ï¼‰ã€‚
         */
        function saveStateForUndo() {
            history.push(JSON.stringify(chartData)); // è­œé¢ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ã—ã¦ä¿å­˜
            if (history.length > MAX_HISTORY) {
                history.shift(); // å±¥æ­´ãŒä¸Šé™ã‚’è¶…ãˆãŸã‚‰å¤ã„ã‚‚ã®ã‹ã‚‰å‰Šé™¤
            }
        }

        /**
         * æœ€å¾Œã®æ“ä½œã‚’å…ƒã«æˆ»ã—ã¾ã™ã€‚
         */
        function undo() {
            if (history.length === 0) return; // æˆ»ã™å±¥æ­´ãŒãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
            const lastState = history.pop();
            chartData = JSON.parse(lastState);
            drawEditor();
            updateAllTja();
        }

        /**
         * ã‚³ãƒ”ãƒ¼ã®é–‹å§‹ä½ç½®ã‚’ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ã«è¨­å®šã—ã¾ã™ã€‚
         */
        function setCopyStart() {
            selectionStart = { ...cursor };
            drawEditor(); // ãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã«å†æç”»
        }

        /**
         * ã‚³ãƒ”ãƒ¼ã®çµ‚äº†ä½ç½®ã‚’ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ã«è¨­å®šã—ã€ãã®é–“ã®éŸ³ç¬¦ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
         * Fnã‚­ãƒ¼ã®ä»£ã‚ã‚Šã«Altã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
         */
        function setCopyEndAndCopy() {
            if (!selectionStart) return;

            let start = selectionStart;
            let end = { ...cursor };

            // é–‹å§‹ç‚¹ã¨çµ‚äº†ç‚¹ãŒé€†ã®å ´åˆã€å…¥ã‚Œæ›¿ãˆã‚‹
            if (start.measure > end.measure || (start.measure === end.measure && start.pos > end.pos)) {
                [start, end] = [end, start];
            }

            clipboard = [];
            for (let m = start.measure; m <= end.measure; m++) {
                if (!chartData[m]) continue;
                const measureData = chartData[m];
                const startPos = (m === start.measure) ? start.pos : 0;
                const endPos = (m === end.measure) ? end.pos + 1 : measureData.notes.length;
                
                const notesToCopy = measureData.notes.slice(startPos, endPos);
                
                if(notesToCopy.length > 0) {
                    clipboard.push({ notes: notesToCopy, commands: [] }); // ã‚³ãƒãƒ³ãƒ‰ã¯ã‚³ãƒ”ãƒ¼ã—ãªã„ä»•æ§˜
                }
            }
            
            selectionStart = null; // é¸æŠã‚’ãƒªã‚»ãƒƒãƒˆ
            drawEditor(); // ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¶ˆã™ãŸã‚ã«å†æç”»
        }

        /**
         * ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã®å†…å®¹ã‚’ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«è²¼ã‚Šä»˜ã‘ã¾ã™ã€‚
         */
        function pasteFromClipboard() {
            if (!clipboard || clipboard.length === 0) return;

            saveStateForUndo(); // è²¼ã‚Šä»˜ã‘å‰ã«çŠ¶æ…‹ã‚’ä¿å­˜

            let targetM = cursor.measure;
            let targetP = cursor.pos;

            for (const clipMeasure of clipboard) {
                for (const noteToPaste of clipMeasure.notes) {
                    while (!chartData[targetM]) {
                        addMeasure(false, false); // å°ç¯€ãŒãªã‘ã‚Œã°è¿½åŠ ï¼ˆUndoå±¥æ­´ã«ã¯æ®‹ã•ãªã„ï¼‰
                    }
                    const targetMeasureNotes = chartData[targetM].notes;

                    if (targetP >= targetMeasureNotes.length) {
                        targetM++;
                        targetP = 0;
                        continue;
                    }

                    targetMeasureNotes[targetP] = { ...noteToPaste }; // ãƒãƒ¼ãƒˆã‚’ã‚³ãƒ”ãƒ¼ã—ã¦è²¼ã‚Šä»˜ã‘
                    targetP++;
                }
            }
            drawEditor();
            updateAllTja();
        }
        // â–²â–²â–²ã“ã“ã¾ã§â–²â–²â–²
        
        function updateAllTja() {
            let tjaString = "";
            chartData.forEach((measure) => {
                measure.commands.forEach(cmd => { tjaString += cmd + "\n"; });
                tjaString += measure.notes.map(n => n.type).join("") + ",\n";
            });
            inputs.chart.value = tjaString;
            updateTjaText();
        }
        
        tjaInput.addEventListener('change', function(e) {
            if (e.target.files.length === 0) return;
            const file = e.target.files[0];
            const reader = new FileReader();
            
            reader.onload = function(evt) {
                const buffer = evt.target.result;
                let text = "";
                
                try {
                    const decoder = new TextDecoder("utf-8", { fatal: true });
                    text = decoder.decode(buffer);
                } catch (e) {
                    try {
                        const decoder = new TextDecoder("shift-jis");
                        text = decoder.decode(buffer);
                    } catch (e2) {
                        console.error("Encoding detection failed", e2);
                        alert("ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰åˆ¤å®šã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                        return;
                    }
                }
                
                parseAndLoadTja(text);
                tjaInput.value = '';
            };
            
            reader.readAsArrayBuffer(file);
        });

        function parseAndLoadTja(tjaText) {
            try {
                history = []; // è­œé¢ã‚’èª­ã¿è¾¼ã‚“ã ã‚‰Undoå±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆ
                const titleMatch = tjaText.match(/TITLE:(.*)/i);
                if(titleMatch) inputs.title.value = titleMatch[1].trim();
                
                const subtitleMatch = tjaText.match(/SUBTITLE:(.*)/i);
                if(subtitleMatch) inputs.subtitle.value = subtitleMatch[1].trim();

                const bpmMatch = tjaText.match(/BPM:([0-9.]+)/i);
                if(bpmMatch) inputs.bpm.value = bpmMatch[1].trim();
                
                const offsetMatch = tjaText.match(/OFFSET:([0-9.-]+)/i);
                if(offsetMatch) inputs.offset.value = offsetMatch[1].trim();

                const levelMatch = tjaText.match(/LEVEL:([0-9]+)/i);
                if(levelMatch) inputs.level.value = levelMatch[1].trim();
                
                const balloonMatch = tjaText.match(/BALLOON:(.*)/i);
                const balloonHits = balloonMatch ? balloonMatch[1].trim().split(',').map(Number) : [];
                let balloonIndex = 0;

                const startIdx = tjaText.toUpperCase().indexOf('#START');
                const endIdx = tjaText.toUpperCase().indexOf('#END');
                if (startIdx === -1) { alert("æœ‰åŠ¹ãªTJAãƒ•ã‚¡ã‚¤ãƒ«ã§ã¯ã‚ã‚Šã¾ã›ã‚“ (#STARTãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“)"); return; }

                const chartPart = tjaText.substring(startIdx + 6, endIdx === -1 ? tjaText.length : endIdx);
                const lines = chartPart.split('\n');
                
                const newChartData = [];
                let currentNotesStr = "";
                let currentCommands = [];

                lines.forEach(line => {
                    line = line.trim();
                    if (!line || line.startsWith('//')) return;

                    if (line.startsWith('#')) {
                        const parts = line.split(' ');
                        let commandName = parts[0].toUpperCase();
                        currentCommands.push(commandName + (parts.length > 1 ? ' ' + parts.slice(1).join(' ') : ''));
                    } else {
                        const commaIndex = line.indexOf(',');
                        if (commaIndex !== -1) {
                            currentNotesStr += line.substring(0, commaIndex);
                            const notesArr = currentNotesStr.split('').map(c => (c >= '0' && c <= '9') ? c : '0');
                            const noteObjects = notesArr.map(noteType => {
                                if (noteType === '7') {
                                    const hits = balloonHits[balloonIndex] || 5;
                                    balloonIndex++;
                                    return { type: '7', hits: hits };
                                }
                                return { type: noteType };
                            });

                            if (noteObjects.length > 0) {
                                newChartData.push({ notes: noteObjects, commands: [...currentCommands] });
                            }
                            
                            currentNotesStr = line.substring(commaIndex + 1); 
                            currentCommands = [];
                        } else {
                            currentNotesStr += line;
                        }
                    }
                });

                if (newChartData.length > 0) {
                    chartData = newChartData;
                    currentGrid = chartData[chartData.length-1].notes.length;
                    gridSelect.value = [4,8,12,16,24,32,48].includes(currentGrid) ? currentGrid : "16";
                    
                    cursor = { measure: 0, pos: 0 };
                    drawEditor();
                    updateAllTja();
                    alert("è­œé¢ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼");
                } else {
                    alert("è­œé¢ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
                }
            } catch(e) { console.error(e); alert("TJAãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); }
        }

        updateTjaText = function() {
            let waveName = fileInput.files[0] ? fileInput.files[0].name : "music.ogg";
            
            const balloonHits = [];
            chartData.forEach(measure => {
                measure.notes.forEach(note => {
                    if (note.type === '7' && note.hits) {
                        balloonHits.push(note.hits);
                    }
                });
            });
            const balloonHeader = balloonHits.length > 0 ? `BALLOON:${balloonHits.join(',')}\n` : '';

            let tja = `TITLE:${inputs.title.value}\nSUBTITLE:${inputs.subtitle.value}\nBPM:${inputs.bpm.value}\nWAVE:${waveName}\nOFFSET:${inputs.offset.value}\n${balloonHeader}COURSE:Oni\nLEVEL:${inputs.level.value}\n\n#START\n${inputs.chart.value}`;
            if (!tja.endsWith('\n')) tja += '\n';
            tja += '#END';
            inputs.out.value = tja;
        };
        
        async function downloadZip() {
            if (!window.JSZip) { alert("JSZip library failed to load."); return; }
            if (!window.Encoding) { alert("Encoding library failed to load."); return; }
            
            const zip = new JSZip();
            const title = inputs.title.value || "New Song";
            
            const tjaString = inputs.out.value;
            
            const sjisCodeArray = Encoding.convert(Encoding.stringToCode(tjaString), {
                to: 'SJIS',
                from: 'UNICODE'
            });
            
            const sjisUint8Array = new Uint8Array(sjisCodeArray);
            zip.file(`${title}.tja`, sjisUint8Array);
            
            if (fileInput.files.length > 0) { const file = fileInput.files[0]; zip.file(file.name, file); }
            try { const content = await zip.generateAsync({type: "blob"}); const a = document.createElement('a'); a.href = URL.createObjectURL(content); a.download = `${title}.zip`; a.click(); } catch (err) { console.error(err); alert("ZIPä½œæˆã‚¨ãƒ©ãƒ¼"); }
        }
        
        // --- PASTE UNCHANGED FUNCTIONS HERE ---
        initEditor();
        async function runAdvancedBpmAnalysis() { if (!musicBuffer) { alert("éŸ³æ¥½ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"); return; } statusText.innerText = "âš¡ é«˜ç²¾åº¦è§£æä¸­..."; setTimeout(async () => { try { const offlineContext = new OfflineAudioContext(1, musicBuffer.length, musicBuffer.sampleRate); const source = offlineContext.createBufferSource(); source.buffer = musicBuffer; const filter = offlineContext.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 140; filter.Q.value = 1; source.connect(filter); filter.connect(offlineContext.destination); source.start(0); const renderedBuffer = await offlineContext.startRendering(); const audioData = renderedBuffer.getChannelData(0); const peaks = getPeaksWithDynamicThreshold(audioData, musicBuffer.sampleRate); const bpm = calculateBPMFromPeaks(peaks, musicBuffer.sampleRate); if (bpm > 0) { const doubledBpm = bpm * 2; const choice = prompt(`BPMè§£æçµæœ:\n\n1: é€šå¸¸BPM: ${bpm.toFixed(1)}\n2: å€é€ŸBPM: ${doubledBpm.toFixed(1)}\n\nã©ã¡ã‚‰ã‚’é©ç”¨ã—ã¾ã™ã‹ï¼Ÿ (1ã‹2ã‚’å…¥åŠ›)`, "1"); let finalBpm = bpm; if (choice === "2") finalBpm = doubledBpm; else if (choice !== "1" && choice !== null) alert("ç„¡åŠ¹ãªé¸æŠã§ã™ã€‚é€šå¸¸BPMã‚’é©ç”¨ã—ã¾ã™ã€‚"); if (choice !== null) { inputs.bpm.value = finalBpm.toFixed(2); updateTjaText(); } statusText.innerText = "âœ… è§£æå®Œäº†"; } else { alert("BPMã‚’æ¤œå‡ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚"); statusText.innerText = "âš ï¸ æ¤œå‡ºä¸èƒ½"; } } catch(e) { console.error(e); alert("è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"); statusText.innerText = "âŒ è§£æã‚¨ãƒ©ãƒ¼"; } }, 100); }
        function getPeaksWithDynamicThreshold(data, sampleRate) { const peaks = []; const chunkSize = sampleRate; const thresholdMultiplier = 0.9; for (let i = 0; i < data.length; i += chunkSize) { const chunk = data.slice(i, i + chunkSize); let max = 0; for (let j = 0; j < chunk.length; j++) if (chunk[j] > max) max = chunk[j]; const threshold = max * thresholdMultiplier; for (let j = 1; j < chunk.length - 1; j++) { if (chunk[j] > threshold && chunk[j] > chunk[j - 1] && chunk[j] > chunk[j + 1]) peaks.push(i + j); } } return peaks; }
        function calculateBPMFromPeaks(peaks, sampleRate) { if (peaks.length < 10) return 0; const intervals = []; for (let i = 1; i < peaks.length; i++) intervals.push((peaks[i] - peaks[i - 1]) / sampleRate); const bpmCandidates = intervals.map(interval => 60 / interval).filter(bpm => bpm > 40 && bpm < 240); if (bpmCandidates.length === 0) return 0; const bpmGroups = {}; bpmCandidates.forEach(bpm => { const roundedBpm = Math.round(bpm); bpmGroups[roundedBpm] = (bpmGroups[roundedBpm] || 0) + 1; }); let maxCount = 0; let dominantGroup = 0; for (const bpm in bpmGroups) { if (bpmGroups[bpm] > maxCount) { maxCount = bpmGroups[bpm]; dominantGroup = Number(bpm); } } while (dominantGroup < 70) dominantGroup *= 2; while (dominantGroup > 180) dominantGroup /= 2; return dominantGroup; }
        initAudio = function() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); };
        fileInput.addEventListener('change', async function (e) { if (e.target.files.length === 0) return; statusText.innerText = "â³ èª­ã¿è¾¼ã¿ä¸­..."; btnPlay.disabled = true; btnAutoBpm.disabled = true; initAudio(); try { const file = e.target.files[0]; const arrayBuffer = await file.arrayBuffer(); audioCtx.decodeAudioData(arrayBuffer, (buffer) => { musicBuffer = buffer; statusText.innerText = "âœ… éŸ³æ¥½æº–å‚™OK"; btnPlay.disabled = false; btnAutoBpm.disabled = false; if (inputs.title.value === "New Song") inputs.title.value = file.name.replace(/\.[^/.]+$/, ""); updateTjaText(); }, (err) => { console.error(err); statusText.innerText = "âŒ èª­è¾¼å¤±æ•—"; alert("éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"); }); } catch (err) { console.error(err); statusText.innerText = "âŒ ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼"; alert("ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ã¾ã›ã‚“ã§ã—ãŸã€‚"); } });
        toggleMetro = function() { isMetroOn = !isMetroOn; btnMetro.innerText = isMetroOn ? "â° ON" : "â° OFF"; btnMetro.classList.toggle("active", isMetroOn); };
        playSound = function (type) { if (!audioCtx) return; const now = audioCtx.currentTime; const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.connect(gain); gain.connect(audioCtx.destination); if (type === 'metro_high') { osc.frequency.setValueAtTime(1200, now); osc.type = 'square'; const vol = 0.2 * volMetro; gain.gain.setValueAtTime(vol, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05); osc.start(now); osc.stop(now + 0.05); } else if (type === 'metro_low') { osc.frequency.setValueAtTime(800, now); osc.type = 'square'; const vol = 0.15 * volMetro; gain.gain.setValueAtTime(vol, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05); osc.start(now); osc.stop(now + 0.05); } else if (type === 'don') { osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.15); gain.gain.setValueAtTime(1.4 * volSe, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15); osc.start(now); osc.stop(now + 0.2); } else { osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.1); gain.gain.setValueAtTime(1.2 * volSe, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.2); } }

        const previewCanvas = document.getElementById('previewCanvas'); const previewCtx = previewCanvas.getContext('2d'); let animationId, startTime = 0, isPlaying = false, isPreviewPaused = false; const HIT_X = 150, PREVIEW_Y = 80, BASE_SPEED = 300;
        
        parseTJA = function () {
            const lines = inputs.chart.value.split('\n');
            const startBpm = parseFloat(inputs.bpm.value) || 120;
            const offset = parseFloat(inputs.offset.value) || 0;
            let currentTime = -offset;
            let currentBpm = startBpm;
            let currentScroll = 1.0;
            let measureRatio = 1.0;
            let parsedNotes = [], parsedClicks = [], parsedBarlines = [], gogoSections = [], parsedRolls = [];
            let isGogo = false;
            let gogoStart = -1;
            let rollStartTime = -1, rollType = null, rollScroll = 1.0;

            lines.forEach(line => {
                line = line.trim();
                if (!line) return;
                if (line.startsWith('#')) {
                    const parts = line.split(' ');
                    const cmd = parts[0].toUpperCase();
                    const val = parseFloat(parts[1]);
                    if (cmd === '#BPMCHANGE' && !isNaN(val)) currentBpm = val;
                    if (cmd === '#SCROLL' && !isNaN(val)) currentScroll = val;
                    if (cmd === '#MEASURE') {
                        const frac = parts[1].split('/');
                        if (frac.length === 2) measureRatio = parseFloat(frac[0]) / parseFloat(frac[1]);
                    }
                    if (cmd === '#GOGOSTART') { isGogo = true; gogoStart = currentTime; }
                    if (cmd === '#GOGOEND') { isGogo = false; if(gogoStart !== -1) { gogoSections.push({start: gogoStart, end: currentTime}); gogoStart = -1; } }
                    return;
                }
                if (line.endsWith(',')) {
                    const data = line.slice(0, -1);
                    const len = data.length;
                    const measureTime = (60 / currentBpm) * 4 * measureRatio;
                    if (len > 0) {
                        const timePerChar = measureTime / len;
                        for (let i = 0; i < len; i++) {
                            const char = data[i];
                            const noteTime = currentTime + (i * timePerChar);

                            if (['5', '6', '7'].includes(char) && rollStartTime === -1) {
                                rollStartTime = noteTime;
                                rollType = char;
                                rollScroll = currentScroll;
                            } else if (char === '8' && rollStartTime !== -1) {
                                parsedRolls.push({ start: rollStartTime, end: noteTime, type: rollType, scroll: rollScroll });
                                rollStartTime = -1;
                            }
                            
                            if (char !== '0') {
                                parsedNotes.push({ time: noteTime, type: ['2', '4'].includes(char) ? 'kat' : 'don', char: char, scroll: currentScroll, isBig: ['3', '4', '6'].includes(char), isGogo: isGogo });
                            }
                        }
                    }
                    const beatsPerMeasure = 4 * measureRatio;
                    const timePerBeat = 60 / currentBpm;
                    for (let b = 0; b < beatsPerMeasure; b++) {
                        if (b * timePerBeat < measureTime) {
                            parsedClicks.push({ time: currentTime + (b * timePerBeat), type: b === 0 ? 'metro_high' : 'metro_low' });
                        }
                    }
                    currentTime += measureTime;
                    parsedBarlines.push({ time: currentTime, scroll: currentScroll });
                }
            });
            if(isGogo) gogoSections.push({start: gogoStart, end: currentTime});
            return { notes: parsedNotes, clicks: parsedClicks, barlines: parsedBarlines, gogoSections: gogoSections, rolls: parsedRolls };
        }
        
        loop = function () {
            if (!isPlaying) return;
            previewCtx.fillStyle = '#222';
            previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            const now = audioCtx.currentTime - startTime;
            const data = window.currentData;
            const laneY = PREVIEW_Y;

            // èƒŒæ™¯ã¨GOGO TIMEã®æç”»
            let currentIsGogo = false;
            data.gogoSections.forEach(gogo => {
                if(now >= gogo.start && now < gogo.end) currentIsGogo = true;
            });
            previewCtx.fillStyle = currentIsGogo ? '#602020' : '#444';
            previewCtx.fillRect(0, laneY - 30, previewCanvas.width, 60);

            // åˆ¤å®šå††ã®æç”»
            previewCtx.beginPath();
            previewCtx.arc(HIT_X, laneY, 26, 0, Math.PI * 2);
            previewCtx.strokeStyle = '#fff';
            previewCtx.lineWidth = 3;
            previewCtx.stroke();
            
            // ãƒ¡ãƒˆãƒ­ãƒãƒ¼ãƒ éŸ³ã®å†ç”Ÿ
            if (isMetroOn) {
                data.clicks.forEach(click => {
                    if (click.time <= now && !click.played) {
                        click.played = true;
                        if (now - click.time < 0.1) playSound(click.type);
                    }
                });
            }
            
            // å°ç¯€ç·šã®æç”»
            if (data.barlines) {
                previewCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                previewCtx.lineWidth = 1;
                data.barlines.forEach(barline => {
                    const timeDiff = barline.time - now;
                    const x = HIT_X + (timeDiff * BASE_SPEED * barline.scroll);
                    if (x > 0 && x < previewCanvas.width) {
                        previewCtx.beginPath();
                        previewCtx.moveTo(x, laneY - 30);
                        previewCtx.lineTo(x, laneY + 30);
                        previewCtx.stroke();
                    }
                });
            }

            // é€£æ‰“ãƒ»é¢¨èˆ¹ã®ãƒãƒ¼ã‚’æç”» (ãƒãƒ¼ãƒˆã‚ˆã‚Šå¥¥ã«æç”»)
            if (data.rolls) {
                data.rolls.forEach(roll => {
                    const timeDiffStart = roll.start - now;
                    const timeDiffEnd = roll.end - now;

                    const startX = HIT_X + (timeDiffStart * BASE_SPEED * roll.scroll);
                    const endX = HIT_X + (timeDiffEnd * BASE_SPEED * roll.scroll);

                    if (endX > 0 && startX < previewCanvas.width) {
                        const isBig = roll.type === '6';
                        const isBalloon = roll.type === '7';
                        
                        if (isBalloon) {
                            previewCtx.fillStyle = 'rgba(230, 126, 34, 0.6)';
                        } else {
                            previewCtx.fillStyle = isBig ? 'rgba(241, 196, 15, 0.6)' : 'rgba(241, 196, 15, 0.4)';
                        }

                        const y = laneY - (isBig ? 22 : 15);
                        const height = isBig ? 44 : 30;
                        previewCtx.fillRect(startX, y, endX - startX, height);
                    }
                });
            }
            
            const notesToDraw = [];
            const effectsToDraw = [];

            data.notes.forEach(note => {
                const timeDiff = note.time - now;
                const x = HIT_X + (timeDiff * BASE_SPEED * note.scroll);

                if (timeDiff <= 0 && !note.played) {
                    note.played = true;
                    if (['1', '2', '3', '4'].includes(note.char)) {
                        playSound(note.type);
                        effectsToDraw.push({ x: HIT_X, y: laneY });
                    }
                }
                if (x > -50 && x < previewCanvas.width + 50) {
                    notesToDraw.push({x: x, y: laneY, noteObj: { type: note.char }});
                }
            });

            for (let i = notesToDraw.length - 1; i >= 0; i--) {
                const note = notesToDraw[i];
                drawNote(previewCtx, note.x, note.y, note.noteObj);
            }

            effectsToDraw.forEach(effect => {
                previewCtx.fillStyle = '#fff';
                previewCtx.beginPath();
                previewCtx.arc(effect.x, effect.y, 22, 0, Math.PI * 2);
                previewCtx.fill();
            });

            // çµ‚äº†åˆ¤å®š
            const lastEventTime = Math.max(
                data.notes.length ? data.notes[data.notes.length - 1].time : 0,
                data.rolls.length ? data.rolls[data.rolls.length - 1].end : 0
            );
            if (lastEventTime > 0 && now > lastEventTime + 2) {
                stopPreview();
                return;
            }
            animationId = requestAnimationFrame(loop);
        }
        
        window.addEventListener('keydown', (e) => {
            if (document.activeElement === canvasWrapper || !isPlaying || !musicBuffer) return;

            const JUMP_AMOUNT = 2.0; // 2ç§’
            let currentTime = audioCtx.currentTime - startTime;

            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault(); // ãƒšãƒ¼ã‚¸ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã

                if (e.key === 'ArrowUp') { // æ—©é€ã‚Š
                    currentTime += JUMP_AMOUNT;
                } else if (e.key === 'ArrowDown') { // æ—©æˆ»ã—
                    currentTime -= JUMP_AMOUNT;
                }
                
                // å†ç”Ÿæ™‚é–“ã®ä¸Šé™ã¨ä¸‹é™ã‚’è¨­å®š
                const duration = musicBuffer.duration;
                if (currentTime > duration) currentTime = duration;
                if (currentTime < 0) currentTime = 0;

                // ç¾åœ¨ã®éŸ³æ¥½ã‚’åœæ­¢
                if (musicSource) {
                    try { musicSource.stop(); } catch (err) {}
                }

                // æ–°ã—ã„å†ç”Ÿä½ç½®ã‚ˆã‚Šæœªæ¥ã«ã‚ã‚‹ãƒãƒ¼ãƒˆã¨ã‚¯ãƒªãƒƒã‚¯ã®å†ç”ŸçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                window.currentData.notes.forEach(n => { if (n.time >= currentTime) n.played = false; });
                window.currentData.clicks.forEach(c => { if (c.time >= currentTime) c.played = false; });

                // æ–°ã—ã„å†ç”Ÿé–‹å§‹åŸºæº–æ™‚é–“ã‚’è¨­å®š
                startTime = audioCtx.currentTime - currentTime;

                // æ–°ã—ã„ä½ç½®ã‹ã‚‰éŸ³æ¥½ã‚’å†ç”Ÿ
                musicSource = audioCtx.createBufferSource();
                musicSource.buffer = musicBuffer;
                const musicGain = audioCtx.createGain();
                musicGain.gain.value = 0.7;
                musicSource.connect(musicGain);
                musicGain.connect(audioCtx.destination);
                musicSource.start(audioCtx.currentTime, currentTime);
            }
        });

        function togglePlayback() {
            if (!isPlaying) {
                startPreview();
            } else {
                if (isPreviewPaused) {
                    // Resume
                    if (audioCtx.state === 'suspended') {
                        audioCtx.resume();
                    }
                    isPreviewPaused = false;
                    btnPlay.innerText = 'âšâš ä¸€æ™‚åœæ­¢';
                    loop();
                } else {
                    // Pause
                    if (audioCtx.state === 'running') {
                        audioCtx.suspend();
                    }
                    isPreviewPaused = true;
                    cancelAnimationFrame(animationId);
                    btnPlay.innerText = 'â–¶ å†ç”Ÿ';
                }
            }
        }
        
        startPreview = function () {
            initAudio();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            stopPreview(); 
            window.currentData = parseTJA();
            if (window.currentData.notes.length === 0 && window.currentData.gogoSections.length === 0 && window.currentData.rolls.length === 0) return;
            startTime = audioCtx.currentTime + 0.1;
            isPlaying = true;
            isPreviewPaused = false;
            if (musicBuffer) {
                musicSource = audioCtx.createBufferSource();
                musicSource.buffer = musicBuffer;
                const musicGain = audioCtx.createGain();
                musicGain.gain.value = 0.7;
                musicSource.connect(musicGain);
                musicGain.connect(audioCtx.destination);
                musicSource.start(startTime);
            }
            loop();
            btnPlay.innerText = 'âšâš ä¸€æ™‚åœæ­¢';
            btnPlay.disabled = false;
        }

        stopPreview = function () {
            isPlaying = false;
            isPreviewPaused = false;
            cancelAnimationFrame(animationId);
            if (musicSource) {
                try { musicSource.stop(); } catch (e) { }
                musicSource = null;
            }
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            previewCtx.fillStyle = '#222';
            previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            btnPlay.innerText = 'â–¶ å†ç”Ÿ';
            btnPlay.disabled = musicBuffer ? false : true;
        }
    </script>
</body>
</html>
