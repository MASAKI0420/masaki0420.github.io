<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>HTML製 osu!taiko シミュレーター</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f0f0f0; color: #333; text-align: center; margin: 0; padding: 20px; }
        #container { max-width: 800px; margin: 0 auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); position: relative; }
        h1 { color: #d9534f; }
        #game-area { position: relative; width: 100%; height: 150px; background-color: #222; border-radius: 8px; overflow: hidden; margin: 20px 0; }
        #countdown { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 80px; font-weight: bold; color: white; display: none; text-shadow: 2px 2px 4px #000; }
        canvas { display: block; width: 100%; height: 100%; }
        #controls, #instructions, #settings { margin-bottom: 20px; }
        input[type="file"], input[type="number"], input[type="checkbox"], button, select { padding: 10px 15px; border-radius: 5px; border: 1px solid #ccc; cursor: pointer; margin: 5px; vertical-align: middle; }
        input[type="text"] { width: 30px; text-align: center; font-size: 1em; padding: 8px; border-radius: 5px; border: 1px solid #ccc; }
        button { background-color: #5cb85c; color: white; border-color: #4cae4c; }
        button:hover { background-color: #4cae4c; }
        button:disabled { background-color: #ccc; border-color: #999; cursor: not-allowed; }
        #pause-button { background-color: #f0ad4e; border-color: #eea236; }
        #pause-button:hover { background-color: #eea236; }
        #restart-button { background-color: #d9534f; border-color: #d43f3a; }
        #restart-button:hover { background-color: #d43f3a; }
        #status { font-size: 1.2em; font-weight: bold; color: #31708f; }
        .key-display { display: inline-block; padding: 5px 10px; border: 1px solid #ccc; border-radius: 4px; background-color: #f7f7f7; margin: 0 5px; font-family: monospace; }
        
        #result-screen {
            display: none; position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            z-index: 100; box-sizing: border-box;
            flex-direction: column;
            align-items: center; 
            padding-top: 350px;
        }
        #result-screen h2 { color: white; border-bottom: 2px solid #ccc; padding-bottom: 10px; margin-bottom: 5px; }
        #result-song-title { color: #eee; font-size: 1.5em; margin-top: 0; margin-bottom: 10px; font-weight: normal; }
        #result-screen p { font-size: 1.2em; margin: 10px 0; }
        
        .setting-item { display: inline-block; margin: 5px 15px 5px 0; }
        #key-config { margin-top: 15px; }
        #key-config h3 { margin-bottom: 10px; }
        .volume-control { display: block; margin: 10px auto; width: 80%; text-align: right; }
        .volume-control label { margin-right: 10px; }
        .volume-control input[type="range"] { vertical-align: middle; width: 60%; }
    </style>
</head>
<body>
    <div id="container">
        <h1>HTML製 osu!taiko シミュレーター</h1>
        <div id="instructions">
            <h2>遊び方</h2>
            <p>1. 譜面ファイル(.osu)と音楽ファイルを選択し、必要であれば各種設定を行います。</p>
            <p>2. 「ゲーム開始」ボタンを押すと3秒後にゲームが始まります。</p>
            <p>※大音符は両手で叩くとスコアが2倍になります（設定で片手処理も可能）。GOGO TIME中はスコアにボーナスが付きます。</p>
            <div> ドン (内側): <span class="key-display" id="display-don-left">D</span> <span class="key-display" id="display-don-right">K</span> </div>
            <div> カッ (外側): <span class="key-display" id="display-katsu-left">S</span> <span class="key-display" id="display-katsu-right">L</span> </div>
        </div>
        <div id="settings">
            <div class="setting-item"> <label for="osu-file">譜面 (.osu):</label> <input type="file" id="osu-file" accept=".osu"> </div>
            <div class="setting-item"> <label for="audio-file">音楽:</label> <input type="file" id="audio-file" accept="audio/*"> </div>
            <hr>
            <div class="setting-item"> <label for="don-sound-file">SE ドン:</label> <input type="file" id="don-sound-file" accept="audio/*"> </div>
            <div class="setting-item"> <label for="katsu-sound-file">SE カッ:</label> <input type="file" id="katsu-sound-file" accept="audio/*"> </div> <hr>
            <div class="volume-control">
                <label for="music-volume">音楽 音量:</label>
                <input type="range" id="music-volume" min="0" max="100" value="80">
            </div>
            <div class="volume-control">
                <label for="se-volume">SE 音量:</label>
                <input type="range" id="se-volume" min="0" max="100" value="100">
            </div> <hr>
            <div class="setting-item"> <label for="offset-input">オフセット (ms):</label> <input type="number" id="offset-input" value="0" style="width: 70px;"> </div>
            <div class="setting-item"> <label for="scroll-speed-input">スクロール速度:</label> <input type="number" id="scroll-speed-input" value="0" step="0.1" min="-6" style="width: 60px;"> </div>
            <div class="setting-item"> <input type="checkbox" id="auto-play-checkbox"> <label for="auto-play-checkbox">オートプレイ</label> </div>
            <div class="setting-item"> <input type="checkbox" id="auto-se-checkbox"> <label for="auto-se-checkbox">SE自動再生</label> </div>
            <div class="setting-item"> <input type="checkbox" id="single-hand-big-note-checkbox"> <label for="single-hand-big-note-checkbox">大音符を片手で処理する</label> </div>
            <div id="key-config">
                <h3>キー設定</h3>
                <div class="setting-item"> <label>ドン(左): </label> <input type="text" id="key-don-left" value="d" maxlength="1"> </div>
                <div class="setting-item"> <label>ドン(右): </label> <input type="text" id="key-don-right" value="k" maxlength="1"> </div>
                <div class="setting-item"> <label>カッ(左): </label> <input type="text" id="key-katsu-left" value="s" maxlength="1"> </div>
                <div class="setting-item"> <label>カッ(右): </label> <input type="text" id="key-katsu-right" value="l" maxlength="1"> </div>
            </div>
        </div>
        <div id="controls"> <button id="start-button">ゲーム開始</button> <button id="pause-button" disabled>ポーズ</button> <button id="restart-button" disabled>やり直し</button> </div>
        <div id="status">ファイルを準備してください</div>
        <div id="game-area"> <canvas id="game-canvas"></canvas> <div id="countdown"></div> </div>
        <div> <h2>Score: <span id="score">0</span></h2> <h2>Combo: <span id="combo">0</span></h2> </div>
        <div id="result-screen">
            <h2>リザルト</h2>
            <h3 id="result-song-title"></h3>
            <p>最終スコア: <span id="result-score">0</span></p>
            <p>最大コンボ: <span id="result-max-combo">0</span></p> <hr>
            <p style="color: gold;">良: <span id="result-ryo">0</span></p>
            <p style="color: white;">可: <span id="result-ka">0</span></p>
            <p style="color: #B19CD9;">不可: <span id="result-fuka">0</span></p> <hr>
            <button id="back-to-title-button">タイトルへ戻る</button>
        </div>
    </div>

    <script>
        const osuFileInput = document.getElementById('osu-file');
        const audioFileInput = document.getElementById('audio-file');
        const donSoundFileInput = document.getElementById('don-sound-file');
        const katsuSoundFileInput = document.getElementById('katsu-sound-file');
        const musicVolumeSlider = document.getElementById('music-volume');
        const seVolumeSlider = document.getElementById('se-volume');
        const startButton = document.getElementById('start-button');
        const pauseButton = document.getElementById('pause-button');
        const restartButton = document.getElementById('restart-button');
        const offsetInput = document.getElementById('offset-input');
        const autoPlayCheckbox = document.getElementById('auto-play-checkbox');
        const autoSeCheckbox = document.getElementById('auto-se-checkbox');
        const singleHandBigNoteCheckbox = document.getElementById('single-hand-big-note-checkbox');
        const scrollSpeedInput = document.getElementById('scroll-speed-input');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const countdownEl = document.getElementById('countdown');
        const statusEl = document.getElementById('status');
        const scoreEl = document.getElementById('score');
        const comboEl = document.getElementById('combo');
        const resultScreen = document.getElementById('result-screen');
        const backToTitleButton = document.getElementById('back-to-title-button');
        const keyDonLeftInput = document.getElementById('key-don-left');
        const keyDonRightInput = document.getElementById('key-don-right');
        const keyKatsuLeftInput = document.getElementById('key-katsu-left');
        const keyKatsuRightInput = document.getElementById('key-katsu-right');
        const displayDonLeft = document.getElementById('display-don-left');
        const displayDonRight = document.getElementById('display-don-right');
        const displayKatsuLeft = document.getElementById('display-katsu-left');
        const displayKatsuRight = document.getElementById('display-katsu-right');
        
        let fileContent = null, audioSrc = null, donSoundSrc = null, katsuSoundSrc = null;
        let songTitle = '';
        let hitObjects = [], audio, barLines = [], goGoSections = [];
        let isPlaying = false, isPaused = false, isAutoPlay = false, isAutoSe = false, isGoGoNow = false;
        let isSingleHandBigNoteEnabled = false;
        let score = 0, combo = 0, offset = 0, maxCombo = 0;
        let animationFrameId = null;
        const BASE_SCROLL_SPEED = 6; 
        let uiScrollSpeed = BASE_SCROLL_SPEED;
        let gameStartTime = 0, audioStartTime = 0, pauseStartTime = 0;
        let judgementCounts = { ryo: 0, ka: 0, fuka: 0 };
        const HIT_WINDOW_PERFECT = 25, HIT_WINDOW_GOOD = 70, HIT_WINDOW_BAD = 100;
        let KEY_MAPPINGS = {};
        
        let activeRollHits = 0;
        let rollCounterClearTime = 0;
        let musicVolume = 0.8;
        let seVolume = 1.0;
        let lastCheckedNoteIndex = 0;
        
        let pressedKeys = new Set();

        function updateKeyMappings() {
            KEY_MAPPINGS = {};
            KEY_MAPPINGS[keyDonLeftInput.value.toLowerCase()] = 'don';
            KEY_MAPPINGS[keyDonRightInput.value.toLowerCase()] = 'don';
            KEY_MAPPINGS[keyKatsuLeftInput.value.toLowerCase()] = 'katsu';
            KEY_MAPPINGS[keyKatsuRightInput.value.toLowerCase()] = 'katsu';
            displayDonLeft.textContent = keyDonLeftInput.value.toUpperCase();
            displayDonRight.textContent = keyDonRightInput.value.toUpperCase();
            displayKatsuLeft.textContent = keyKatsuLeftInput.value.toUpperCase();
            displayKatsuRight.textContent = keyKatsuRightInput.value.toUpperCase();
        }

        osuFileInput.addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;

            if (!file.name.toLowerCase().endsWith('.osu')) {
                alert('対応している譜面ファイル形式は .osu のみです。');
                e.target.value = '';
                fileContent = null;
                return;
            }

            const reader = new FileReader();
            reader.onload = e => {
                fileContent = e.target.result;
                statusEl.textContent = '譜面ファイルを読み込みました。';
            };
            reader.readAsText(file, 'utf-8');
        });

        audioFileInput.addEventListener('change', e => { if (e.target.files[0]) { audioSrc = URL.createObjectURL(e.target.files[0]); statusEl.textContent = '音楽ファイルを読み込みました。'; } });
        donSoundFileInput.addEventListener('change', e => { if (e.target.files[0]) { donSoundSrc = URL.createObjectURL(e.target.files[0]); statusEl.textContent = 'ドン(SE)を読み込みました。'; } });
        katsuSoundFileInput.addEventListener('change', e => { if (e.target.files[0]) { katsuSoundSrc = URL.createObjectURL(e.target.files[0]); statusEl.textContent = 'カッ(SE)を読み込みました。'; } });
        musicVolumeSlider.addEventListener('input', e => { musicVolume = e.target.value / 100; if (audio) audio.volume = musicVolume; });
        seVolumeSlider.addEventListener('input', e => { seVolume = e.target.value / 100; });
        offsetInput.addEventListener('change', () => { offset = parseInt(offsetInput.value, 10) || 0; });
        autoPlayCheckbox.addEventListener('change', e => { isAutoPlay = e.target.checked; });
        autoSeCheckbox.addEventListener('change', e => { isAutoSe = e.target.checked; });
        singleHandBigNoteCheckbox.addEventListener('change', e => { isSingleHandBigNoteEnabled = e.target.checked; });
        scrollSpeedInput.addEventListener('change', () => { const modifier = parseFloat(scrollSpeedInput.value); uiScrollSpeed = (!isNaN(modifier) ? BASE_SCROLL_SPEED + modifier : BASE_SCROLL_SPEED); if (uiScrollSpeed < 1) uiScrollSpeed = 1; });
        [keyDonLeftInput, keyDonRightInput, keyKatsuLeftInput, keyKatsuRightInput].forEach(input => input.addEventListener('input', e => { e.target.value = e.target.value.toLowerCase(); updateKeyMappings(); }));
        pauseButton.addEventListener('click', togglePause);
        restartButton.addEventListener('click', restartGame);
        backToTitleButton.addEventListener('click', () => { resultScreen.style.display = 'none'; statusEl.textContent = 'ファイルを準備してください'; });

        startButton.addEventListener('click', () => {
            if (!fileContent || !audioSrc) {
                alert('譜面ファイルと音楽ファイルの両方を選択してください。');
                return;
            }
            endGame(); 
            if (parseFile()) {
                setupGame(); 
                startCountdown();
            } else {
                alert("譜面の解析に失敗しました。ファイルが破損しているか、対応していない形式の可能性があります。");
                statusEl.textContent = "譜面の解析に失敗しました。";
            }
        });
        
        function parseFile() {
            if (fileContent && fileContent.toUpperCase().includes('[HITOBJECTS]')) {
                return parseOsuFile();
            }
            return false;
        }

        function parseOsuFile() {
            try {
                hitObjects = []; barLines = []; goGoSections = [];
                songTitle = '不明な曲';
                let uninheritedTimingPoints = [];
                let velocityChanges = [];
                const allTimingPoints = [];
                const lines = fileContent.split('\n').map(l => l.trim());
                let section = '';
                let sliderMultiplier = 1.4;

                for (const line of lines) {
                    if (line.startsWith('[')) { section = line; continue; }
                    if (!section) continue;

                    if (section === '[Metadata]') {
                        if (line.toLowerCase().startsWith('title:')) {
                            songTitle = line.substring(line.indexOf(':') + 1).trim();
                        }
                    } else if (section === '[Difficulty]') {
                        if (line.startsWith('SliderMultiplier:')) sliderMultiplier = parseFloat(line.split(':')[1]);
                    } else if (section === '[TimingPoints]') {
                        const parts = line.split(',');
                        if (parts.length < 2) continue;
                        const time = parseFloat(parts[0]);
                        const val = parseFloat(parts[1]);
                        const meter = parts.length > 2 ? parseInt(parts[2], 10) : 4;
                        const kiai = parts.length > 7 ? (parseInt(parts[7], 10) & 1) !== 0 : false;
                        allTimingPoints.push({ time, kiai });
                        if (val > 0) {
                            uninheritedTimingPoints.push({ time, beatLength: val, meter });
                        } else if (val < 0) {
                            velocityChanges.push({ time, multiplier: -100 / val });
                        }
                    }
                }
                
                if (uninheritedTimingPoints.length === 0) uninheritedTimingPoints.push({time: 0, beatLength: 500, meter: 4});
                velocityChanges.sort((a,b) => a.time - b.time);

                const getScrollMultiplier = (time) => {
                    for (let i = velocityChanges.length - 1; i >= 0; i--) {
                        if (velocityChanges[i].time <= time) {
                            return velocityChanges[i].multiplier;
                        }
                    }
                    return 1.0;
                };
                
                section = '';
                for (const line of lines) {
                    if (line.startsWith('[')) { section = line; continue; }
                    if (section !== '[HitObjects]') continue;
                    const parts = line.split(',');
                    if (parts.length < 5) continue;
                    const time = parseInt(parts[2], 10), type = parseInt(parts[3], 10), hitSound = parseInt(parts[4], 10);
                    const isBig = (hitSound & 4) !== 0;
                    const scrollMultiplier = getScrollMultiplier(time);
                    const noteProps = { time, judged: false, scrollSpeed: scrollMultiplier };

                    if (type & 2) {
                        const parentTimingPoint = uninheritedTimingPoints.findLast(p => p.time <= time) || uninheritedTimingPoints[0];
                        const pixelLength = parseFloat(parts[7]);
                        const duration = pixelLength / (sliderMultiplier * scrollMultiplier * 100) * parentTimingPoint.beatLength;
                        hitObjects.push({ ...noteProps, type: 'roll', isBig, endTime: time + duration, lastAutoHitTime: 0, hitsMade: 0 });
                    } else if (type & 8) {
                        const endTime = parseInt(parts[5], 10);
                        const duration = endTime - time;
                        const hitsRequired = Math.max(3, Math.ceil(duration / 200));
                        hitObjects.push({ ...noteProps, type: 'balloon', endTime, hitsRequired, hitsMade: 0, lastAutoHitTime: 0 });
                    } else if (type & 1) {
                        let noteType = 'don';
                        if ((hitSound & 2) || (hitSound & 8)) noteType = 'katsu';
                        hitObjects.push({ ...noteProps, type: noteType, isBig, autoSePlayed: false });
                    }
                }

                allTimingPoints.sort((a,b) => a.time - b.time);
                let kiaiActive = false, kiaiStartTime = 0;
                const lastNoteTime = hitObjects.reduce((max, note) => Math.max(max, note.endTime || note.time), 0);
                for(const point of allTimingPoints) {
                    if(point.kiai && !kiaiActive) {
                        kiaiActive = true; kiaiStartTime = point.time;
                    } else if (!point.kiai && kiaiActive) {
                        kiaiActive = false; goGoSections.push({start: kiaiStartTime, end: point.time});
                    }
                }
                if(kiaiActive) goGoSections.push({start: kiaiStartTime, end: lastNoteTime + 5000});

                if (uninheritedTimingPoints.length > 0 && hitObjects.length > 0) {
                    for (let i = 0; i < uninheritedTimingPoints.length; i++) {
                        const currentPoint = uninheritedTimingPoints[i];
                        const measureLength = currentPoint.beatLength * currentPoint.meter;
                        if(measureLength <= 0) continue;
                        const barEndTime = (i + 1 < uninheritedTimingPoints.length) ? uninheritedTimingPoints[i+1].time : lastNoteTime + 2000;
                        for(let t = currentPoint.time; t < barEndTime; t += measureLength) {
                            barLines.push({time: t, scrollSpeed: getScrollMultiplier(t)});
                        }
                    }
                }
                
                return hitObjects.length > 0;
            } catch (error) {
                console.error("Error during .osu parsing:", error);
                return false;
            }
        }
        
        function setupGame() {
            const rect = canvas.parentElement.getBoundingClientRect(); canvas.width = rect.width; canvas.height = rect.height;
            score = 0; combo = 0; maxCombo = 0;
            // songTitle = ''; // This line is removed to prevent song title from being cleared
            judgementCounts = { ryo: 0, ka: 0, fuka: 0 };
            activeRollHits = 0;
            rollCounterClearTime = 0;
            lastCheckedNoteIndex = 0;
            isGoGoNow = false;
            pressedKeys.clear();
            scoreEl.textContent = score; comboEl.textContent = combo;
            if (audio) audio.pause(); 
            audio = new Audio(audioSrc);
            audio.volume = musicVolume;
            resultScreen.style.display = 'none';
        }
        
        function startCountdown() {
            if (hitObjects.length === 0) { alert("譜面の読み込みに失敗したか、ノーツがありません。"); return; }
            startButton.disabled = true; pauseButton.disabled = false; restartButton.disabled = false;
            
            let count = 3;
            countdownEl.textContent = count;
            
            const gameStartDelay = 3000;
            
            countdownEl.style.display = 'block';
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.textContent = count;
                } else {
                    countdownEl.style.display = 'none';
                    clearInterval(countdownInterval);
                }
            }, 1000);

            statusEl.textContent = isAutoPlay ? "オートプレイを開始します..." : "まもなく開始します...";
            gameStartTime = performance.now();
            audioStartTime = gameStartTime + gameStartDelay;
            isPlaying = true; isPaused = false;
            animationFrameId = requestAnimationFrame(gameLoop);
            
            setTimeout(() => {
                if (isPlaying && !isPaused) {
                    audio.play();
                    statusEl.textContent = isAutoPlay ? "オートプレイ中..." : "ゲーム中！";
                }
            }, gameStartDelay);
        }
        
        function gameLoop() {
            if (!isPlaying) return;
            if (!isPaused) {
                const currentTime = performance.now();
                const elapsedTime = currentTime - audioStartTime - offset;
                
                if (rollCounterClearTime > 0 && elapsedTime >= rollCounterClearTime) {
                    activeRollHits = 0; rollCounterClearTime = 0;
                }
                
                isGoGoNow = false;
                for (const section of goGoSections) {
                    if (elapsedTime >= section.start && elapsedTime < section.end) {
                        isGoGoNow = true; break;
                    }
                }
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGameArea(isGoGoNow);
                drawBarLines(elapsedTime);
                drawNotes(elapsedTime);
                drawRollCounter(elapsedTime);

                if (isAutoPlay) autoPlay(elapsedTime);
                else {
                    if (isAutoSe) {
                        for (const note of hitObjects) {
                            if (!note.autoSePlayed && (note.type === 'don' || note.type === 'katsu') && elapsedTime >= note.time) {
                                playHitSound(note.type);
                                note.autoSePlayed = true;
                            }
                        }
                    }
                    checkMisses(elapsedTime);
                }

                const allNotesJudged = hitObjects.every(n => n.judged);
                if (allNotesJudged && hitObjects.length > 0) {
                    const lastNoteEndTime = hitObjects.reduce((max, note) => Math.max(max, note.endTime || note.time), 0);
                    if (elapsedTime > lastNoteEndTime + 200 + 2000) {
                        endGame(true); return;
                    }
                } else if (audio.ended) {
                    endGame(true); return;
                }
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function drawBarLines(elapsedTime) {
            const judgePointX = canvas.width * 0.2;
            const pixelMultiplier = uiScrollSpeed * 0.1;
            ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2; ctx.globalAlpha = 0.8;
            barLines.forEach(line => {
                const timeToJudge = line.time - elapsedTime;
                const x = judgePointX + timeToJudge * line.scrollSpeed * pixelMultiplier;

                if (x > canvas.width + 50 || x < -50) return;
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            });
            ctx.globalAlpha = 1.0;
        }
        
        function drawNotes(elapsedTime) {
            const judgePointX = canvas.width * 0.2;
            const y = canvas.height / 2;
            const pixelMultiplier = uiScrollSpeed * 0.1;

            for (const note of hitObjects) {
                if (note.judged) continue;
                
                const timeToJudge = note.time - elapsedTime;
                const startX = judgePointX + timeToJudge * note.scrollSpeed * pixelMultiplier;

                if (note.type === 'roll' || note.type === 'balloon') {
                    const timeToEnd = note.endTime - elapsedTime;
                    const endX = judgePointX + timeToEnd * note.scrollSpeed * pixelMultiplier;

                    if (endX < -50 || startX > canvas.width + 50) continue;
                    
                    if (note.type === 'roll') {
                        const barHeight = note.isBig ? 80 : 54;
                        const radius = barHeight / 2;
                        ctx.fillStyle = "gold"; ctx.lineWidth = 2; ctx.strokeStyle = '#fff';
                        ctx.beginPath(); ctx.rect(startX, y - radius, endX - startX, barHeight); ctx.fill(); ctx.stroke();
                        ctx.beginPath(); ctx.arc(startX, y, radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                        ctx.strokeStyle = 'gold'; 
                        ctx.beginPath(); ctx.arc(endX, y, radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    } else { // balloon
                        const radius = 35;
                        if (startX < judgePointX && endX > judgePointX) {
                            ctx.beginPath(); ctx.fillStyle = "orange"; ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
                            ctx.arc(judgePointX, y, radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                            const remainingHits = note.hitsRequired - note.hitsMade;
                            if (remainingHits > 0) {
                                ctx.fillStyle = '#fff'; ctx.font = 'bold 24px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                                ctx.fillText(remainingHits, judgePointX, y);
                            }
                        } else if (startX >= judgePointX && startX <= canvas.width + radius) {
                           ctx.beginPath(); ctx.fillStyle = "orange"; ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
                           ctx.arc(startX, y, radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                        }
                    }
                } else { // don, katsu
                    if (startX > canvas.width + 50 || startX < -50) continue;
                    const radius = note.isBig ? 40 : 27;
                    ctx.beginPath(); ctx.fillStyle = note.type === 'don' ? '#ff0000' : '#00BFFF';
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
                    ctx.arc(startX, y, radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                }
            }
        }
        
        function autoPlay(elapsedTime) {
            const AUTO_HIT_INTERVAL = 25; // 25ms = 40 hits/sec
            for (const note of hitObjects) {
                if (note.judged) continue;
                if (note.type === 'balloon' || note.type === 'roll') {
                    if (elapsedTime >= note.time && elapsedTime <= note.endTime) {
                         if (elapsedTime - (note.lastAutoHitTime || 0) > AUTO_HIT_INTERVAL) {
                            playHitSound('don');
                            let hitScore = 100;
                            if (isGoGoNow) hitScore *= 1.2;
                            score += hitScore;
                            note.hitsMade++;
                            showHitEffect('yellow');
                            if (note.type === 'roll') {
                                activeRollHits = note.hitsMade; rollCounterClearTime = 0; 
                            } else if (note.type === 'balloon' && note.hitsMade >= note.hitsRequired) {
                                let burstBonus = 5000;
                                if (isGoGoNow) burstBonus *= 1.2;
                                score += burstBonus;
                                note.judged = true;
                            }
                            scoreEl.textContent = Math.floor(score);
                            note.lastAutoHitTime = elapsedTime;
                         }
                    }
                    if (elapsedTime > note.endTime && !note.judged) {
                        if (note.type === 'roll' && note.hitsMade > 0) rollCounterClearTime = elapsedTime + 2000;
                        note.judged = true;
                    }
                } else if (elapsedTime >= note.time) {
                    let baseScore = 300;
                    if (note.isBig) baseScore *= 2;
                    playHitSound(note.type); updateScore(baseScore); updateCombo(true); 
                    showHitEffect('gold'); showJudgement("良");
                    judgementCounts.ryo++; note.judged = true;
                }
            }
        }
        
        function endGame(isFinished = false) {
            isPlaying = false; isPaused = false;
            if(animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null;
            if (audio) audio.pause();
            if (isFinished) { statusEl.textContent = `ゲーム終了！結果を確認してください。`; displayResult(); }
            pauseButton.disabled = true; restartButton.disabled = true; startButton.disabled = false;
        }

        function displayResult() {
            document.getElementById('result-song-title').textContent = songTitle;
            document.getElementById('result-score').textContent = Math.floor(score);
            document.getElementById('result-max-combo').textContent = maxCombo;
            document.getElementById('result-ryo').textContent = judgementCounts.ryo;
            document.getElementById('result-ka').textContent = judgementCounts.ka;
            document.getElementById('result-fuka').textContent = judgementCounts.fuka;
            resultScreen.style.display = 'flex';
        }

        function drawGameArea(isGoGoNow) {
            const judgePointX = canvas.width * 0.2, y = canvas.height / 2;
            if (isGoGoNow) {
                const fireGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                fireGradient.addColorStop(0, "rgba(255, 100, 0, 0.4)");
                fireGradient.addColorStop(0.5, "rgba(255, 69, 0, 0.6)");
                fireGradient.addColorStop(1, "rgba(255, 100, 0, 0.4)");
                ctx.fillStyle = fireGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(judgePointX, y, 45, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.arc(judgePointX, y, 27, 0, Math.PI * 2); ctx.stroke();
        }
        
        document.addEventListener('keyup', (e) => {
            pressedKeys.delete(e.key.toLowerCase());
        });

        document.addEventListener('keydown', (e) => {
            if (isAutoPlay || !isPlaying || isPaused || e.repeat) return;
            const currentTime = performance.now();
            const elapsedTime = currentTime - audioStartTime - offset;
            if (elapsedTime < 0) return;

            const key = e.key.toLowerCase();
            if (KEY_MAPPINGS[key]) {
                pressedKeys.add(key);
            } else {
                return;
            }
            
            const keyType = KEY_MAPPINGS[key];

            // Part 1: Check for a bonus hit (only if single-hand mode is OFF)
            if (!isSingleHandBigNoteEnabled) {
                for (let i = lastCheckedNoteIndex; i >= 0; i--) {
                    const note = hitObjects[i];
                    if (note && note.judged && note.isBig && !note.bonusApplied) {
                        const timeSinceHit = elapsedTime - note.judgementTime;
                        if (timeSinceHit < 80 && note.type === keyType) {
                            const donLeftKey = keyDonLeftInput.value.toLowerCase();
                            const donRightKey = keyDonRightInput.value.toLowerCase();
                            const katsuLeftKey = keyKatsuLeftInput.value.toLowerCase();
                            const katsuRightKey = keyKatsuRightInput.value.toLowerCase();
                            const isDonBonus = note.type === 'don' && pressedKeys.has(donLeftKey) && pressedKeys.has(donRightKey);
                            const isKatsuBonus = note.type === 'katsu' && pressedKeys.has(katsuLeftKey) && pressedKeys.has(katsuRightKey);

                            if (isDonBonus || isKatsuBonus) {
                                note.bonusApplied = true;
                                const basePoints = (note.judgement === 'ryo') ? 300 : (note.judgement === 'ka') ? 100 : 0;
                                if (basePoints > 0) { updateScore(basePoints); showHitEffect('gold'); }
                                return; 
                            }
                        }
                        if (timeSinceHit >= 80) break;
                    }
                }
            }

            // Part 2: Handle long note hits (Rolls/Balloons)
            let isLongNoteHit = false;
            for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) {
                const note = hitObjects[i];
                if (note.judged) continue;
                if (elapsedTime >= note.time && elapsedTime <= note.endTime + HIT_WINDOW_BAD) {
                    if (note.type === 'roll' && (note.isBig || keyType === 'don')) {
                        if (!isAutoSe) playHitSound('don');
                        let rollHitScore = note.isBig ? 200 : 100;
                        if (isGoGoNow) rollHitScore *= 1.2;
                        score += rollHitScore;
                        note.hitsMade++; activeRollHits = note.hitsMade;
                        rollCounterClearTime = 0;
                        scoreEl.textContent = Math.floor(score);
                        isLongNoteHit = true;
                    } else if (note.type === 'balloon' && keyType === 'don') {
                        if (!isAutoSe) playHitSound('don');
                        note.hitsMade++;
                        let balloonHitScore = 300;
                        if (isGoGoNow) balloonHitScore *= 1.2;
                        score += balloonHitScore;
                        scoreEl.textContent = Math.floor(score);
                        if (note.hitsMade >= note.hitsRequired) {
                            let balloonBurstBonus = 5000;
                            if (isGoGoNow) balloonBurstBonus *= 1.2;
                            score += balloonBurstBonus;
                            note.judged = true;
                        }
                        isLongNoteHit = true;
                    }
                }
                if (note.time > elapsedTime + 200) break; 
            }
            if (isLongNoteHit) return;

            // Part 3: Judge a new regular note
            let targetNote = null, minTimeDiff = Infinity;
            for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) {
                const note = hitObjects[i];
                if (note.judged || note.type === 'balloon' || note.type === 'roll') continue;
                const timeDiff = Math.abs(note.time - elapsedTime);
                if (timeDiff <= HIT_WINDOW_BAD) {
                    if (timeDiff < minTimeDiff) { minTimeDiff = timeDiff; targetNote = note; }
                }
                if (note.time > elapsedTime + HIT_WINDOW_BAD + 100) break;
            }

            if (targetNote) {
                targetNote.judged = true;
                targetNote.judgementTime = elapsedTime;
                targetNote.bonusApplied = false;

                if (targetNote.type === keyType) {
                    if (!isAutoSe) playHitSound(keyType);
                    let basePoints = 0;
                    let judgementText = '';

                    if (minTimeDiff <= HIT_WINDOW_PERFECT) { basePoints = 300; targetNote.judgement = 'ryo'; judgementText = "良"; judgementCounts.ryo++; }
                    else if (minTimeDiff <= HIT_WINDOW_GOOD) { basePoints = 100; targetNote.judgement = 'ka'; judgementText = "可"; judgementCounts.ka++; }
                    else { targetNote.judgement = 'fuka'; judgementText = "不可"; judgementCounts.fuka++; }

                    let scoreMultiplier = 1;
                    if (targetNote.isBig) {
                        if (isSingleHandBigNoteEnabled) {
                            scoreMultiplier = 2;
                            targetNote.bonusApplied = true;
                        } else {
                            const donLeftKey = keyDonLeftInput.value.toLowerCase();
                            const donRightKey = keyDonRightInput.value.toLowerCase();
                            const katsuLeftKey = keyKatsuLeftInput.value.toLowerCase();
                            const katsuRightKey = keyKatsuRightInput.value.toLowerCase();
                            const isDonHit = targetNote.type === 'don' && pressedKeys.has(donLeftKey) && pressedKeys.has(donRightKey);
                            const isKatsuHit = targetNote.type === 'katsu' && pressedKeys.has(katsuLeftKey) && pressedKeys.has(katsuRightKey);
                            if (isDonHit || isKatsuHit) { scoreMultiplier = 2; targetNote.bonusApplied = true; }
                        }
                    }

                    if (basePoints > 0) {
                        updateScore(basePoints * scoreMultiplier);
                        updateCombo(true);
                        showHitEffect(targetNote.judgement === 'ryo' ? 'gold' : 'white');
                    } else { updateCombo(false); }
                    showJudgement(judgementText);

                } else { 
                    targetNote.judgement = 'fuka';
                    updateCombo(false); 
                    showJudgement("不可"); 
                    judgementCounts.fuka++;
                }
            }
        });


        function checkMisses(elapsedTime) {
            for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) {
                const note = hitObjects[i];
                if (note.judged) {
                    if (i === lastCheckedNoteIndex) lastCheckedNoteIndex++;
                    continue;
                }
                if (note.time > elapsedTime + HIT_WINDOW_BAD) {
                    break;
                }
                if (note.type !== 'balloon' && note.type !== 'roll') {
                    if (elapsedTime > note.time + HIT_WINDOW_BAD) {
                        note.judged = true; updateCombo(false); showJudgement("不可"); judgementCounts.fuka++;
                    }
                } else {
                    if (elapsedTime > note.endTime) {
                        if (note.type === 'roll' && note.hitsMade > 0) rollCounterClearTime = elapsedTime + 2000;
                        note.judged = true;
                    }
                }
            }
        }
        
        function updateScore(points) {
            let currentPoints = points + (points * Math.floor(combo / 10) * 0.1);
            if(isGoGoNow) {
                currentPoints *= 1.2;
            }
            score += currentPoints;
            scoreEl.textContent = Math.floor(score);
        }

        function updateCombo(hit) {
             if (hit) { combo++; if (combo > maxCombo) maxCombo = combo; } else { combo = 0; } comboEl.textContent = combo;
        }
        
        function showJudgement(text) {
            const el = document.createElement('div');
            el.textContent = text;
            const judgePointX = canvas.width * 0.2, judgePointY = canvas.height / 2, verticalOffset = -45;
            Object.assign(el.style, { position: 'absolute', left: `${judgePointX}px`, top: `${judgePointY + verticalOffset}px`, fontSize: '30px', fontWeight: 'bold', pointerEvents: 'none', zIndex: '10', textShadow: '0 0 6px #000, 0 0 6px #000', transform: 'translate(-50%, -50%)' });
            switch(text) {
                case '良': el.style.color = 'gold'; break;
                case '可': el.style.color = 'white'; break;
                case '不可': el.style.color = '#B19CD9'; break;
            }
            canvas.parentElement.appendChild(el);
            el.animate([ { transform: 'translate(-50%, -50%) translateY(10px)', opacity: 0 }, { transform: 'translate(-50%, -50%) translateY(-15px)', opacity: 1, offset: 0.3 }, { transform: 'translate(-50%, -50%) translateY(0)', opacity: 1 } ], { duration: 100, easing: 'ease-out', fill: 'forwards' });
            setTimeout(() => { el.remove(); }, 300); 
        }
        
        function showHitEffect(color) {
            const effectEl = document.createElement('div');
            const judgePointX = canvas.width * 0.2, judgePointY = canvas.height / 2;
            Object.assign(effectEl.style, { position: 'absolute', left: `${judgePointX}px`, top: `${judgePointY}px`, width: '100px', height: '100px', transform: 'translate(-50%, -50%) scale(0.8)', border: `5px solid ${color}`, borderRadius: '50%', opacity: '0.8', transition: 'all 0.1s ease-out', pointerEvents: 'none', zIndex: 5 });
            canvas.parentElement.appendChild(effectEl);
            setTimeout(() => {
                effectEl.style.transform = 'translate(-50%, -50%) scale(1.2)';
                effectEl.style.opacity = '0';
                setTimeout(() => effectEl.remove(), 100);
            }, 10);
        }

        function drawRollCounter(elapsedTime) {
            if (activeRollHits > 0) {
                const judgePointX = canvas.width * 0.2, xPos = judgePointX * 0.4, y = canvas.height / 2;
                ctx.fillStyle = 'white'; ctx.font = 'bold 36px "Segoe UI"'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.shadowColor = 'black'; ctx.shadowBlur = 5;
                ctx.fillText(activeRollHits, xPos, y);
                ctx.shadowBlur = 0;
            }
        }

        function playHitSound(type) {
            const soundSrc = (type === 'don') ? donSoundSrc : katsuSoundSrc;
            if (soundSrc) {
                const hitSound = new Audio(soundSrc);
                hitSound.volume = seVolume;
                hitSound.play();
            }
        }

        function togglePause() {
            if (!isPlaying) return;
            isPaused = !isPaused;
            if (isPaused) {
                if (performance.now() >= audioStartTime) audio.pause();
                pauseStartTime = performance.now();
                pauseButton.textContent = '再開'; statusEl.textContent = "一時停止中";
            } else {
                const pauseDuration = performance.now() - pauseStartTime;
                audioStartTime += pauseDuration;
                if (performance.now() >= audioStartTime && !audio.ended) audio.play();
                pauseButton.textContent = 'ポーズ'; statusEl.textContent = "ゲーム中！";
            }
        }

        async function restartGame() {
            endGame();
            if(parseFile()){
                setupGame();
                startCountdown();
            }
        }
        
        updateKeyMappings();
    </script>
</body>
</html>```
