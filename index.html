<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Taiko Player</title>

    <!-- PWA対応 -->
    <meta name="theme-color" content="#d9534f">
    <link rel="manifest" id="manifest">
    <link rel="apple-touch-icon" id="apple-icon">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --panel-bg: #1f2940;
            --panel-text: #e0e5f0;
            --panel-border: #4a5578;
            --accent-color: #d9534f; /* Taiko風の赤色 */
            --disabled-color: #555c6f;
        }
        html, body {
            width: 100%;
            background-color: #0d0d1a;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin: 0;
            color: white;
        }
        #app-container {
            display: flex;
            justify-content: center;
            width: 100%;
            padding: 5vh 0;
            box-sizing: border-box;
        }
        
        #controls-panel {
            width: 95%; max-width: 520px;
            background-color: var(--panel-bg);
            border: 1px solid var(--panel-border);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            color: var(--panel-text);
            display: grid; grid-template-columns: 1fr 1fr;
            gap: 20px 15px;
            align-items: center;
        }
        #controls-panel::-webkit-scrollbar { width: 8px; }
        #controls-panel::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
        #controls-panel::-webkit-scrollbar-thumb { background-color: var(--panel-border); border-radius: 4px; }

        #game-container {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: #000;
            overflow: hidden;
            display: none;
            z-index: 10;
        }
        #background-video {
            position: absolute;
            top: -8%; left: 50%;
            transform: translate(-50%, -50%) scale(1.2);
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            object-fit: cover;
            z-index: 1;
            opacity: 0.5;
        }
        
       #background-image {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%) scale(0.45);
        min-width: 100%;
        min-height: 100%;
        width: auto;
        height: auto;
        object-fit: cover;
        z-index: 1;
        opacity: 0.5;
        }
        #playfield {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 80px;
            transform: translateY(-100%);
            background-color: transparent;
            z-index: 10;
        }
        #lane-visual {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(18, 18, 18, 0.85);
            box-shadow: 0 5px 25px rgba(0,0,0,0.3);
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 11;
        }
        
        .grid-item-full { grid-column: 1 / -1; }
        #controls-panel h2 { grid-column: 1 / -1; text-align: center; margin: 0 0 10px 0; font-size: 1.8em; font-weight: 600; color: var(--accent-color); }
        #controls-panel label { font-size: 0.9em; font-weight: 500; color: #a0a8c0; margin-bottom: 8px; display: block; }
        #controls-panel p { grid-column: 1 / -1; font-size: 0.8em; color: #828aa1; text-align: center; margin: 0; }
        input[type="file"] { width: 0.1px; height: 0.1px; opacity: 0; overflow: hidden; position: absolute; z-index: -1; }
        .file-input-label { display: inline-block; padding: 8px 15px; font-size: 0.9em; font-weight: 500; color: var(--panel-text); background-color: #394362; border: 1px solid var(--panel-border); border-radius: 6px; cursor: pointer; transition: background-color 0.2s; text-align: center;}
        .file-input-label:hover { background-color: #4a5578; }
        #file-name { margin-left: 10px; font-size: 0.9em; color: #a0a8c0; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 6px; background: #2a344d; border-radius: 3px; outline: none; cursor: pointer; box-sizing: border-box;}
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--accent-color); border-radius: 50%; cursor: pointer; }
        input[type="number"] { width: 100%; background-color: #2a344d; color: var(--panel-text); border: 1px solid var(--panel-border); border-radius: 6px; padding: 8px; text-align: center; font-size: 1em; box-sizing: border-box; }
        #key-config-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; }
        .key-config-item { display: flex; flex-direction: column; }
        .key-config-input { flex-grow: 1; height: 45px; background-color: #2a344d; border: 1px solid var(--panel-border); border-radius: 6px; color: var(--panel-text); font-size: 1.3em; font-weight: bold; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; user-select: none; }
        .key-config-input:hover { background-color: #394362; }
        .key-config-input.is-waiting { background-color: var(--accent-color); border-color: var(--accent-color); outline: none; color: white; }
        .checkbox-wrapper { display: flex; align-items: center; cursor: pointer; margin-bottom: 5px; }
        input[type="checkbox"] { display: none; }
        .custom-checkbox { width: 20px; height: 20px; background-color: #2a344d; border: 1px solid var(--panel-border); border-radius: 4px; display: inline-block; position: relative; margin-right: 10px; transition: background-color 0.2s; flex-shrink: 0; }
        input[type="checkbox"]:checked + .custom-checkbox { background-color: var(--accent-color); }
        .custom-checkbox::after { content: ''; position: absolute; left: 6px; top: 2px; width: 5px; height: 10px; border: solid white; border-width: 0 3px 3px 0; transform: rotate(45deg); display: none; }
        input[type="checkbox"]:checked + .custom-checkbox::after { display: block; }
        .control-button, select.control-button { width: 100%; padding: 12px; font-size: 1em; font-weight: 500; color: var(--panel-text); background-color: #394362; border: 1px solid var(--panel-border); border-radius: 8px; cursor: pointer; transition: background-color 0.2s; -webkit-appearance: none; text-align: center; }
        select.control-button { text-align-last: center;}
        .control-button:hover, select.control-button:hover { background-color: #4a5578; }
        #start-button { grid-column: 1 / -1; padding: 15px; font-size: 1.2em; font-weight: 600; color: white; background-color: var(--accent-color); border: none; }
        #start-button:disabled { background-color: var(--disabled-color); cursor: not-allowed; color: #8c92a3; }
        #song-info { grid-column: 1 / -1; min-height: 40px; text-align: center; }
        #ingame-pause-button { position: absolute; top: 20px; left: 20px; width: 48px; height: 48px; background-color: rgba(0,0,0,0.3); border: 2px solid white; border-radius: 8px; color: white; font-size: 1.8em; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 100; }
        #ui-panel {
            position: absolute; top: 20px; right: 30px;
            color: white; z-index: 20;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
            text-align: right;
            font-weight: 600;
        }
        #score { font-size: 2.5em; }
        #accuracy { font-size: 1.5em; color: #FFD700; }
        
        #combo-display {
            position: absolute;
            top: calc(50% + 10px);
            left: 30px;
            z-index: 20;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.2s, transform 0.2s;
        }
        #combo-display.visible {
            opacity: 1;
            transform: scale(1);
        }
        #combo { font-size: 4em; }
        #combo-label { font-size: 1em; margin-left: 2px; }

        #judgment-text {
            position: absolute;
            top: calc(50% - 140px);
            left: 220px;
            transform: translateX(-50%);
            font-size: 2.0em;
            font-weight: bold;
            opacity: 0; z-index: 22;
            padding: 5px 20px; border-radius: 4px;
            color: white; text-align: center;
            text-shadow: 0 0 8px #000, 0 0 8px #000;
            animation: judgment-anim-new 0.4s ease-out;
            pointer-events: none;
        }
        @keyframes judgment-anim-new {
            0% { transform: translateX(-50%) translateY(10px) scale(0.9); opacity: 0; }
            25% { transform: translateX(-50%) translateY(0) scale(1.05); opacity: 1; }
            80% { transform: translateX(-50%) translateY(0) scale(1); opacity: 1; }
            100% { transform: translateX(-50%) translateY(0) scale(1); opacity: 0; }
        }

        #progress-container {
            position: absolute;
            top: 10px;
            left: 50%;
            width: 40%;
            height: 8px;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.4);
            border-radius: 4px;
            z-index: 20;
            overflow: hidden;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background-color: #4dabf7;
            border-radius: 4px;
            transition: width 0.1s linear;
        }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: white; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 200; }
        .overlay-menu { text-align: center; padding: 30px 40px; background-color: var(--panel-bg); border-radius: 12px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .overlay-menu h2 { font-size: 2.8em; margin-top: 0; margin-bottom: 30px; letter-spacing: 2px;}
        .overlay-button { display: block; width: 220px; padding: 15px; margin: 12px auto; font-size: 1.2em; color: white; border: 2px solid var(--panel-border); background-color: #394362; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, transform 0.1s; }
        .overlay-button:hover { background-color: #4a5578; }
        .overlay-button:active { transform: scale(0.98); }
        
        /* ★★★ リザルト画面のスタイルここから ★★★ */
        #results-menu {
            transform: scale(0.8);
            transition: transform 0.2s;
        }
        #results-menu #results-song-title { font-size: 1.2em; color: #a0a8c0; margin-top: -20px; margin-bottom: 25px;}
        #results-menu .results-main-stats { display: flex; justify-content: space-around; align-items: center; gap: 20px; margin-bottom: 30px; width: 450px; }
        #results-menu .results-item { text-align: center; }
        .results-item span:first-child { display: block; font-size: 1em; color: #a0a8c0; margin-bottom: 5px;}
        .results-item span:last-child { font-size: 2em; font-weight: 600;}
        #results-rank-value { font-size: 3em; font-weight: bold; }
        .rank-s { color: gold; }
        .rank-a { color: #e5e4e2; }
        .rank-b { color: #cd7f32; }
        .rank-c { color: #87ceeb; }
        .rank-d { color: #dda0dd; }
        #results-menu .results-judgments { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 30px; text-align: center; }
        .judgment-item span:first-child { font-size: 1.2em; font-weight: bold;}
        #results-ryo { color: gold; }
        #results-ka { color: white; }
        #results-fuka { color: #dda0dd; }
        /* ★★★ リザルト画面のスタイルここまで ★★★ */


        #drum-display {
            position: absolute;
            width: 70px;
            height: 70px;
            top: calc(50% - 40px);
            left: 70px;
            transform: translateY(-50%);
            z-index: 15;
            pointer-events: none;
        }
        .drum-body {
            width: 100%;
            height: 100%;
            background-color: #d2b48c; 
            border: 8px solid #a0522d; 
            border-radius: 50%;
            box-sizing: border-box;
            position: absolute;
        }
        .drum-hit-area {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0; left: 0;
            border-radius: 50%;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.05s linear;
        }
        .drum-hit-area.active {
            opacity: 1;
        }
        #drum-don-left {
            background-color: rgba(255, 77, 109, 0.8);
            clip-path: polygon(0% 0%, 50% 0%, 50% 100%, 0% 100%);
        }
        #drum-don-right {
            background-color: rgba(255, 77, 109, 0.8);
            clip-path: polygon(50% 0%, 100% 0%, 100% 100%, 50% 100%);
        }
        #drum-katsu-left {
            border: 8px solid rgba(77, 171, 247, 0.9);
            clip-path: polygon(0% 0%, 50% 0%, 50% 100%, 0% 100%);
        }
        #drum-katsu-right {
            border: 8px solid rgba(77, 171, 247, 0.9);
            clip-path: polygon(50% 0%, 100% 0%, 100% 100%, 50% 100%);
        }
        
        #touch-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            -webkit-tap-highlight-color: transparent; 
            user-select: none;
        }
        
        #touch-drum-visual {
            position: absolute;
            bottom: var(--touch-drum-y-offset-vh, -5vh);
            left: 50%;
            transform: translateX(-50%) rotate(180deg);
            width: var(--touch-drum-size-vh, 90vh);
            height: var(--touch-drum-container-height-vh, 45vh);
            overflow: hidden;
            pointer-events: none;
            z-index: 4;
            opacity: var(--touch-drum-opacity, 0.3);
        }
        #touch-drum-visual::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 200%;
            border-radius: 50%;
            background: #cccccc; 
        }
        #touch-drum-visual::before {
            content: '';
            position: absolute;
            left: var(--touch-drum-rim-thickness-vh, 5vh);
            bottom: var(--touch-drum-rim-thickness-vh, 5vh);
            width: calc(100% - (var(--touch-drum-rim-thickness-vh, 5vh) * 2));
            height: calc(200% - (var(--touch-drum-rim-thickness-vh, 5vh) * 2));
            border-radius: 50%;
            background-color: white; 
            z-index: 5;
        }

        #orientation-warning {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: var(--panel-bg);
            color: var(--panel-text);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            text-align: center;
        }
        .orientation-message {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .orientation-message p {
            font-size: 1.2em;
            margin-top: 20px;
            line-height: 1.6;
        }

        #roll-counter {
            position: absolute;
            z-index: 25;
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 5px black, 0 0 5px black;
            transform: translateX(-50%);
            pointer-events: none;
            display: none;
        }

        #judgment-config-inputs { 
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr; 
            gap: 10px; 
        }
        .judgment-config-item > label {
            font-size: 0.8em;
            margin-bottom: 4px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="controls-panel">
            <h2>Taiko Player</h2>
            <div class="grid-item-full">
                <label for="osz-file">1. 譜面パッケージ (.osz) または .osu</label>
                <div style="display: flex; align-items: center;">
                    <label for="osz-file" class="file-input-label">ファイルを選択</label>
                    <span id="file-name" style="flex-grow: 1; text-align: right;">選択されていません</span>
                </div>
            </div>
            <input type="file" id="osz-file" accept=".osz,.osu">
            <div id="beatmap-selector-container" class="grid-item-full" style="display: none;">
                <label for="beatmap-selector">2. 譜面を選択</label>
                <select id="beatmap-selector" class="control-button"></select>
            </div>
            <div class="grid-item-full" id="song-info">
                <div id="song-title">譜面パッケージを選択してください</div>
                <div id="song-artist" style="font-size: 0.9em; color: #a0a8c0;"></div>
            </div>
            <div class="speed-control">
                <label for="speed-slider" id="speed-label">スクロール速度 (x1.0)</label>
                <input type="range" id="speed-slider" min="-5" max="5" value="0" step="0.1">
            </div>
            <div class="offset-control">
                <label for="offset-input">譜面オフセット (ms)</label>
                <input type="number" id="offset-input" value="0" step="5">
            </div>
            
            <div class="grid-item-full">
                <label>判定タイミング (ms)</label>
                <div id="judgment-config-inputs">
                     <div class="judgment-config-item">
                        <label for="hit-window-perfect-input">良 (PERFECT)</label>
                        <input type="number" id="hit-window-perfect-input" step="1">
                    </div>
                     <div class="judgment-config-item">
                        <label for="hit-window-good-input">可 (GREAT)</label>
                        <input type="number" id="hit-window-good-input" step="1">
                    </div>
                     <div class="judgment-config-item">
                        <label for="hit-window-bad-input">不可 (MISS)</label>
                        <input type="number" id="hit-window-bad-input" step="1">
                    </div>
                </div>
            </div>
            
            <div class="grid-item-full">
                <label>レーンカバー設定</label>
                <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 10px; align-items: center;">
                    <select id="lane-cover-type" class="control-button">
                        <option value="none">なし</option>
                        <option value="right">右から</option>
                    </select>
                    <div id="lane-cover-slider-container" style="display: none;">
                        <label for="lane-cover-slider" id="lane-cover-label" style="margin-bottom: 2px;">カバー量 (0%)</label>
                        <input type="range" id="lane-cover-slider" min="0" max="100" value="0" step="1">
                    </div>
                </div>
            </div>

            <div class="grid-item-full">
                <label for="touch-drum-size-slider" id="touch-drum-size-label">タッチ太鼓の大きさ (90vh)</label>
                <input type="range" id="touch-drum-size-slider" min="60" max="140" value="90" step="2">
            </div>

            <div class="grid-item-full">
                <label for="touch-drum-y-offset-slider" id="touch-drum-y-offset-label">タッチ太鼓のY軸オフセット (-5vh)</label>
                <input type="range" id="touch-drum-y-offset-slider" min="-40" max="10" value="-5" step="1">
            </div>

            <div class="grid-item-full">
                <label for="touch-drum-opacity-slider" id="touch-drum-opacity-label">タッチ太鼓の不透明度 (30%)</label>
                <input type="range" id="touch-drum-opacity-slider" min="0" max="100" value="30" step="1">
            </div>

            <div class="grid-item-full">
                <label>キー設定</label>
                <div id="key-config-inputs">
                     <div class="key-config-item">
                        <label>ドン (左)</label>
                        <div id="key-don-left" class="key-config-input" data-key-id="don_left" tabindex="0">D</div>
                    </div>
                    <div class="key-config-item">
                        <label>ドン (右)</label>
                        <div id="key-don-right" class="key-config-input" data-key-id="don_right" tabindex="0">K</div>
                    </div>
                    <div class="key-config-item">
                        <label>カッ (左)</label>
                        <div id="key-katsu-left" class="key-config-input" data-key-id="katsu_left" tabindex="0">S</div>
                    </div>
                    <div class="key-config-item">
                        <label>カッ (右)</label>
                        <div id="key-katsu-right" class="key-config-input" data-key-id="katsu_right" tabindex="0">L</div>
                    </div>
                </div>
            </div>
             <div class="assist-control">
                <label>プレイアシスト</label>
                <label for="auto-play-checkbox" class="checkbox-wrapper">
                    <input type="checkbox" id="auto-play-checkbox">
                    <span class="custom-checkbox"></span>
                    <span>オートプレイ</span>
                </label>
                 <label for="single-hand-big-note-checkbox" class="checkbox-wrapper">
                    <input type="checkbox" id="single-hand-big-note-checkbox" checked>
                    <span class="custom-checkbox"></span>
                    <span>大音符を片手で処理</span>
                </label>
            </div>
            <div class="file-input-wrapper">
                <label>サウンド設定</label>
                 <div style="display: flex; gap: 10px;">
                    <label for="don-sound-file" class="file-input-label">ドン(SE)</label>
                    <input type="file" id="don-sound-file" accept="audio/*">
                    <label for="katsu-sound-file" class="file-input-label">カッ(SE)</label>
                    <input type="file" id="katsu-sound-file" accept="audio/*">
                </div>
            </div>
            <div class="grid-item-full" style="display: flex; flex-direction: column; gap: 5px; margin-top: 10px;">
                 <button id="save-settings-button" class="control-button">設定を保存</button>
                 <p id="settings-status" style="text-align: center; font-size: 0.8em; color: #a0a8c0; margin: 0; min-height: 1em;"></p>
            </div>
            <button id="start-button" class="grid-item-full" disabled>ゲーム開始</button>
            <p class="grid-item-full">※ ESCキーでポーズ</p>
        </div>
    </div>

    <div id="game-container">
        <video id="background-video" autoplay muted loop playsinline></video>
        <img id="background-image" />
        <button id="ingame-pause-button">||</button>
        <div id="ui-panel">
            <div id="score">0</div>
            <div id="accuracy">100.00%</div>
        </div>
        <div id="combo-display">
            <span id="combo">0</span><span id="combo-label">x</span>
        </div>
        <div id="judgment-text"></div>
        <div id="drum-display">
            <div class="drum-body"></div>
            <div id="drum-don-left" class="drum-hit-area"></div>
            <div id="drum-don-right" class="drum-hit-area"></div>
            <div id="drum-katsu-left" class="drum-hit-area"></div>
            <div id="drum-katsu-right" class="drum-hit-area"></div>
        </div>
        <div id="playfield">
            <div id="lane-visual"></div>
            <canvas id="game-canvas"></canvas>
        </div>
        
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
        <div id="touch-controls"></div>
        <div id="touch-drum-visual"></div>
        <div id="roll-counter"></div>

        <div id="pause-overlay" class="overlay">
            <div id="pause-menu" class="overlay-menu">
                <h2>PAUSED</h2>
                <button id="resume-button" class="overlay-button">再開 (Resume)</button>
                <button id="retry-button" class="overlay-button">やり直し (Retry)</button>
                <button id="back-to-title-button-pause" class="overlay-button">タイトルへ戻る</button>
            </div>
        </div>
        <div id="results-overlay" class="overlay">
            <div id="results-menu" class="overlay-menu">
                <h2>RESULTS</h2>
                <div id="results-song-title">Song Title</div>
                 <div class="results-main-stats">
                    <div class="results-item">
                        <span>SCORE</span>
                        <span id="results-score-value">0</span>
                    </div>
                    <div class="results-item">
                        <span>RANK</span>
                        <span id="results-rank-value"></span>
                    </div>
                    <div class="results-item">
                        <span>MAX COMBO</span>
                        <span id="results-max-combo-value">0</span>
                    </div>
                </div>
                <div class="results-judgments">
                    <div class="judgment-item" id="results-ryo">
                        <span>良 (PERFECT)</span>
                        <span id="results-ryo-value">0</span>
                    </div>
                     <div class="judgment-item" id="results-ka">
                        <span>可 (GREAT)</span>
                        <span id="results-ka-value">0</span>
                    </div>
                     <div class="judgment-item" id="results-fuka">
                        <span>不可 (MISS)</span>
                        <span id="results-fuka-value">0</span>
                    </div>
                </div>
                <button id="results-retry-button" class="overlay-button">やり直し (Retry)</button>
                <button id="back-to-title-button-results" class="overlay-button">タイトルへ戻る</button>
            </div>
        </div>
    </div>
    
    <div id="orientation-warning">
        <div id="desktop-warning-message" class="orientation-message" style="display: none;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="80" height="80" fill="currentColor"><path d="M20,18H4V6H20M20,4H4A2,2,0,0,0,2,6V18A2,2,0,0,0,4,20H20A2,2,0,0,0,22,18V6A2,2,0,0,0,20,4Z"/></svg>
            <p>このサイトはスマートフォン専用です。<br>スマートフォンでお楽しみください。</p>
        </div>
        <div id="mobile-warning-message" class="orientation-message" style="display: none;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="80" height="80" fill="currentColor"><path d="M18.5,4H5.5A2.5,2.5,0,0,0,3,6.5v11A2.5,2.5,0,0,0,5.5,20h13A2.5,2.5,0,0,0,21,17.5V6.5A2.5,2.5,0,0,0,18.5,4ZM5.5,5.5h13a1,1,0,0,1,1,1v11a1,1,0,0,1-1,1H5.5a1,1,0,0,1-1-1V6.5A1,1,0,0,1,5.5,5.5Z"/></svg>
            <p>快適にプレイするために、<br>端末を横向きにしてください。</p>
        </div>
    </div>

    <audio id="audio-player"></audio>
    <script>
    const dom = {
        appContainer: document.getElementById('app-container'),
        gameContainer: document.getElementById('game-container'),
        oszFileInput: document.getElementById('osz-file'),
        fileName: document.getElementById('file-name'),
        beatmapSelectorContainer: document.getElementById('beatmap-selector-container'),
        beatmapSelector: document.getElementById('beatmap-selector'),
        songTitleElement: document.getElementById('song-title'),
        songArtistElement: document.getElementById('song-artist'),
        donSoundFileInput: document.getElementById('don-sound-file'),
        katsuSoundFileInput: document.getElementById('katsu-sound-file'),
        speedSlider: document.getElementById('speed-slider'),
        speedLabel: document.getElementById('speed-label'),
        offsetInput: document.getElementById('offset-input'),
        autoPlayCheckbox: document.getElementById('auto-play-checkbox'),
        singleHandBigNoteCheckbox: document.getElementById('single-hand-big-note-checkbox'),
        keyConfigInputs: document.getElementById('key-config-inputs'),
        startButton: document.getElementById('start-button'),
        backgroundVideo: document.getElementById('background-video'),
        backgroundImage: document.getElementById('background-image'),
        playfield: document.getElementById('playfield'),
        canvas: document.getElementById('game-canvas'),
        ctx: document.getElementById('game-canvas').getContext('2d'),
        ingamePauseButton: document.getElementById('ingame-pause-button'),
        scoreElement: document.getElementById('score'),
        accuracyElement: document.getElementById('accuracy'),
        comboElement: document.getElementById('combo'),
        comboDisplay: document.getElementById('combo-display'),
        judgmentTextElement: document.getElementById('judgment-text'),
        progressBar: document.getElementById('progress-bar'),
        pauseOverlay: document.getElementById('pause-overlay'),
        resumeButton: document.getElementById('resume-button'),
        retryButton: document.getElementById('retry-button'),
        backToTitlePause: document.getElementById('back-to-title-button-pause'),
        resultsOverlay: document.getElementById('results-overlay'),
        resultsSongTitle: document.getElementById('results-song-title'),
        resultsScoreValue: document.getElementById('results-score-value'),
        resultsRankValue: document.getElementById('results-rank-value'),
        resultsMaxComboValue: document.getElementById('results-max-combo-value'),
        resultsRyoValue: document.getElementById('results-ryo-value'),
        resultsKaValue: document.getElementById('results-ka-value'),
        resultsFukaValue: document.getElementById('results-fuka-value'),
        resultsRetryButton: document.getElementById('results-retry-button'),
        backToTitleResults: document.getElementById('back-to-title-button-results'),
        audioPlayer: document.getElementById('audio-player'),
        drumDonLeft: document.getElementById('drum-don-left'),
        drumDonRight: document.getElementById('drum-don-right'),
        drumKatsuLeft: document.getElementById('drum-katsu-left'),
        drumKatsuRight: document.getElementById('drum-katsu-right'),
        touchControls: document.getElementById('touch-controls'),
        laneCoverType: document.getElementById('lane-cover-type'),
        laneCoverSlider: document.getElementById('lane-cover-slider'),
        laneCoverLabel: document.getElementById('lane-cover-label'),
        touchDrumSizeSlider: document.getElementById('touch-drum-size-slider'),
        touchDrumSizeLabel: document.getElementById('touch-drum-size-label'),
        touchDrumYOffsetSlider: document.getElementById('touch-drum-y-offset-slider'),
        touchDrumYOffsetLabel: document.getElementById('touch-drum-y-offset-label'),
        touchDrumOpacitySlider: document.getElementById('touch-drum-opacity-slider'),
        touchDrumOpacityLabel: document.getElementById('touch-drum-opacity-label'),
        touchDrumVisual: document.getElementById('touch-drum-visual'),
        drumDisplay: document.getElementById('drum-display'),
        rollCounter: document.getElementById('roll-counter'),
        saveSettingsButton: document.getElementById('save-settings-button'),
        settingsStatus: document.getElementById('settings-status'),
        hitWindowPerfectInput: document.getElementById('hit-window-perfect-input'),
        hitWindowGoodInput: document.getElementById('hit-window-good-input'),
        hitWindowBadInput: document.getElementById('hit-window-bad-input'),
        orientationWarning: document.getElementById('orientation-warning'),
        desktopWarningMessage: document.getElementById('desktop-warning-message'),
        mobileWarningMessage: document.getElementById('mobile-warning-message'),
    };

    let KEYS = { don_left: 'D', don_right: 'K', katsu_left: 'S', katsu_right: 'L' };
    const BASE_SCROLL_SPEED = 6;
    let uiScrollSpeed = BASE_SCROLL_SPEED;
    
    let HIT_WINDOW_PERFECT = 25, HIT_WINDOW_GOOD = 75, HIT_WINDOW_BAD = 100;
    
    const JUDGE_POINT_X = 220;
    const taikoSizeMultiplier = 1.0; 
    let laneCoverConfig = { type: 'none', value: 0 };
    let fileContent = null, audioSrc = null, donSoundSrc = null, katsuSoundSrc = null;
    let songInfo = { title: '', artist: '', version: '', audioFilename: '' };
    let hitObjects = [], barLines = [], goGoSections = [];
    let donSound, katsuSound;
    let audioLoaded = false, beatmapLoaded = false;
    let isGameRunning = false, isPaused = false, isAutoPlay = false;
    let isSingleHandBigNoteEnabled = true;
    let score = 0, combo = 0, offset = 0, maxCombo = 0, accuracy = 100;
    let judgmentCounts = { ryo: 0, ka: 0, fuka: 0 };
    let animationFrameId = null;
    let lastNoteTime = 0;
    let gameStartTime = 0;
    let pauseStartTime = 0;
    let totalPauseDuration = 0;
    let pressedKeys = new Set();
    let osz_zip = null;
    let osz_beatmaps = [];
    let backgroundUrl = null;
    let backgroundType = null;
    let lastCheckedNoteIndex = 0;
    let activeRollHits = 0;
    let rollCounterClearTime = 0;
    let isGoGoNow = false;
    let drumHitTimeouts = {};

    function checkDeviceAndOrientation() {
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isPortrait = window.innerHeight > window.innerWidth;
        // A width threshold to guess if it's a desktop or a mobile device in "desktop view" mode.
        // 1024px is a common breakpoint for tablets, so anything wider is likely a desktop experience.
        const DESKTOP_WIDTH_THRESHOLD = 1024; 

        // The condition for showing the "PC/Desktop not supported" message is:
        // 1. It's not a touch-capable device (a real PC).
        // OR
        // 2. Its reported screen width is very large, which is typical for "Desktop Site" mode on mobile.
        if (!isTouchDevice || window.innerWidth >= DESKTOP_WIDTH_THRESHOLD) {
            dom.appContainer.style.display = 'none';
            dom.gameContainer.style.display = 'none';
            dom.mobileWarningMessage.style.display = 'none';
            dom.desktopWarningMessage.style.display = 'flex';
            dom.orientationWarning.style.display = 'flex';
            return; // Stop further checks
        }

        // If we reach here, it's a touch device with a "mobile-like" width.
        // Now, we just need to check its orientation.
        dom.desktopWarningMessage.style.display = 'none';
        dom.mobileWarningMessage.style.display = 'flex'; // Ensure the mobile message is the one ready to be shown

        if (isPortrait) {
            // It's a touch device, but in the wrong orientation.
            dom.appContainer.style.display = 'none';
            dom.gameContainer.style.display = 'none';
            dom.orientationWarning.style.display = 'flex';
        } else {
            // It's a touch device in the correct (landscape) orientation.
            dom.orientationWarning.style.display = 'none';
            if (!isGameRunning) {
                dom.appContainer.style.display = 'flex';
            } else {
                dom.gameContainer.style.display = 'block';
            }
        }
    }

    function parseOsuFile(content) {
        try {
            hitObjects = []; barLines = []; goGoSections = [];
            let uninheritedTimingPoints = [];
            let velocityChanges = [];
            const allTimingPoints = [];
            const lines = content.split('\n').map(l => l.trim());
            let section = '';
            let sliderMultiplier = 1.4;
            let foundTimingPoints = false;
            if (!Array.prototype.findLast) {
                Array.prototype.findLast = function(predicate) {
                    for (let i = this.length - 1; i >= 0; i--) {
                        if (predicate(this[i], i, this)) {
                            return this[i];
                        }
                    }
                    return undefined;
                };
            }
            for (const line of lines) {
                if (line.startsWith('[')) { section = line; continue; }
                if (!section) continue;
                if (section === '[General]' && line.toLowerCase().startsWith('audiofilename:')) songInfo.audioFilename = line.substring(line.indexOf(':') + 1).trim();
                else if (section === '[Metadata]') {
                    if (line.toLowerCase().startsWith('title:')) songInfo.title = line.substring(line.indexOf(':') + 1).trim();
                    else if (line.toLowerCase().startsWith('artist:')) songInfo.artist = line.substring(7).trim();
                    else if (line.toLowerCase().startsWith('version:')) songInfo.version = line.substring(8).trim();
                } else if (section === '[Difficulty]') {
                    if (line.startsWith('SliderMultiplier:')) sliderMultiplier = parseFloat(line.split(':')[1]);
                } else if (section === '[TimingPoints]') {
                    foundTimingPoints = true;
                    const parts = line.split(',');
                    if (parts.length < 2) continue;
                    const time = parseFloat(parts[0]);
                    const val = parseFloat(parts[1]);
                    const meter = parts.length > 2 ? parseInt(parts[2], 10) : 4;
                    const kiai = parts.length > 7 ? (parseInt(parts[7], 10) & 1) !== 0 : false;
                    allTimingPoints.push({ time, kiai });
                    if (val > 0) {
                        uninheritedTimingPoints.push({ time, beatLength: val, meter });
                    } else if (val < 0) {
                        velocityChanges.push({ time, multiplier: -100 / val });
                    }
                }
            }
            if (uninheritedTimingPoints.length === 0) {
                 uninheritedTimingPoints.push({time: 0, beatLength: 500, meter: 4});
            }
            velocityChanges.sort((a,b) => a.time - b.time);
            const getScrollMultiplier = (time) => {
                for (let i = velocityChanges.length - 1; i >= 0; i--) {
                    if (velocityChanges[i].time <= time) return velocityChanges[i].multiplier;
                }
                return 1.0;
            };
            section = '';
            for (const line of lines) {
                if (line.startsWith('[')) { section = line; continue; }
                if (section !== '[HitObjects]') continue;
                const parts = line.split(',');
                if (parts.length < 5) continue;
                const time = parseInt(parts[2], 10), type = parseInt(parts[3], 10), hitSound = parseInt(parts[4], 10);
                const isBig = (hitSound & 4) !== 0;
                const scrollMultiplier = getScrollMultiplier(time);
                const noteProps = { time, judged: false, scrollSpeed: scrollMultiplier };
                if (type & 2) {
                    const parentTimingPoint = uninheritedTimingPoints.findLast(p => p.time <= time) || uninheritedTimingPoints[0];
                    const pixelLength = parseFloat(parts[7]);
                    const duration = pixelLength / (sliderMultiplier * scrollMultiplier * 100) * parentTimingPoint.beatLength;
                    hitObjects.push({ ...noteProps, type: 'roll', isBig, endTime: time + duration, lastAutoHitTime: 0, hitsMade: 0 });
                } else if (type & 8) {
                    const endTime = parseInt(parts[5], 10);
                    const duration = endTime - time;
                    const hitsRequired = Math.max(3, Math.ceil(duration / 200));
                    hitObjects.push({ ...noteProps, type: 'balloon', endTime, hitsRequired, hitsMade: 0, lastAutoHitTime: 0 });
                } else if (type & 1) {
                    let noteType = 'don';
                    if ((hitSound & 2) || (hitSound & 8)) noteType = 'katsu';
                    hitObjects.push({ ...noteProps, type: noteType, isBig });
                }
            }
            allTimingPoints.sort((a,b) => a.time - b.time);
            let kiaiActive = false, kiaiStartTime = 0;
            const currentLastNoteTime = hitObjects.reduce((max, note) => Math.max(max, note.endTime || note.time), 0);
            for(const point of allTimingPoints) {
                if(point.kiai && !kiaiActive) {
                    kiaiActive = true; kiaiStartTime = point.time;
                } else if (!point.kiai && kiaiActive) {
                    kiaiActive = false; goGoSections.push({start: kiaiStartTime, end: point.time});
                }
            }
            if(kiaiActive) goGoSections.push({start: kiaiStartTime, end: currentLastNoteTime + 5000});
            if (uninheritedTimingPoints.length > 0 && hitObjects.length > 0) {
                for (let i = 0; i < uninheritedTimingPoints.length; i++) {
                    const currentPoint = uninheritedTimingPoints[i];
                    const measureLength = currentPoint.beatLength * currentPoint.meter;
                    if(measureLength <= 0) continue;
                    const barEndTime = (i + 1 < uninheritedTimingPoints.length) ? uninheritedTimingPoints[i+1].time : currentLastNoteTime + 2000;
                    for(let t = currentPoint.time; t < barEndTime; t += measureLength) {
                        barLines.push({time: t, scrollSpeed: getScrollMultiplier(t)});
                    }
                }
            }
            hitObjects.sort((a, b) => a.time - b.time);
            lastNoteTime = hitObjects.length > 0 ? (hitObjects[hitObjects.length - 1].endTime || hitObjects[hitObjects.length - 1].time) : 1;
            return hitObjects.length > 0;
        } catch (error) {
            console.error("Error during .osu parsing:", error);
            alert("譜面の解析に失敗しました。");
            return false;
        }
    }

    function handleSoundFile(e, soundType) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const dataUrl = event.target.result;
            if (soundType === 'don') {
                donSoundSrc = dataUrl;
                if (donSound) donSound.src = donSoundSrc;
            } else if (soundType === 'katsu') {
                katsuSoundSrc = dataUrl;
                if (katsuSound) katsuSound.src = katsuSoundSrc;
            }
        };
        reader.readAsDataURL(file);
    }
    
    function setupFileListeners() {
        dom.oszFileInput.addEventListener('change', handleOszFile);
        dom.beatmapSelector.addEventListener('change', handleBeatmapSelection);
        dom.donSoundFileInput.addEventListener('change', e => handleSoundFile(e, 'don'));
        dom.katsuSoundFileInput.addEventListener('change', e => handleSoundFile(e, 'katsu'));
    }
    async function handleOszFile(e) {
        const file = e.target.files[0]; if (!file) return;
        dom.fileName.textContent = file.name;
        resetGameAndFiles(false);
        dom.songTitleElement.textContent = '読み込み中...'; dom.songArtistElement.textContent = '';
        if (file.name.toLowerCase().endsWith('.osu')) {
            const reader = new FileReader();
            reader.onload = e => {
                fileContent = e.target.result;
                processSingleOsuFile(fileContent);
            };
            reader.readAsText(file, 'utf-8');
            return;
        }
        try {
            osz_zip = new JSZip();
            const zip = await osz_zip.loadAsync(file);
            const filePromises = [];
            osz_beatmaps = [];
            const imageExtensions = ['.jpg', '.jpeg', '.png'];
            const videoExtensions = ['.mp4', '.avi', '.webm'];
            zip.forEach((relativePath, zipEntry) => {
                const lowerCasePath = relativePath.toLowerCase();
                if (lowerCasePath.endsWith('.osu')) {
                    filePromises.push(zipEntry.async('string').then(content => {
                        const tempInfo = { title: '', artist: '', version: '' };
                        const lines = content.split('\n');
                        for(const line of lines) {
                           if (line.startsWith('Title:')) tempInfo.title = line.substring(6).trim();
                           else if (line.startsWith('Artist:')) tempInfo.artist = line.substring(7).trim();
                           else if (line.startsWith('Version:')) tempInfo.version = line.substring(8).trim();
                        }
                        osz_beatmaps.push({ name: relativePath, content: content, info: tempInfo });
                    }));
                } else if (videoExtensions.some(ext => lowerCasePath.endsWith(ext))) {
                    if (backgroundType !== 'video') {
                        filePromises.push(zipEntry.async('blob').then(blob => { backgroundUrl = URL.createObjectURL(blob); backgroundType = 'video'; }));
                    }
                } else if (imageExtensions.some(ext => lowerCasePath.endsWith(ext))) {
                     if (!backgroundType) {
                        filePromises.push(zipEntry.async('blob').then(blob => { backgroundUrl = URL.createObjectURL(blob); backgroundType = 'image'; }));
                    }
                }
            });
            await Promise.all(filePromises);
            if (osz_beatmaps.length === 0) { alert('.osuファイルが見つかりませんでした。'); resetGameAndFiles(); return; }
            dom.beatmapSelector.innerHTML = '<option value="">-- 難易度を選択 --</option>';
            osz_beatmaps.forEach((osuFile, index) => {
                const optionText = `${osuFile.info.version || osuFile.name}`;
                const option = new Option(optionText, index);
                dom.beatmapSelector.appendChild(option);
            });
            dom.beatmapSelectorContainer.style.display = 'block';
            const firstBeatmap = osz_beatmaps[0];
            dom.songTitleElement.textContent = firstBeatmap.info.title || '譜面を選択してください';
            dom.songArtistElement.textContent = firstBeatmap.info.artist || '';
        } catch (err) { alert('ファイルの読み込みに失敗しました。'); console.error(err); resetGameAndFiles(); }
    }
    async function handleBeatmapSelection() {
        const selectedIndex = dom.beatmapSelector.value;
        beatmapLoaded = false; audioLoaded = false;
        checkReadyState();
        if (selectedIndex === "") return;
        const selectedOsu = osz_beatmaps[parseInt(selectedIndex, 10)]; if (!selectedOsu) return;
        fileContent = selectedOsu.content;
        if (parseOsuFile(fileContent)) {
            beatmapLoaded = true;
            dom.songTitleElement.textContent = songInfo.title || '（タイトル不明）';
            dom.songArtistElement.textContent = songInfo.artist || '（アーティスト不明）';
            if (osz_zip && songInfo.audioFilename) {
                 const targetAudioName = songInfo.audioFilename.replace(/\\/g, '/').toLowerCase();
                 const audioFileEntry = Object.values(osz_zip.files).find(file => 
                    !file.dir && file.name.replace(/\\/g, '/').toLowerCase().endsWith(targetAudioName)
                 );
                 if(audioFileEntry) {
                    try {
                        const audioBlob = await audioFileEntry.async('blob');
                        if (audioSrc) URL.revokeObjectURL(audioSrc);
                        audioSrc = URL.createObjectURL(audioBlob);
                        dom.audioPlayer.src = audioSrc;
                        audioLoaded = true;
                    } catch(e) {
                        alert(`音声ファイル "${songInfo.audioFilename}" の読み込みに失敗しました。`);
                    }
                 } else {
                    alert(`音声ファイル "${songInfo.audioFilename}" が見つかりません。`);
                 }
            }
        }
        checkReadyState();
    }
    function processSingleOsuFile(content) {
        if (parseOsuFile(content)) {
            beatmapLoaded = true;
            dom.songTitleElement.textContent = songInfo.title || '（タイトル不明）';
            dom.songArtistElement.textContent = songInfo.artist || '（アーティスト不明）';
            alert('譜面を読み込みました。対応する音声ファイルを手動で選択してください。');
        }
        checkReadyState();
    }
    function resetGameAndFiles(clearFileInput = true) {
        resetGame();
        if (backgroundUrl) { URL.revokeObjectURL(backgroundUrl); backgroundUrl = null; backgroundType = null; }
        fileContent = null;
        osz_zip = null;
        osz_beatmaps = [];
        beatmapLoaded = false; audioLoaded = false;
        dom.beatmapSelectorContainer.style.display = 'none'; dom.beatmapSelector.innerHTML = '';
        if (clearFileInput) { dom.oszFileInput.value = ''; dom.fileName.textContent = '選択されていません'; }
        dom.songTitleElement.textContent = '譜面パッケージを選択してください'; dom.songArtistElement.textContent = '';
        checkReadyState();
    }
    function checkReadyState() {
        const manualAudioNeeded = !osz_zip;
        if(manualAudioNeeded && dom.audioPlayer.src && dom.audioPlayer.src !== window.location.href) {
            audioLoaded = true;
        }
        dom.startButton.disabled = !(beatmapLoaded && audioLoaded);
    }
    function updateSpeed() {
        const val = parseFloat(dom.speedSlider.value);
        const displayVal = (1.0 + val / 6.0).toFixed(1);
        dom.speedLabel.textContent = `スクロール速度 (x${displayVal})`;
        uiScrollSpeed = BASE_SCROLL_SPEED + val;
        if (uiScrollSpeed < 1) uiScrollSpeed = 1;
    }
    function updateLaneCover() {
        const type = dom.laneCoverType.value;
        const value = parseInt(dom.laneCoverSlider.value, 10);
        const sliderContainer = document.getElementById('lane-cover-slider-container');
        dom.laneCoverLabel.textContent = `カバー量 (${value}%)`;
        laneCoverConfig = { type, value };
        if (type === 'none') {
            sliderContainer.style.display = 'none';
        } else {
            sliderContainer.style.display = 'block';
        }
    }
    function updateTouchDrumSize() {
        const value = dom.touchDrumSizeSlider.value;
        dom.touchDrumSizeLabel.textContent = `タッチ太鼓の大きさ (${value}vh)`;
        const drumContainer = dom.gameContainer.querySelector('#touch-drum-visual');
        drumContainer.style.setProperty('--touch-drum-size-vh', `${value}vh`);
        drumContainer.style.setProperty('--touch-drum-container-height-vh', `${value / 2}vh`);
        const rimThickness = Math.max(2, value / 18);
        drumContainer.style.setProperty('--touch-drum-rim-thickness-vh', `${rimThickness}vh`);
    }
    function updateTouchDrumYOffset() {
        const value = dom.touchDrumYOffsetSlider.value;
        dom.touchDrumYOffsetLabel.textContent = `タッチ太鼓のY軸オフセット (${value}vh)`;
        const drumContainer = dom.gameContainer.querySelector('#touch-drum-visual');
        drumContainer.style.setProperty('--touch-drum-y-offset-vh', `${value}vh`);
    }

    function updateTouchDrumOpacity() {
        const value = dom.touchDrumOpacitySlider.value;
        const opacity = value / 100;
        dom.touchDrumOpacityLabel.textContent = `タッチ太鼓の不透明度 (${value}%)`;
        dom.touchDrumVisual.style.setProperty('--touch-drum-opacity', opacity);
    }

    function updateJudgmentWindows() {
        let perfect = parseInt(dom.hitWindowPerfectInput.value, 10);
        let good = parseInt(dom.hitWindowGoodInput.value, 10);
        let bad = parseInt(dom.hitWindowBadInput.value, 10);
        if (isNaN(perfect) || isNaN(good) || isNaN(bad)) return;
        if (perfect < 1) perfect = 1;
        if (good < perfect) good = perfect;
        if (bad < good) bad = good;
        HIT_WINDOW_PERFECT = perfect;
        HIT_WINDOW_GOOD = good;
        HIT_WINDOW_BAD = bad;
        dom.hitWindowPerfectInput.value = HIT_WINDOW_PERFECT;
        dom.hitWindowGoodInput.value = HIT_WINDOW_GOOD;
        dom.hitWindowBadInput.value = HIT_WINDOW_BAD;
    }

    function initKeyConfig() {
        dom.keyConfigInputs.querySelectorAll('.key-config-input').forEach(keyInput => {
            keyInput.addEventListener('click', e => {
                if (isGameRunning) return;
                document.querySelectorAll('.key-config-input.is-waiting').forEach(el => el.blur());
                e.currentTarget.textContent = '...';
                e.currentTarget.classList.add('is-waiting');
            });
            keyInput.addEventListener('blur', e => {
                const keyId = e.currentTarget.dataset.keyId;
                e.currentTarget.classList.remove('is-waiting');
                e.currentTarget.textContent = KEYS[keyId];
            });
            keyInput.addEventListener('keydown', e => {
                e.preventDefault();
                const keyDiv = e.currentTarget;
                if (!keyDiv.classList.contains('is-waiting')) return;
                if (e.key === 'Escape') { keyDiv.blur(); return; }
                const newKey = e.key.toUpperCase();
                if (newKey.length > 1 && !['SPACE', 'BACKSPACE', 'ENTER'].includes(newKey) ) return;
                const keyId = keyDiv.dataset.keyId;
                if (Object.values(KEYS).some((key, k_idx) => key === newKey && Object.keys(KEYS)[k_idx] !== keyId)) {
                    alert('そのキーは他のアクションで既に使用されています。');
                    return;
                }
                KEYS[keyId] = newKey;
                keyDiv.blur();
            });
        });
    }
    function saveSettings() {
        try {
            updateJudgmentWindows(); // Ensure latest values are captured before saving
            const settings = {
                scrollSpeed: dom.speedSlider.value,
                offset: dom.offsetInput.value,
                laneCoverType: dom.laneCoverType.value,
                laneCoverValue: dom.laneCoverSlider.value,
                touchDrumSize: dom.touchDrumSizeSlider.value,
                touchDrumYOffset: dom.touchDrumYOffsetSlider.value,
                touchDrumOpacity: dom.touchDrumOpacitySlider.value,
                autoPlay: dom.autoPlayCheckbox.checked,
                singleHandBigNote: dom.singleHandBigNoteCheckbox.checked,
                keys: KEYS,
                donSoundDataUrl: donSoundSrc,
                katsuSoundDataUrl: katsuSoundSrc,
                hitWindowPerfect: HIT_WINDOW_PERFECT,
                hitWindowGood: HIT_WINDOW_GOOD,
                hitWindowBad: HIT_WINDOW_BAD,
            };
            localStorage.setItem('taikoPlayerSettings', JSON.stringify(settings));
            dom.settingsStatus.textContent = '設定を保存しました！';
            setTimeout(() => { dom.settingsStatus.textContent = ''; }, 3000);
        } catch (e) {
            console.error('Error saving settings:', e);
            dom.settingsStatus.textContent = '設定の保存に失敗しました。';
            setTimeout(() => { dom.settingsStatus.textContent = ''; }, 3000);
        }
    }
    function loadSettings() {
        const savedSettings = localStorage.getItem('taikoPlayerSettings');
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);

                if (settings.scrollSpeed !== undefined) dom.speedSlider.value = settings.scrollSpeed;
                if (settings.offset !== undefined) dom.offsetInput.value = settings.offset;
                if (settings.laneCoverType !== undefined) dom.laneCoverType.value = settings.laneCoverType;
                if (settings.laneCoverValue !== undefined) dom.laneCoverSlider.value = settings.laneCoverValue;
                if (settings.touchDrumSize !== undefined) dom.touchDrumSizeSlider.value = settings.touchDrumSize;
                if (settings.touchDrumYOffset !== undefined) dom.touchDrumYOffsetSlider.value = settings.touchDrumYOffset;
                if (settings.touchDrumOpacity !== undefined) dom.touchDrumOpacitySlider.value = settings.touchDrumOpacity;
                if (settings.autoPlay !== undefined) dom.autoPlayCheckbox.checked = settings.autoPlay;
                if (settings.singleHandBigNote !== undefined) dom.singleHandBigNoteCheckbox.checked = settings.singleHandBigNote;
                if (settings.keys) KEYS = settings.keys;
                if (settings.donSoundDataUrl) donSoundSrc = settings.donSoundDataUrl;
                if (settings.katsuSoundDataUrl) katsuSoundSrc = settings.katsuSoundDataUrl;
                if (settings.hitWindowPerfect !== undefined) HIT_WINDOW_PERFECT = settings.hitWindowPerfect;
                if (settings.hitWindowGood !== undefined) HIT_WINDOW_GOOD = settings.hitWindowGood;
                if (settings.hitWindowBad !== undefined) HIT_WINDOW_BAD = settings.hitWindowBad;
                
            } catch (e) {
                console.error('Error parsing saved settings:', e);
                localStorage.removeItem('taikoPlayerSettings');
            }
        }
        
        // Update all UI elements and labels from the current values (either default or loaded)
        updateSpeed();
        updateLaneCover();
        updateTouchDrumSize();
        updateTouchDrumYOffset();
        updateTouchDrumOpacity();
        dom.hitWindowPerfectInput.value = HIT_WINDOW_PERFECT;
        dom.hitWindowGoodInput.value = HIT_WINDOW_GOOD;
        dom.hitWindowBadInput.value = HIT_WINDOW_BAD;
        updateJudgmentWindows(); // To validate and sync variables
        Object.keys(KEYS).forEach(keyId => {
            const elId = `key-${keyId.replace('_', '-')}`;
            document.getElementById(elId).textContent = KEYS[keyId];
        });
    }
    function initGameUI() {
        const rect = dom.playfield.getBoundingClientRect();
        dom.canvas.width = rect.width;
        dom.canvas.height = rect.height;
        updateLaneCover();
    }
    function resetGame() {
        score = 0; combo = 0; maxCombo = 0; totalPauseDuration = 0;
        judgmentCounts = { ryo: 0, ka: 0, fuka: 0 };
        accuracy = 100;
        dom.scoreElement.textContent = score;
        dom.accuracyElement.textContent = `S 100.00%`;
        updateComboDisplay();
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        hitObjects.forEach(note => note.judged = false);
        lastCheckedNoteIndex = 0;
        activeRollHits = 0;
        rollCounterClearTime = 0;
        isGoGoNow = false;
        pressedKeys.clear();
        dom.resultsOverlay.style.display = 'none';
        isGameRunning = false; isPaused = false;
    }
    function startGame() {
        // フルスクリーンAPIが利用可能か確認し、実行する
        if (dom.gameContainer.requestFullscreen) {
            dom.gameContainer.requestFullscreen().catch(err => {
                // ユーザーが許可しなかった場合などのエラーはコンソールに出力
                console.log(`フルスクリーンモードへの移行に失敗しました: ${err.message} (${err.name})`);
            });
        }
        
        if (isGameRunning || !beatmapLoaded || !audioLoaded) return;
        resetGame();
        dom.appContainer.style.display = 'none';
        dom.gameContainer.style.display = 'block';
        initGameUI();
        
        updateLaneCover();
        dom.backgroundVideo.style.display = 'none';
        dom.backgroundImage.style.display = 'none';
        if (backgroundUrl) {
            if (backgroundType === 'video') {
                dom.backgroundVideo.src = backgroundUrl;
                dom.backgroundVideo.style.display = 'block';
                dom.backgroundVideo.currentTime = 0;
                dom.backgroundVideo.play();
            } else if (backgroundType === 'image') {
                dom.backgroundImage.src = backgroundUrl;
                dom.backgroundImage.style.display = 'block';
            }
        }
        isGameRunning = true; isPaused = false;
        isAutoPlay = dom.autoPlayCheckbox.checked;
        isSingleHandBigNoteEnabled = dom.singleHandBigNoteCheckbox.checked;
        offset = parseInt(dom.offsetInput.value, 10) || 0;
        if (donSoundSrc) donSound = new Audio(donSoundSrc);
        if (katsuSoundSrc) katsuSound = new Audio(katsuSoundSrc);
        gameStartTime = performance.now() + 3000;
        totalPauseDuration = 0;
        dom.audioPlayer.currentTime = 0;
        setTimeout(() => {
            if(isGameRunning && !isPaused) {
                dom.audioPlayer.play();
            }
        }, 3000);
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    function getGameTime() {
        if(isPaused) return pauseStartTime - gameStartTime - totalPauseDuration;
        return performance.now() - gameStartTime - totalPauseDuration;
    }
    function gameLoop() {
        if (!isGameRunning) return;
        animationFrameId = requestAnimationFrame(gameLoop);
        if (isPaused) return;
        const elapsedTime = getGameTime() - offset;
        isGoGoNow = false;
        for (const section of goGoSections) {
            if (elapsedTime >= section.start && elapsedTime < section.end) {
                isGoGoNow = true; break;
            }
        }
        dom.ctx.clearRect(0, 0, dom.canvas.width, dom.canvas.height);
        drawGameArea(isGoGoNow);
        dom.ctx.save();
        if (laneCoverConfig.type === 'right' && laneCoverConfig.value > 0) {
            const clipX = dom.canvas.width * (1 - laneCoverConfig.value / 100);
            dom.ctx.beginPath();
            dom.ctx.rect(0, 0, clipX, dom.canvas.height);
            dom.ctx.clip();
        }
        drawBarLines(elapsedTime);
        drawNotes(elapsedTime);
        dom.ctx.restore();
        drawRollCounter(elapsedTime);
        if (isAutoPlay) {
            autoPlayHandler(elapsedTime);
        } else {
            checkMisses(elapsedTime);
        }
        const progress = Math.min(1, elapsedTime / lastNoteTime);
        dom.progressBar.style.width = (progress * 100) + '%';
        if (progress >= 1 && elapsedTime > lastNoteTime + 3000) {
            showResults();
        }
    }
    function drawGameArea(isGoGo) {
        const y = dom.canvas.height / 2;
        if (isGoGo) {
             const fireGradient = dom.ctx.createLinearGradient(0, 0, 0, dom.canvas.height);
             fireGradient.addColorStop(0, "rgba(255, 100, 0, 0.4)");
             fireGradient.addColorStop(0.5, "rgba(255, 69, 0, 0.6)");
             fireGradient.addColorStop(1, "rgba(255, 100, 0, 0.4)");
             dom.ctx.fillStyle = fireGradient;
             dom.ctx.fillRect(0, 0, dom.canvas.width, dom.canvas.height);
        }
        const baseRadius = dom.canvas.height * 0.45;
        const judgeCircleRadius = baseRadius * taikoSizeMultiplier;
        dom.ctx.fillStyle = '#ffc0cb';
        dom.ctx.beginPath();
        dom.ctx.arc(JUDGE_POINT_X, y, judgeCircleRadius, 0, Math.PI * 2);
        dom.ctx.fill();
        dom.ctx.fillStyle = '#d2b48c';
        dom.ctx.beginPath();
        dom.ctx.arc(JUDGE_POINT_X, y, judgeCircleRadius * 0.8, 0, Math.PI * 2);
        dom.ctx.fill();
        dom.ctx.strokeStyle = '#a0522d';
        dom.ctx.lineWidth = judgeCircleRadius * 0.15;
        dom.ctx.beginPath();
        dom.ctx.arc(JUDGE_POINT_X, y, judgeCircleRadius * 0.9, 0, Math.PI * 2);
        dom.ctx.stroke();
        dom.ctx.strokeStyle = '#fff'; dom.ctx.lineWidth = 2;
        dom.ctx.beginPath(); dom.ctx.arc(JUDGE_POINT_X, y, judgeCircleRadius * 0.5, 0, Math.PI * 2); dom.ctx.stroke();
    }
    function drawBarLines(elapsedTime) {
        const pixelMultiplier = uiScrollSpeed * 0.1;
        dom.ctx.strokeStyle = '#FFFFFF'; dom.ctx.lineWidth = 2; dom.ctx.globalAlpha = 0.5;
        barLines.forEach(line => {
            const timeToJudge = line.time - elapsedTime;
            const x = JUDGE_POINT_X + timeToJudge * line.scrollSpeed * pixelMultiplier;
            if (x > dom.canvas.width + 50 || x < JUDGE_POINT_X - 50) return;
            dom.ctx.beginPath(); dom.ctx.moveTo(x, 0); dom.ctx.lineTo(x, dom.canvas.height); dom.ctx.stroke();
        });
        dom.ctx.globalAlpha = 1.0;
    }
    function drawNotes(elapsedTime) {
        const y = dom.canvas.height / 2;
        const pixelMultiplier = uiScrollSpeed * 0.1;
        for (const note of hitObjects) {
            if (note.judged) continue;
            const timeToJudge = note.time - elapsedTime;
            const startX = JUDGE_POINT_X + timeToJudge * note.scrollSpeed * pixelMultiplier;
            if (note.type === 'roll' || note.type === 'balloon') {
                const timeToEnd = note.endTime - elapsedTime;
                const endX = JUDGE_POINT_X + timeToEnd * note.scrollSpeed * pixelMultiplier;
                if (endX < JUDGE_POINT_X - 50 || startX > dom.canvas.width + 50) continue;
                if (note.type === 'roll') {
                    const barHeight = note.isBig ? y * 1.1 : y * 0.8;
                    const radius = barHeight / 2;
                    dom.ctx.fillStyle = "gold"; dom.ctx.lineWidth = 2; dom.ctx.strokeStyle = '#fff';
                    dom.ctx.beginPath(); dom.ctx.rect(startX, y - radius, endX - startX, barHeight); dom.ctx.fill(); dom.ctx.stroke();
                    dom.ctx.beginPath(); dom.ctx.arc(startX, y, radius, 0, Math.PI * 2); dom.ctx.fill(); dom.ctx.stroke();
                    dom.ctx.strokeStyle = 'gold'; 
                    dom.ctx.beginPath(); dom.ctx.arc(endX, y, radius, 0, Math.PI * 2); dom.ctx.fill(); dom.ctx.stroke();
                } else {
                    const radius = y * 0.6;
                    let currentX = startX;
                    if (startX < JUDGE_POINT_X && endX > JUDGE_POINT_X) currentX = JUDGE_POINT_X;
                    if (currentX < -radius || currentX > dom.canvas.width + radius) continue;
                    dom.ctx.beginPath(); dom.ctx.fillStyle = "orange"; dom.ctx.strokeStyle = '#fff'; dom.ctx.lineWidth = 3;
                    dom.ctx.arc(currentX, y, radius, 0, Math.PI * 2); dom.ctx.fill(); dom.ctx.stroke();
                    const remainingHits = note.hitsRequired - note.hitsMade;
                    if (remainingHits > 0) {
                        dom.ctx.fillStyle = '#fff'; dom.ctx.font = `bold ${radius}px sans-serif`; dom.ctx.textAlign = 'center'; dom.ctx.textBaseline = 'middle';
                        dom.ctx.fillText(remainingHits, currentX, y);
                    }
                }
            } else {
                if (startX > dom.canvas.width + 50 || startX < JUDGE_POINT_X - 50) continue;
                const radius = note.isBig ? y * 0.7 : y * 0.45;
                dom.ctx.beginPath(); dom.ctx.fillStyle = note.type === 'don' ? '#ff4d6d' : '#4dabf7';
                dom.ctx.strokeStyle = '#fff'; dom.ctx.lineWidth = 2;
                dom.ctx.arc(startX, y, radius, 0, Math.PI * 2); dom.ctx.fill(); dom.ctx.stroke();
            }
        }
    }
    function drawRollCounter(elapsedTime) {
        if (rollCounterClearTime > 0 && elapsedTime >= rollCounterClearTime) {
            activeRollHits = 0;
            rollCounterClearTime = 0;
        }
        if (activeRollHits > 0) {
            const drumRect = dom.drumDisplay.getBoundingClientRect();
            const gameRect = dom.gameContainer.getBoundingClientRect();
            const left = (drumRect.left - gameRect.left) + (drumRect.width / 2);
            const top = (drumRect.top - gameRect.top)  + 15;
            dom.rollCounter.style.left = `${left}px`;
            dom.rollCounter.style.top = `${top}px`;
            dom.rollCounter.textContent = activeRollHits;
            dom.rollCounter.style.display = 'block';
        } else {
            dom.rollCounter.style.display = 'none';
        }
    }
    function playHitSound(type) {
        const sound = (type === 'don') ? donSound : katsuSound;
        if (sound) {
            sound.currentTime = 0;
            sound.play().catch(e => {});
        }
    }
    function autoPlayHandler(elapsedTime) {
        const AUTO_HIT_INTERVAL = 25;
        for (const note of hitObjects) {
            if (note.judged) continue;
            if (note.type === 'balloon' || note.type === 'roll') {
                if (elapsedTime >= note.time && elapsedTime <= note.endTime) {
                     if (elapsedTime - (note.lastAutoHitTime || 0) > AUTO_HIT_INTERVAL) {
                        playHitSound('don');
                        let hitScore = 100; if (isGoGoNow) hitScore *= 1.2;
                        score += hitScore; note.hitsMade++;
                        if (note.type === 'roll') {
                            activeRollHits = note.hitsMade; rollCounterClearTime = 0; 
                        } else if (note.type === 'balloon' && note.hitsMade >= note.hitsRequired) {
                            let burstBonus = 5000; if (isGoGoNow) burstBonus *= 1.2;
                            score += burstBonus; note.judged = true;
                        }
                        dom.scoreElement.textContent = Math.floor(score);
                        note.lastAutoHitTime = elapsedTime;
                     }
                }
                if (elapsedTime > note.endTime && !note.judged) {
                    if (note.type === 'roll' && note.hitsMade > 0) rollCounterClearTime = elapsedTime + 2000;
                    note.judged = true;
                }
            } else if (elapsedTime >= note.time) {
                playHitSound(note.type);
                handleJudgment('ryo', note);
            }
        }
    }
    function showDrumHit(keyId) {
        const hitMap = {
            don_left: dom.drumDonLeft,
            don_right: dom.drumDonRight,
            katsu_left: dom.drumKatsuLeft,
            katsu_right: dom.drumKatsuRight,
        };
        const element = hitMap[keyId];
        if (!element) return;
        if (drumHitTimeouts[keyId]) {
            clearTimeout(drumHitTimeouts[keyId]);
        }
        element.classList.add('active');
        drumHitTimeouts[keyId] = setTimeout(() => {
            element.classList.remove('active');
        }, 100);
    }
    function processPlayerHit(keyId) {
        if (!isGameRunning || isPaused || isAutoPlay) return;
        const elapsedTime = getGameTime() - offset;
        if (elapsedTime < -500) return;
        showDrumHit(keyId);
        const keyType = keyId.startsWith('don') ? 'don' : 'katsu';
        let isLongNoteHit = false;
        for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) {
                const note = hitObjects[i];
                if (note.judged) continue;
                if (elapsedTime >= note.time && elapsedTime <= note.endTime + HIT_WINDOW_BAD) {
                    if (note.type === 'roll' && (note.isBig || keyType === 'don')) {
                        playHitSound('don');
                        let rollHitScore = note.isBig ? 200 : 100; if (isGoGoNow) rollHitScore *= 1.2;
                        score += rollHitScore; note.hitsMade++; activeRollHits = note.hitsMade;
                        rollCounterClearTime = 0;
                        dom.scoreElement.textContent = Math.floor(score);
                        isLongNoteHit = true; break;
                    } else if (note.type === 'balloon' && keyType === 'don') {
                        playHitSound('don');
                        note.hitsMade++;
                        let balloonHitScore = 300; if (isGoGoNow) balloonHitScore *= 1.2;
                        score += balloonHitScore;
                        dom.scoreElement.textContent = Math.floor(score);
                        if (note.hitsMade >= note.hitsRequired) {
                            let balloonBurstBonus = 5000; if (isGoGoNow) balloonBurstBonus *= 1.2;
                            score += balloonBurstBonus; note.judged = true;
                        }
                        isLongNoteHit = true; break;
                    }
                }
                if (note.time > elapsedTime + 200) break; 
        }
        if (isLongNoteHit) return;
        let targetNote = null, minTimeDiff = Infinity;
        for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) {
            const note = hitObjects[i];
            if (note.judged || note.type === 'balloon' || note.type === 'roll') continue;
            const timeDiff = Math.abs(note.time - elapsedTime);
            if (timeDiff <= HIT_WINDOW_BAD) {
                if (timeDiff < minTimeDiff) { minTimeDiff = timeDiff; targetNote = note; }
            }
            if (note.time > elapsedTime + HIT_WINDOW_BAD + 100) break;
        }
        if (targetNote) {
            if (targetNote.type === keyType) {
                playHitSound(keyType);
                const actualTimeDiff = Math.abs(targetNote.time - elapsedTime);
                if (actualTimeDiff <= HIT_WINDOW_PERFECT) handleJudgment('ryo', targetNote);
                else if (actualTimeDiff <= HIT_WINDOW_GOOD) handleJudgment('ka', targetNote);
                else handleJudgment('fuka', targetNote);
            } else { 
                handleJudgment('fuka', targetNote);
            }
        }
    }
    document.addEventListener('keydown', e => {
        if (e.repeat) return;
        const key = e.key.toUpperCase();
        pressedKeys.add(key);
        let hitKeyId = null;
        for (const id in KEYS) {
            if (KEYS[id] === key) {
                hitKeyId = id;
                break;
            }
        }
        if (hitKeyId) {
            processPlayerHit(hitKeyId);
        }
    });
    document.addEventListener('keyup', e => {
        pressedKeys.delete(e.key.toUpperCase());
    });
    function checkMisses(elapsedTime) {
        for (let i = lastCheckedNoteIndex; i < hitObjects.length; i++) {
            const note = hitObjects[i];
            if (note.judged) {
                if (i === lastCheckedNoteIndex) lastCheckedNoteIndex++;
                continue;
            }
            if (note.time > elapsedTime + HIT_WINDOW_BAD) break;
            if (note.type !== 'balloon' && note.type !== 'roll') {
                if (elapsedTime > note.time + HIT_WINDOW_BAD) {
                    handleJudgment('fuka', note);
                }
            } else {
                if (elapsedTime > note.endTime) {
                    if (note.type === 'roll' && note.hitsMade > 0) rollCounterClearTime = elapsedTime + 2000;
                    note.judged = true;
                }
            }
        }
    }
    function handleJudgment(judgement, note) {
        if(note.judged) return;
        note.judged = true;
        const judgmentMap = { ryo: '良', ka: '可', fuka: '不可'};
        showJudgment(judgmentMap[judgement]);
        judgmentCounts[judgement]++;
        if(judgement === 'ryo' || judgement === 'ka') {
            const basePoints = judgement === 'ryo' ? 300 : 100;
            let scoreMultiplier = 1;
            if(note.isBig) {
                if (isSingleHandBigNoteEnabled) {
                    scoreMultiplier = 2;
                } else {
                     const isDonHit = note.type === 'don' && pressedKeys.has(KEYS.don_left) && pressedKeys.has(KEYS.don_right);
                     const isKatsuHit = note.type === 'katsu' && pressedKeys.has(KEYS.katsu_left) && pressedKeys.has(KEYS.katsu_right);
                     if (isDonHit || isKatsuHit) scoreMultiplier = 2;
                }
            }
            updateScore(basePoints * scoreMultiplier);
            updateCombo(true);
        } else {
            updateCombo(false);
        }
        updateAccuracy();
    }
    function updateScore(points) {
        let currentPoints = points + (points * Math.floor(combo / 10) * 0.1);
        if(isGoGoNow) {
            currentPoints *= 1.2;
        }
        score += currentPoints;
        dom.scoreElement.textContent = Math.floor(score);
    }
    function updateCombo(hit) {
        if (hit) {
            combo++;
            if (combo > maxCombo) maxCombo = combo;
        } else {
            combo = 0;
        }
        updateComboDisplay();
    }
    function updateAccuracy() {
        const totalHits = judgmentCounts.ryo + judgmentCounts.ka + judgmentCounts.fuka;
        if (totalHits === 0) {
            accuracy = 100;
        } else {
            const accVal = (judgmentCounts.ryo * 300 + judgmentCounts.ka * 150) / (totalHits * 300);
            accuracy = accVal * 100;
        }
        let rank;
        if (accuracy >= 95) rank = 'S';
        else if (accuracy >= 90) rank = 'A';
        else if (accuracy >= 80) rank = 'B';
        else if (accuracy >= 70) rank = 'C';
        else rank = 'D';
        dom.accuracyElement.textContent = `${rank} ${accuracy.toFixed(2)}%`;
    }
    function showJudgment(text) {
        const el = dom.judgmentTextElement;
        const judgmentStyles = {
            "良": 'gold', "可": 'white', "不可": '#dda0dd'
        };
        el.textContent = text;
        el.style.color = judgmentStyles[text] || 'white';
        el.style.animation = 'none';
        void el.offsetHeight;
        el.style.animation = null;
    }
    function updateComboDisplay() {
        if (combo > 0) {
            dom.comboElement.textContent = combo;
            dom.comboDisplay.classList.add('visible');
        } else {
            dom.comboDisplay.classList.remove('visible');
        }
    }
    function togglePause() {
        if (!isGameRunning) return; isPaused = !isPaused;
        if (isPaused) {
            pauseStartTime = performance.now();
            dom.audioPlayer.pause();
            if (backgroundType === 'video') dom.backgroundVideo.pause();
            cancelAnimationFrame(animationFrameId);
            dom.pauseOverlay.style.display = 'flex';
        } else {
            totalPauseDuration += performance.now() - pauseStartTime;
            dom.audioPlayer.play();
            if (backgroundType === 'video') dom.backgroundVideo.play();
            animationFrameId = requestAnimationFrame(gameLoop);
            dom.pauseOverlay.style.display = 'none';
        }
    }
    document.addEventListener('keydown', e => { if(e.key === 'Escape') togglePause(); });
    function retryGame() {
        isGameRunning = false; isPaused = false;
        dom.audioPlayer.pause(); dom.audioPlayer.currentTime = 0;
        if (backgroundType === 'video') dom.backgroundVideo.pause();
        dom.pauseOverlay.style.display = 'none';
        dom.resultsOverlay.style.display = 'none';
        if (beatmapLoaded && audioLoaded) {
            startGame();
        } else {
            backToTitle();
        }
    }
    function backToTitle() {
        // ★★★★★ 修正点：フルスクリーンモードを解除する処理を追加 ★★★★★
        if (document.exitFullscreen) {
            document.exitFullscreen().catch((err) => console.error(`フルスクリーン解除に失敗: ${err.message}`));
        }
        // ★★★★★ 修正ここまで ★★★★★

        isGameRunning = false; isPaused = false;
        if(dom.audioPlayer) dom.audioPlayer.pause();
        if (backgroundType === 'video' && dom.backgroundVideo) dom.backgroundVideo.pause();
        dom.pauseOverlay.style.display = 'none';
        dom.resultsOverlay.style.display = 'none';
        dom.gameContainer.style.display = 'none';
        dom.appContainer.style.display = 'flex';
        resetGame();
        checkReadyState();
        checkDeviceAndOrientation(); // Re-check orientation when going back to title
    }
    function showResults() {
        if(!isGameRunning && dom.resultsOverlay.style.display === 'flex') return;
        isGameRunning = false;
        
        cancelAnimationFrame(animationFrameId);

        // Populate basic info
        dom.resultsSongTitle.textContent = `${songInfo.title} - ${songInfo.version}`;
        dom.resultsScoreValue.textContent = Math.floor(score);
        dom.resultsMaxComboValue.textContent = maxCombo;
        dom.resultsRyoValue.textContent = judgmentCounts.ryo;
        dom.resultsKaValue.textContent = judgmentCounts.ka;
        dom.resultsFukaValue.textContent = judgmentCounts.fuka;

        // Calculate and display rank
        let rank;
        if (accuracy >= 95) rank = 'S';
        else if (accuracy >= 90) rank = 'A';
        else if (accuracy >= 80) rank = 'B';
        else if (accuracy >= 70) rank = 'C';
        else rank = 'D';

        const rankValueEl = dom.resultsRankValue;
        rankValueEl.textContent = rank;
        rankValueEl.className = ''; // Clear previous classes
        rankValueEl.classList.add(`rank-${rank.toLowerCase()}`);
        
        dom.resultsOverlay.style.display = 'flex';
        if (backgroundType === 'video') dom.backgroundVideo.pause();
    }
    function setupTouchListeners() {
        dom.touchControls.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const vh = window.innerHeight / 100;
            const drumSizeVh = parseFloat(dom.touchDrumSizeSlider.value);
            const yOffsetVh = parseFloat(dom.touchDrumYOffsetSlider.value);
            const rimThicknessVh = Math.max(2, drumSizeVh / 18);
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight + (yOffsetVh * vh);
            const outerRadius = (drumSizeVh * vh) / 2;
            const rimThicknessPx = rimThicknessVh * vh;
            const innerRadius = outerRadius - rimThicknessPx;
            for (const touch of e.changedTouches) {
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                const dx = touchX - centerX;
                const dy = touchY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                let hitType = 'katsu';
                if (distance <= innerRadius) {
                    hitType = 'don';
                }
                const side = (touchX < centerX) ? 'left' : 'right';
                const hitKeyId = `${hitType}_${side}`;
                processPlayerHit(hitKeyId);
            }
        }, { passive: false });
    }

    // --- 初期化処理 ---
    initKeyConfig();
    setupFileListeners();
    setupTouchListeners();
    loadSettings();
    dom.laneCoverType.addEventListener('change', updateLaneCover);
    dom.laneCoverSlider.addEventListener('input', updateLaneCover);
    dom.touchDrumSizeSlider.addEventListener('input', updateTouchDrumSize);
    dom.touchDrumYOffsetSlider.addEventListener('input', updateTouchDrumYOffset);
    dom.touchDrumOpacitySlider.addEventListener('input', updateTouchDrumOpacity);
    dom.saveSettingsButton.addEventListener('click', saveSettings);
    dom.startButton.addEventListener('click', startGame);
    dom.speedSlider.addEventListener('input', updateSpeed);
    dom.hitWindowPerfectInput.addEventListener('change', updateJudgmentWindows);
    dom.hitWindowGoodInput.addEventListener('change', updateJudgmentWindows);
    dom.hitWindowBadInput.addEventListener('change', updateJudgmentWindows);
    dom.ingamePauseButton.addEventListener('click', togglePause);
    dom.resumeButton.addEventListener('click', togglePause);
    dom.retryButton.addEventListener('click', retryGame);
    dom.backToTitlePause.addEventListener('click', backToTitle);
    dom.resultsRetryButton.addEventListener('click', retryGame);
    dom.backToTitleResults.addEventListener('click', backToTitle);
    dom.audioPlayer.addEventListener('canplaythrough', () => {
       if(!osz_zip) {
            audioLoaded = true;
            checkReadyState();
       }
    });
    
    window.addEventListener('resize', () => {
        checkDeviceAndOrientation();
        initGameUI();
    });
    document.addEventListener('DOMContentLoaded', checkDeviceAndOrientation);


    // --- PWA対応 ---
    document.addEventListener('DOMContentLoaded', () => {
        const iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><rect width="512" height="512" fill="#1f2940"/><circle cx="256" cy="256" r="220" fill="#d9534f"/><circle cx="256" cy="256" r="180" fill="none" stroke="#ffffff" stroke-width="20"/></svg>`;
        const iconDataUrl = `data:image/svg+xml;base64,${btoa(iconSvg)}`;
        const manifestContent = {
            "name": "Taiko Player",
            "short_name": "Taiko",
            "start_url": ".",
            "display": "standalone",
            "background_color": "#1f2940",
            "theme_color": "#d9534f",
            "description": "A web-based Taiko no Tatsujin simulator.",
            "icons": [
                { "src": iconDataUrl, "type": "image/svg+xml", "sizes": "192x192" },
                { "src": iconDataUrl, "type": "image/svg+xml", "sizes": "512x512" }
            ]
        };
        const manifestBlob = new Blob([JSON.stringify(manifestContent)], {type: 'application/json'});
        const manifestUrl = URL.createObjectURL(manifestBlob);
        document.getElementById('manifest').setAttribute('href', manifestUrl);
        document.getElementById('apple-icon').setAttribute('href', iconDataUrl);
        const swCode = `self.addEventListener('install',(e)=>self.skipWaiting());self.addEventListener('fetch',(e)=>{});`;
        const swBlob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(swBlob);
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register(swUrl)
                .then(reg => console.log('Service Worker registered successfully:', reg))
                .catch(err => console.log('Service Worker registration failed:', err));
        }
    });
    </script>
</body>
</html>
